<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">





  <link rel="alternate" href="/atom.xml" title="寿司卷code" type="application/atom+xml">






<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux运维常见问题">
<meta property="og:url" content="https://imauu.gitee.io/2022/05/01/Linux运维常见问题/index.html">
<meta property="og:site_name" content="寿司卷code">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gixjr757h0j30sg0lc0tx.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ta05y5ijj21440aowhm.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1t9yzafvnj21fs0fsjvu.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1t9rze7sbj216u0joac7.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1t9yf5lrdj21yi06a0ut.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h1tan27h2uj21dn0u0wo9.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h213m79jt0j20ug0iidhc.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h6k5rk6g3xj210e0l6769.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h6m7ampiwdj20i40cmt9j.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h6fmy1qp5fj21ck0ty0vh.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h6fnhtxp5nj21ay0o077d.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h6fnt21f6pj21au0pwwj5.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ipn8fu0nj21710u0acq.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-1c44ad58e68f9997dcb5c28d55ce1dbd_1440w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-9d44bdbdfd3e2d1ab5dab401796230da_1440w.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-91a75c8f444894425aab4dc1bcda3d27_1440w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-7218789ff54d1e5173ebbccb1fca7b52_1440w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-e2b95d909d2c82d9320faef7a4e30484_1440w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-5689efac56e639b1688abd2cb3b9bc9c_1440w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-a68f90cbe319f0cf041340ccc3b319cd_1440w.jpg">
<meta property="og:updated_time" content="2022-09-28T04:41:19.344Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux运维常见问题">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlgy1gixjr757h0j30sg0lc0tx.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":14,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://imauu.gitee.io/2022/05/01/Linux运维常见问题/">






  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "1db79efd"
    });
  daovoice('update');
  </script>



  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "1db79efd"
    });
  daovoice('update');
  </script>



  <title>Linux运维常见问题 | 寿司卷code</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <!--
    <a href="https://github.com/shang-code/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>
    -->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">寿司卷code</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不拼尽全力试一下，又怎么会知道啊。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://imauu.gitee.io/2022/05/01/Linux运维常见问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="尚先森">
      <meta itemprop="description" content>
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/e6c9d24ely1h4nm4ry4apj205i05ia9y.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="寿司卷code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux运维常见问题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-05-01T21:42:58+08:00">
                2022-05-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2022-09-28T12:41:19+08:00">
                2022-09-28
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2022/05/01/Linux运维常见问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2022/05/01/Linux运维常见问题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  39.8k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  147 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gixjr757h0j30sg0lc0tx.jpg" alt="linux_tubiao" style="zoom:67%;">

<a id="more"></a>

<p>面试题可以参考:<a href="https://blog.csdn.net/weixin_45548465/article/details/104986399" target="_blank" rel="noopener">面试题总结</a></p>
<h1 id="查看系统相关信息"><a href="#查看系统相关信息" class="headerlink" title="查看系统相关信息"></a>查看系统相关信息</h1><h2 id="查看网卡流量"><a href="#查看网卡流量" class="headerlink" title="查看网卡流量"></a>查看网卡流量</h2><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@3 ~]# watch ifconfig eth0</span><br><span class="line"></span><br><span class="line">Every 2.0s: ifconfig eth0                         Sun May  1 21:53:10 2022</span><br><span class="line"></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 10.2.3.101  netmask 255.255.255.0  broadcast 10.2.3.255</span><br><span class="line">        inet6 fe80::546f:77ff:fe6f:78  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 56:6f:77:6f:00:78  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 980997  bytes 63958819 (60.9 MiB)</span><br><span class="line">        RX errors 0  dropped 140820  overruns 0  frame 0</span><br><span class="line">        TX packets 109994  bytes 6171909 (5.8 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<h3 id="dstat"><a href="#dstat" class="headerlink" title="dstat"></a>dstat</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1ta05y5ijj21440aowhm.jpg" alt="image-20220501223228884"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@3 ~]# dstat</span><br><span class="line">You did not select any stats, using -cdngy by default.</span><br><span class="line">----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw </span><br><span class="line">  0   0 100   0   0   0|1277B 1515B|   0     0 |   0     0 |  54    56 </span><br><span class="line">  0   0 100   0   0   0|   0     0 | 485B  130B|   0     0 |  95   103 </span><br><span class="line">  0   0 100   0   0   0|   0     0 | 348B  898B|   0     0 |  84   109 </span><br><span class="line">  0   0 100   0   0   0|   0     0 | 449B  370B|   0     0 |  93   110 </span><br><span class="line">  0   0 100   0   0   0|   0     0 | 450B  370B|   0     0 |  84    91 </span><br><span class="line">  0   0 100   0   0   0|   0     0 | 467B  370B|   0     0 |  90   101 </span><br><span class="line">  0   0 100   0   0   0|   0     0 | 306B  370B|   0     0 |  72    95 q</span><br><span class="line">  0   0 100   0   0   0|   0     0 | 501B  740B|   0     0 |  69    92 </span><br><span class="line">  0   0 100   0   0   0|   0   345k| 186B  130B|   0     0 |  78   101 </span><br><span class="line">  0   0 100   0   0   0|   0     0 | 485B  370B|   0     0 |  70    90</span><br></pre></td></tr></table></figure>

<h3 id="sysstat"><a href="#sysstat" class="headerlink" title="sysstat"></a>sysstat</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1t9yzafvnj21fs0fsjvu.jpg" alt="image-20220501223121263"></p>
<blockquote>
<p>  此命令根据参数的不同,可以查看系统不同的信息,详情请见:<a href="https://linux.cn/article-4028-1.html" target="_blank" rel="noopener">https://linux.cn/article-4028-1.html</a></p>
<p>  也可以参考百度文库:<a href="https://wenku.baidu.com/view/e89049fdcd2f0066f5335a8102d276a2002960e6.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/e89049fdcd2f0066f5335a8102d276a2002960e6.html</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@3 ~]# yum -y install sysstat</span><br><span class="line">[root@3 ~]# sar -n DEV 1 2		// -n DEV表示查看网络信息,1表示一秒一次,2表示一共两次</span><br><span class="line">Linux 3.10.0-957.el7.x86_64 (3.101-CentOS7.6) 	05/01/2022 	_x86_64_	(8 CPU)</span><br><span class="line"></span><br><span class="line">09:59:51 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">09:59:52 PM      eth0      6.00      0.00      0.42      0.00      0.00      0.00      0.00</span><br><span class="line">09:59:52 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">09:59:52 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">09:59:53 PM      eth0      6.00      1.00      0.36      0.19      0.00      0.00      0.00</span><br><span class="line">09:59:53 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">Average:        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">Average:         eth0      6.00      0.50      0.39      0.09      0.00      0.00      0.00</span><br><span class="line">Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1t9rze7sbj216u0joac7.jpg" alt="image-20220501222435466"></p>
<h3 id="cat直接查看"><a href="#cat直接查看" class="headerlink" title="cat直接查看"></a>cat直接查看</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1t9yf5lrdj21yi06a0ut.jpg" alt="image-20220501223048558"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@3 ~]# cat /proc/net/dev</span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">  eth0: 95970470  988296    0 141200    0     0          0         0  6464566  114062    0    0    0     0       0          0</span><br><span class="line">    lo:  336200    6724    0    0    0     0          0         0   336200    6724    0    0    0     0       0          0</span><br></pre></td></tr></table></figure>

<p>proc/net/dev中每一项的含义是：</p>
<ul>
<li><p>bytes: The total number of bytes of data transmitted or received by the interface.（接口发送或接收的数据的总字节数）</p>
</li>
<li><p>packets: The total number of packets of data transmitted or received by the interface.（接口发送或接收的数据包总数）</p>
</li>
<li><p>errs: The total number of transmit or receive errors detected by the device driver.（由设备驱动程序检测到的发送或接收错误的总数）</p>
</li>
<li><p>drop: The total number of packets dropped by the device driver.（设备驱动程序丢弃的数据包总数）</p>
</li>
<li><p>fifo: The number of FIFO buffer errors.（FIFO缓冲区错误的数量）</p>
</li>
<li><p>frame: The number of packet framing errors.（分组帧错误的数量）</p>
</li>
<li><p>colls: The number of collisions detected on the interface.（接口上检测到的冲突数）</p>
</li>
<li><p>compressed: The number of compressed packets transmitted or received by the device driver. (This - - appears to be unused in the 2.2.15 kernel.)（设备驱动程序发送或接收的压缩数据包数）</p>
</li>
<li><p>carrier: The number of carrier losses detected by the device driver.（由设备驱动程序检测到的载波损耗的数量）</p>
</li>
<li><p>multicast: The number of multicast frames transmitted or received by the device driver.（设备驱动程序发送或接收的多播帧数）</p>
</li>
</ul>
<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><h3 id="查看进程已运行时间"><a href="#查看进程已运行时间" class="headerlink" title="查看进程已运行时间"></a>查看进程已运行时间</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1tan27h2uj21dn0u0wo9.jpg" alt="image-20220501225429123"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@3 ~]# ps -eo pid,lstart,etime,command </span><br><span class="line">  PID                  STARTED     ELAPSED COMMAND</span><br><span class="line">    1 Fri Apr 29 14:00:04 2022  2-08:53:16 /usr/lib/systemd/systemd --switched-root --system --deserialize 22</span><br><span class="line">    2 Fri Apr 29 14:00:04 2022  2-08:53:16 [kthreadd]</span><br><span class="line">    3 Fri Apr 29 14:00:04 2022  2-08:53:16 [ksoftirqd/0]</span><br><span class="line">    5 Fri Apr 29 14:00:04 2022  2-08:53:16 [kworker/0:0H]</span><br><span class="line">    6 Fri Apr 29 14:00:04 2022  2-08:53:16 [kworker/u32:0]</span><br><span class="line">    7 Fri Apr 29 14:00:04 2022  2-08:53:16 [migration/0]</span><br><span class="line">    8 Fri Apr 29 14:00:04 2022  2-08:53:16 [rcu_bh]</span><br></pre></td></tr></table></figure>

<h3 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># processes  进程管理</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#ps查看当前系统执行的线程列表，进行瞬间状态，不是连续状态，连续状态需要使用top名称查看  更多常用参数请使用 man ps查看</span></span></span><br><span class="line">ps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示所有进程详细信息</span></span></span><br><span class="line">ps aux</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#-u 显示某个用户的进程列表</span></span></span><br><span class="line">ps -f -u www-data </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># -C 通过名字或者命令搜索进程</span></span></span><br><span class="line">ps -C apache2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># --sort  根据进程cpu使用率降序排列，查看前5个进程  -pcpu表示降序  pcpu升序</span></span></span><br><span class="line">ps aux --sort=-pcpu | head -5 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#-f 用树结构显示进程的层次关系，父子进程情况下</span></span></span><br><span class="line">ps -f --forest -C apache2 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示一个父进程的所有子进程</span></span></span><br><span class="line">ps -o pid,uname,comm -C apache2</span><br><span class="line">ps --ppid 2359 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示一个进程的所有线程  -L 参数</span></span></span><br><span class="line">ps -p 3150 -L </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示进程的执行时间 -o参数</span></span></span><br><span class="line">ps -e -o pid,comm,etime </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#watch命令可以用来实时捕捉ps显示进程</span></span></span><br><span class="line">watch -n 1 'ps -e -o pid,uname,cmd,pmem,pcpu --sort=-pmem,-pcpu | head -15' </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#jobs 查看后台运行的进程  jobs命令执行的结果，＋表示是一个当前的作业，减号表是是一个当前作业之后的一个作业，jobs -l选项可显示所有任务的PID,jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息</span></span></span><br><span class="line">jobs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看后台运营的进程号</span></span></span><br><span class="line">jobs -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看现在被终止或者退出的进程号</span></span></span><br><span class="line">jobs -n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#kill命令 终止一个前台进程可以使用Ctrl+C键   kill  通过top或者ps获取进程id号  kill [-s 信号 | -p ] [ -a ] 进程号 ...</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。关闭进程号12的进程</span></span></span><br><span class="line">kill 12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#等同于在前台运行PID为123的进程时按下Ctrl+C键</span></span></span><br><span class="line">kill -2 123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程  </span></span></span><br><span class="line">kill -9 123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#列出所有信号名称</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#HUP    1    终端断线</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#INT     2    中断（同 Ctrl + C）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#QUIT    3    退出（同 Ctrl + \）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#TERM   15    终止</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#KILL    9    强制终止</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#CONT   18    继续（与STOP相反， fg/bg命令）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#STOP    19    暂停（同 Ctrl + Z）</span></span></span><br><span class="line">kill -l</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#得到指定信号的数值</span></span></span><br><span class="line">kill -l KILL</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#杀死指定用户所有进程</span></span></span><br><span class="line">kill -u peidalinux</span><br><span class="line">kill -9 $(ps -ef | grep peidalinux) </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#将后台中的命令调至前台继续运行  将进程123调至前台执行</span></span></span><br><span class="line">fg 123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#将一个在后台暂停的命令，变成继续执行</span></span></span><br><span class="line">bg  123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思  下面输出被重定向到myout.file文件中</span></span></span><br><span class="line">nohup command &gt; myout.file 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#at：计划任务，在特定的时间执行某项工作，在特定的时间执行一次。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 格式：at HH:MM YYYY-MM-DD //HH（小时）:MM（分钟） YYYY（年）-MM（月份）-DD（日）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#HH[am pm]+D(天) days //HH（小时）[am（上午）pm（下午）]+days（天）</span></span></span><br><span class="line">at 12:00（时间） //at命令设定12:00执行一项操作</span><br><span class="line"><span class="meta">#</span><span class="bash">at&gt;useradd aaa //在at命令里设定添加用户aaa</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ctrl+d //退出at命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tail -f /etc/passwd //查看/etc/passwd文件后十行是否增加了一个用户aaa</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#计划任务设定后，在没有执行之前我们可以用atq命令来查看系统没有执行工作任务。</span></span></span><br><span class="line">atq</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#启动计划任务后，如果不想启动设定好的计划任务可以使用atrm命令删除。</span></span></span><br><span class="line">atrm 1 //删除计划任务1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#pstree命令：列出当前的进程，以及它们的树状结构  格式：pstree [选项] [pid|user]</span></span></span><br><span class="line">pstree</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#nice命令：改变程序执行的优先权等级 应用程序优先权值的范围从-20～19，数字越小，优先权就越高。一般情况下，普通应用程序的优先权值（CPU使用权值）都是0，如果让常用程序拥有较高的优先权等级，自然启动和运行速度都会快些。需要注意的是普通用户只能在0～19之间调整应用程序的优先权值，只有超级用户有权调整更高的优先权值（从-20～19）。</span></span></span><br><span class="line">nice [-n &lt;优先等级&gt;][--help][--version][命令]</span><br><span class="line">nice -n 5 ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#sleep命令：使进程暂停执行一段时间</span></span></span><br><span class="line">date;sleep 1m;date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#renice命令 renice命令允许用户修改一个正在运行进程的优先权。利用renice命令可以在命令执行时调整其优先权。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#其中，参数number与nice命令的number意义相同。（1） 用户只能对自己所有的进程使用renice命令。（2） root用户可以在任何进程上使用renice命令。（3） 只有root用户才能提高进程的优先权</span></span></span><br><span class="line">renice -5 -p 5200  #PID为5200的进程nice设为-5 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#pmap命令用于显示一个或多个进程的内存状态。其报告进程的地址空间和内存状态信息 #pmap PID </span></span></span><br><span class="line">pmap 20367</span><br></pre></td></tr></table></figure>

<h2 id="查看Linux系统每个IP的连接数"><a href="#查看Linux系统每个IP的连接数" class="headerlink" title="查看Linux系统每个IP的连接数"></a>查看Linux系统每个IP的连接数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk '/^tcp/&#123;print $5&#125;' | awk -F: '&#123;print $1&#125;' | sort | uniq -c | sort -nr</span><br></pre></td></tr></table></figure>

<h2 id="awk数量统计"><a href="#awk数量统计" class="headerlink" title="awk数量统计"></a>awk数量统计</h2><blockquote>
<p>   统计Apache/Nginx日志中某一天不同IP的访问量　&lt;统计日志&gt;</p>
<p>  例如: awk ‘{a[$1]++}END{for(i in a){printf(“%d\t%s\n”,a[i],i)}}’ access.log | sort -nr | head -5</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@test nginx_log]# grep '07/Aug/2012' access.log |awk '&#123;a[$1]++&#125; END&#123;for(i in a)&#123;print i,a[i]&#125; &#125;' |sort -k2 -rn |head</span><br><span class="line">222.130.129.42 5761</span><br><span class="line">123.126.51.94 988</span><br><span class="line">123.126.68.22 588</span><br><span class="line">123.114.46.141 418</span><br><span class="line">61.135.249.218 368</span><br><span class="line">110.75.173.162 330</span><br><span class="line">110.75.173.163 327</span><br><span class="line">110.75.173.161 321</span><br><span class="line">110.75.173.160 319</span><br><span class="line">110.75.173.164 314</span><br></pre></td></tr></table></figure>

<ul>
<li>相关解释</li>
</ul>
<blockquote>
<ol>
<li>{a[$1]++} 对每行内容，以第一个字段（估计就是IP地址吧）为数组下标进行计数。若遇第一个字段相同的情况，计数累加。用于统计各个IP地址出现的次数。</li>
<li>END{for(i in a){printf(“%d\t%s\n”,a[i],i)}}  对数组中的每个下标，打印最终统计次数及IP地址，中间以TAB分隔。</li>
<li>sort -nr  由于之前的打印是次数在前，所以这里可以用sort按数字由大到小排序</li>
<li>head -5 取前5个，即出现次数最多的（访问频率最高的）</li>
</ol>
</blockquote>
<h2 id="查看inode信息"><a href="#查看inode信息" class="headerlink" title="查看inode信息"></a>查看inode信息</h2><blockquote>
<p>  除了文件本身的文件名称之外,文件所有的信息都在inode中保存.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看文件的inode信息</span></span><br><span class="line">[root@3 ~]# stat /etc/passwd</span><br><span class="line">  File: ‘/etc/passwd’</span><br><span class="line">  Size: 1047      	Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd00h/64768d	Inode: 67498799    Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Context: system_u:object_r:passwd_file_t:s0</span><br><span class="line">Access: 2022-05-02 14:01:01.743000000 +0800</span><br><span class="line">Modify: 2021-05-25 18:03:10.665000000 +0800</span><br><span class="line">Change: 2021-05-25 18:03:10.669000000 +0800</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看文件的inode号码</span></span><br><span class="line">[root@3 ~]# ls -i /etc/passwd</span><br><span class="line">67498799 /etc/passwd</span><br></pre></td></tr></table></figure>

<h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看当前系统load</span></span><br><span class="line">uptime</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看系统状态和每个进程的系统资源使用状况</span></span><br><span class="line">top</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可视化显示CPU的使用状况</span></span><br><span class="line">htop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看每个CPU的负载信息</span></span><br><span class="line">mpstat -P ALL 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">每隔1秒查看磁盘IO的统计信息</span></span><br><span class="line">iostat -xkdz 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">每隔一秒查看虚拟内存的使用信息</span></span><br><span class="line">vmstat 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看内存使用统计信息</span></span><br><span class="line">free</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看网络使用信息</span></span><br><span class="line">nicstat -z 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">类似vmstat的显示优化的工具</span></span><br><span class="line">dstat 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看系统活动状态，比如系统分页统计，块设备IO统计等</span></span><br><span class="line">sar</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">网络连接状态查看</span></span><br><span class="line">netstat -s</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进程资源使用信息查看</span></span><br><span class="line">pidstat 1</span><br><span class="line">pidstat -d 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看某个进程的系统调用信息 -p后面是进程id，-tttT 进程系统后的系统调用时间</span></span><br><span class="line">strace -tttT -p 12670</span><br><span class="line"><span class="meta">#</span><span class="bash">统计IO设备输入输出的系统调用信息</span></span><br><span class="line">strace -c dd if=/dev/zero of=/dev/null bs=512 count=1024k</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">tcpdump 查看网络数据包</span></span><br><span class="line">tcpdump -nr /tmp/out.tcpdump</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">块设备的读写事件信息统计</span></span><br><span class="line">btrace /dev/sdb </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">iotop查看某个进程的IO操作统计信息</span></span><br><span class="line">iotop -bod5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">slabtop 查看内核 slab内存分配器的使用信息</span></span><br><span class="line">slabtop -sc</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">系统参数设置</span></span><br><span class="line">sysctl -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">系统性能指标统计信息</span></span><br><span class="line">perf stat gzip file1</span><br><span class="line"><span class="meta">#</span><span class="bash">系统cpu活动状态查看</span></span><br><span class="line">perf record -a -g -F 997 sleep 10</span><br></pre></td></tr></table></figure>

<h2 id="磁盘IO检查"><a href="#磁盘IO检查" class="headerlink" title="磁盘IO检查"></a>磁盘IO检查</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#iostat是查看磁盘活动统计情况</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示所有设备负载情况 r/s:  每秒完成的读 I/O 设备次数。即 rio/s；w/s:  每秒完成的写 I/O 设备次数。即 wio/s等</span></span></span><br><span class="line">iostat </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#每隔2秒刷新磁盘IO信息，并且每次显示3次</span></span></span><br><span class="line">iostat 2 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">显示某个磁盘的IO信息</span></span><br><span class="line">iostat -d sda1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#显示tty和cpu信息</span></span></span><br><span class="line">iostat -t</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#以M为单位显示磁盘IO信息</span></span></span><br><span class="line">iostat -m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看TPS和吞吐量信息  kB_read/s：每秒从设备（drive expressed）读取的数据量；kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；</span></span></span><br><span class="line">iostat -d -k 1 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看设备使用率（%util）、响应时间（await）</span></span><br><span class="line">iostat -d -x -k 1 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看CPU状态</span></span><br><span class="line">iostat -c 1 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">统计进程(pid)的<span class="built_in">stat</span>,进程的<span class="built_in">stat</span>自然包括进程的IO状况</span></span><br><span class="line">pidstat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">只显示IO</span></span><br><span class="line">pidstat -d  1 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">-d IO 信息,-r 缺页及内存信息-u CPU使用率-t 以线程为统计单位1  1秒统计一次</span></span><br><span class="line">pidstat -u -r -d -t 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">文件级IO分析,查看当前文件由哪些进程打开</span></span><br><span class="line">lsof   </span><br><span class="line">ls /proc/pid/fd</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">利用 sar 报告磁盘 I/O 信息DEV 正在监视的块设备 tps 每秒钟物理设备的 I/O 传输总量 rd_sec/s 每秒从设备读取的扇区数量 wr_sec/s 每秒向设备写入的扇区数量 avgrq-sz I/O 请求的平均扇区数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">avgqu-sz I/O 请求的平均队列长度 await I/O 请求的平均等待时间，单位为毫秒 svctm I/O 请求的平均服务时间，单位为毫秒 %util I/O 请求所占用的时间的百分比，即设备利用率</span></span><br><span class="line">sar -pd 10 3 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">iotop  top的io版</span></span><br><span class="line">iotop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看页面缓存信息 其中的Cached 指用于pagecache的内存大小（diskcache-SwapCache）。随着写入缓存页，Dirty 的值会增加 一旦开始把缓存页写入硬盘,Writeback的值会增加直到写入结束。</span></span><br><span class="line">cat /proc/meminfo </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看有多少个pdflush进程 Linux 用pdflush进程把数据从缓存页写入硬盘</span></span><br><span class="line"><span class="meta">#</span><span class="bash">pdflush的行为受/proc/sys/vm中的参数的控制/proc/sys/vm/dirty_writeback_centisecs (default 500): 1/100秒, 多长时间唤醒pdflush将缓存页数据写入硬盘。默认5秒唤醒2个（更多个）线程。如果wrteback的时间长于dirty_writeback_centisecs的时间，可能会出问题</span></span><br><span class="line">cat /proc/sys/vm/nr_pdflush_threads</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看I/O 调度器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">调度算法</span></span><br><span class="line"><span class="meta">#</span><span class="bash">noop anticipatory deadline [cfq] </span></span><br><span class="line"><span class="meta">#</span><span class="bash">deadline :    deadline 算法保证对既定的IO请求以最小的延迟时间。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">anticipatory：有个IO发生后，如果又有进程请求IO，则产生一个默认6ms猜测时间，猜测下一个进程请求IO是干什么。这对于随机读取会造成较大的延时。对数据库应用很糟糕，而对于Web Server等则会表现不错。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">cfq:        对每个进程维护一个IO队列，各个进程发来的IO请求会被cfq以轮循方式处理，对每一个IO请求都是公平。适合离散读的应用。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">noop:        对所有IO请求都用FIFO队列形式处理。默认IO不会存在性能问题。</span></span><br><span class="line">cat /sys/block/[disk]/queue/scheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">改变IO调度器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> deadline &gt; /sys/block/sdX/queue/scheduler</span></span><br><span class="line"><span class="meta">#</span><span class="bash">提高调度器请求队列的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 4096 &gt; /sys/block/sdX/queue/nr_requests</span></span><br></pre></td></tr></table></figure>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>进程：<ul>
<li>是系统进行资源分配和调度的一个独立单位.</li>
<li>是程序的一次执行，每个进程都有自己的地址空间、内存、数据栈及其他辅助记录运行轨迹的数据</li>
</ul>
</li>
<li>线程：<ul>
<li>是进程的一个实体，是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位</li>
<li>所有的线程运行在同一个进程中，共享相同的运行资源和环境</li>
<li>线程一般是并发执行的，使得实现了多任务的并行和数据共享。</li>
</ul>
</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>（1）通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。<br>（2）线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程主要是为了节约CPU时间，发挥利用，根据具体情况而定。线程的运行中需要使用计算机的内存资源和CPU。<br>（3）进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。<br>（4）线程的上下文切换远大于进程间上下文切换的速度。<br>（5）进程是不可执行的实体，程序是一个没有生命的实体，只有当处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。</p>
<h3 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h3><p>（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。<br>（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。<br>（3）处理机分给线程，即真正在处理机上运行的是线程。<br>（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体. </p>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>（1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位<br>（2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行<br>（3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.<br>（4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</p>
<h2 id="软链接与硬链接的区别"><a href="#软链接与硬链接的区别" class="headerlink" title="软链接与硬链接的区别"></a>软链接与硬链接的区别</h2><ol>
<li>路径</li>
</ol>
<ul>
<li>软链接: 必须是绝对路径</li>
<li>硬链接: 可以是相对路径,也可以是绝对路径</li>
</ul>
<ol start="2">
<li>权限</li>
</ol>
<ul>
<li>软链接: 链接文件权限永远是 777</li>
<li>硬链接: 跟源文件权限一致</li>
</ul>
<ol start="3">
<li>变更源文件</li>
</ol>
<ul>
<li>软链接: 不可以删除与移动源文件</li>
<li>硬链接: 可以删除与移动源文件</li>
</ul>
<ol start="4">
<li>inode数量</li>
</ol>
<ul>
<li>软链接: inode数量与源文件不通</li>
<li>硬链接: inode数量与源文件相同</li>
</ul>
<ol start="5">
<li>文件与目录</li>
</ol>
<ul>
<li>软链接: 对目录与文件都生效</li>
<li>硬链接: 只对文件生效</li>
</ul>
<ol start="6">
<li>跨文件系统</li>
</ol>
<ul>
<li>软链接: 可以跨文件系统</li>
<li>硬链接: 不可以跨文件系统</li>
</ul>
<h2 id="cookie与session的区别："><a href="#cookie与session的区别：" class="headerlink" title="cookie与session的区别："></a>cookie与session的区别：</h2><blockquote>
<p>   cookie数据保存在客户端，session数据保存在服务器端。</p>
</blockquote>
<p>session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。</p>
<h2 id="CDN访问流程"><a href="#CDN访问流程" class="headerlink" title="CDN访问流程"></a>CDN访问流程</h2><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h213m79jt0j20ug0iidhc.jpg" alt="image-20220508165559673" style="zoom:50%;">

<p>①当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。</p>
<p>②CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。</p>
<p>③用户向CDN的全局负载均衡设备发起内容URL访问请求。</p>
<p>④CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</p>
<p>⑤区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。</p>
<p>⑥全局负载均衡设备把服务器的IP地址返回给用户。</p>
<p>⑦用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</p>
<p>　　DNS服务器根据用户IP地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。使用CDN服务的网站，只需将其域名解析权交给CDN的GSLB设备，将需要分发的内容注入CDN，就可以实现内容加速了。</p>
<h2 id="进程间如何通信"><a href="#进程间如何通信" class="headerlink" title="进程间如何通信"></a>进程间如何通信</h2><table>
<thead>
<tr>
<th><strong>通信方法</strong></th>
<th><strong>无法介于内核态与用户态的原因</strong></th>
</tr>
</thead>
<tbody><tr>
<td>管道（不包括命名管道）</td>
<td>局限于父子进程间的通信。</td>
</tr>
<tr>
<td>消息队列</td>
<td>在硬、软中断中无法无阻塞地接收数据。</td>
</tr>
<tr>
<td>信号量</td>
<td>无法介于内核态和用户态使用。</td>
</tr>
<tr>
<td>共享内存</td>
<td>需要信号量辅助，而信号量又无法使用。</td>
</tr>
</tbody></table>
<h2 id="什么是rootkit"><a href="#什么是rootkit" class="headerlink" title="什么是rootkit"></a>什么是rootkit</h2><p>入侵者入侵后往往会进行清理脚印和留后门等工作，最常使用的后门创建工具就是rootkit。<br>不要被名字所迷惑，这个所谓的“rootkit”可不是给超级用户root用的，它是入侵者在入侵了一台主机后，用来做创建后门并加以伪装用的程序包。这个程序包里通常包括了日志清理器，后门等程序。同时，程序包里通常还带有一些伪造的ps、ls、who、w、netstat等原本属于系统本身的程序。这样的话，程序员在试图通过这些命令查询系统状况的时候，就无法通过这些假的系统程序发觉入侵者的行踪。</p>
<p>在一些黑客组织中,rootkit (或者backdoor) 是一个非常感兴趣的话题。<br>各种不同的rootkit被开发并发布在internet上。在这些rootkit之中, LKM尤其被人关注, 因为它是利用现代操作系统的模块技术。作为内核的一部分运行,这种rootkit将会越来越比传统技术更加强大更加不易被发觉。一旦被安装运行到目标机器上, 系统就会完全被控制在hacker手中了。甚至系统管理员根本找不到安全隐患的痕迹, 因为他们不能再信任它们的操作系统了。</p>
<p>后门程序的目的就是甚至系统管理员企图弥补系统漏洞的时候也可以给hacker系统的访问权限。</p>
<h2 id="什么是蜜罐"><a href="#什么是蜜罐" class="headerlink" title="什么是蜜罐"></a>什么是蜜罐</h2><p>蜜罐技术本质上是一种对攻击方进行欺骗的技术，通过布置一些作为诱饵的主机、网络服务或者信息，诱使攻击方对它们实施攻击，从而可以对攻击行为进行捕获和分析，了解攻击方所使用的工具与方法，推测攻击意图和动机，能够让防御方清晰地了解他们所面对的安全威胁，并通过技术和管理手段来增强实际系统的安全防护能力。</p>
<p>蜜罐好比是情报收集系统。蜜罐好像是故意让人攻击的目标，引诱黑客前来攻击。所以攻击者入侵后，你就可以知道他是如何得逞的，随时了解针对服务器发动的最新的攻击和漏洞。还可以通过窃听黑客之间的联系，收集黑客所用的种种工具，并且掌握他们的社交网络。</p>
<h2 id="Linux中什么是Watchdog"><a href="#Linux中什么是Watchdog" class="headerlink" title="Linux中什么是Watchdog"></a>Linux中什么是Watchdog</h2><p>Watchdog在实现上可以是硬件电路也可以是软件定时器，能够在系统出现故障时自动重新启动系统。在Linux 内核下, watchdog的基本工作原理是：当watchdog启动后(即/dev/watchdog 设备被打开后)，如果在某一设定的时间间隔内/dev/watchdog没有被执行写操作, 硬件watchdog电路或软件定时器就会重新启动系统</p>
<h2 id="访问一个网站的流程"><a href="#访问一个网站的流程" class="headerlink" title="访问一个网站的流程"></a>访问一个网站的流程</h2><p>用户输入网站按回车， 查找本地缓存，如果有就打开页面，如果没有，利用DNS做域名解析，递归查询，一级一级的向上提交查询请求，知道查询到为止<br>HOSTS表 –&gt; 本地DNS –&gt;上层DNS(包括根DNS)</p>
<p>经过了DNS解析，知道了网站的IP地址，然后建立tcp三次握手; 建立请求后，发送请求报文，默认请求的是index.html</p>
<p>传送完毕，断开连接</p>
<h2 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h2><p><strong><em>三次握手</em></strong></p>
<ol>
<li>由客户端(用户)发送建立TCP连接的请求报文，其中报文中包含<code>seq</code>序列号，是由发送端随机生成的。并且还将报文中<code>SYN</code>字段置为 <strong>1</strong>，表示需要建立TCP连接请求。 </li>
<li>服务端(就是百度服务器)会回复客户端(用户)发送的TCP连接请求报文，其中包含<code>seq</code>序列号，也是由回复端随机生成的， 并且将回复报文的SYN字段置1，而且会产生<code>ACK</code>验证字段，ACK 验证字段数值是在客户端发过来的<code>seq</code>序列号基础上加 <strong>1</strong> 进行回复: 并且还会回复ack确认控制字段，以便客户端收到信息时，知晓自己的TCP建立请求已得到了确认。</li>
<li>客户端收到服务端发送的TCP建立请求后，会使自己的原有序列号加 <strong>1</strong> 进行再次发送序列号， 并且再次回复<code>ACK</code>验证请求，在B端发送过来的<code>seq</code>基础上加1，进行回复; 同时也会回复 ack 确认控制字段， 以便B收到信息时，知晓自己的TCP建立请求已经得到了确认。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6k5rk6g3xj210e0l6769.jpg" alt="image-20220926175721947"></p>
<p><strong><em>四次挥手*</em></strong></p>
<p><em>*第一次挥手:</em> </p>
<p>Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态。 </p>
<p><em>第二次挥手:</em> </p>
<p>Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)，Server 进入 CLOSE_WAIT 状态。</p>
<p><em>第三次挥手:</em> </p>
<p>Server 发送一个FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。 </p>
<p><em>第四次挥手:</em> </p>
<p>Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给Server，确认序号为收到序号+1，</p>
<p>Server进入CLOSED状态，完成四次挥手.</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6m7ampiwdj20i40cmt9j.jpg" alt="image-20220928122126015" style="zoom:150%;">

<h2 id="LVS相关"><a href="#LVS相关" class="headerlink" title="LVS相关"></a>LVS相关</h2><h3 id="LVS-负载均衡有哪些策略"><a href="#LVS-负载均衡有哪些策略" class="headerlink" title="LVS 负载均衡有哪些策略"></a>LVS 负载均衡有哪些策略</h3><p>LVS一共有三种工作模式: </p>
<ul>
<li>DR</li>
<li>Tunnel</li>
<li>NAT</li>
</ul>
<h3 id="谈谈你对LVS的理解"><a href="#谈谈你对LVS的理解" class="headerlink" title="谈谈你对LVS的理解"></a>谈谈你对LVS的理解</h3><p>LVS是一个<strong>虚拟的服务器集群系统</strong>，在unix系统下实现负载均衡的功能;采用<code>IP负载均衡技术</code>和<code>机遇内容请求分发技术</code>来实现。</p>
<p>LVS采用三层结构，分别是:</p>
<ul>
<li><p>第一层: 负载调度器</p>
</li>
<li><p>第二层: 服务池</p>
</li>
<li><p>第三层:共享存储</p>
</li>
</ul>
<p><strong>负载调度器</strong>(load balancer/ Director)，是整个集群的总代理，它有两个网卡，一个网卡面对访问网站的客户端，一个网卡面对整个集群的内部。负责将客户端的请求发送到一组服务器上执行，而客户也认为服务是来自这台主的。举个生动的例子，集群是个公司，负载调度器就是在外接揽生意，将接揽到的生意分发给后台的真正干活的真正的主机们。当然需要将活按照一定的算法分发下去，让大家都公平的干活。</p>
<p><strong>服务器池</strong>(server pool/ Realserver)，是一组真正执行客户请求的服务器，可以当做WEB服务器。就 是上面例子中的小员工。</p>
<p><strong>共享存储</strong>(shared storage)，它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相 同的内容，提供相同的服务。一个公司得有一个后台账目吧，这才能协调。不然客户把钱付给了A，而 换B接待客户，因为没有相同的账目。B说客户没付钱，那这样就不是客户体验度的问题了。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6fmy1qp5fj21ck0ty0vh.jpg" alt="image-20220922200358216"></p>
<h3 id="负载均衡的原理是什么"><a href="#负载均衡的原理是什么" class="headerlink" title="负载均衡的原理是什么"></a>负载均衡的原理是什么</h3><p>当客户端发起请求时，请求直接发给Director Server(调度器)，这时会根据设定的调度算法，将请求按照算法的规定智能的分发到真正的后台服务器。以达到将压力均摊。</p>
<p>但是我们知道，http的连接时无状态的，假设这样一个场景，我登录某宝买东西，当我看上某款商品时，我将它加入购物车，但是我刷新了一下页面，这时由于负载均衡的原因，调度器又选了新的一台服务器为我提供服务，我刚才的购物车内容全都不见了，这样就会有十分差的用户体验。</p>
<p>所以就还需要一个存储共享，这样就保证了用户请求的数据是一样的</p>
<h3 id="LVS由哪两部分组成的"><a href="#LVS由哪两部分组成的" class="headerlink" title="LVS由哪两部分组成的"></a>LVS由哪两部分组成的</h3><p>LVS由<code>ipvs</code>和<code>ipvsadm</code>组成</p>
<ul>
<li><p><strong>ipvs</strong>(ip virtual server): 一段代码工作在内核空间，叫ipvs，<strong><em>是真正生效实现调度的代码</em></strong>。</p>
</li>
<li><p><strong>ipvsadm</strong>: 另外一段是工作在用户空间，叫ipvsadm，负责为ipvs内核框架编写规则，定义谁是集群服务，而谁是后端真实的服务器(Real Server)</p>
</li>
</ul>
<h3 id="LVS相关的术语"><a href="#LVS相关的术语" class="headerlink" title="LVS相关的术语"></a>LVS相关的术语</h3><ul>
<li><p><strong>DS</strong>: Director Server。指的是前端负载均衡器节点。</p>
</li>
<li><p><strong>RS</strong>: Real Server。后端真实的工作服务器。</p>
</li>
<li><p><strong>VIP</strong>: Virtual IP 向外部直接面向用户请求，作为用户请求的目标的IP地址。 </p>
</li>
<li><p><strong>DIP</strong>: Director Server IP，主要用于和内部主机通讯的IP地址。</p>
</li>
<li><p><strong>RIP</strong>: Real Server IP，后端服务器的IP地址。</p>
</li>
<li><p><strong>CIP</strong>: Client IP，访问客户端的IP地址。</p>
</li>
</ul>
<h3 id="LVS-NAT模式的原理"><a href="#LVS-NAT模式的原理" class="headerlink" title="LVS-NAT模式的原理"></a>LVS-NAT模式的原理</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6fnhtxp5nj21ay0o077d.jpg" alt="image-20220922202300843"></p>
<blockquote>
<p>  (1). 当用户请求到达 Director Server，此时请求的数据报文会先到内核空间的 PREROUTING 链。 此时报文的源IP为CIP，目标IP为VIP</p>
<p>  (2). PREROUTING检查发现数据包的目标 IP 是本机，将数据包送至 INPUT 链</p>
<p>  (3). IPVS比对数据包请求的服务是否为集群服务，若是，修改数据包的目标IP地址为后端服务器 IP， 然后将数据包发至POSTROUTING链。 此时报文的源IP为CIP，目标IP为RIP</p>
<p>  (4). POSTROUTING链通过选路，将数据包发送给Real Server</p>
<p>  (5). Real Server比对发现目标为自己的IP，开始构建响应报文发回给Director Server。 此时报文的源IP为RIP，目标IP为CIP</p>
<p>  (6). Director Server在响应客户端前，此时会将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的源IP为VIP，目标IP为CIP</p>
</blockquote>
<h3 id="LVS-NAT模型的特性"><a href="#LVS-NAT模型的特性" class="headerlink" title="LVS-NAT模型的特性"></a>LVS-NAT模型的特性</h3><ul>
<li><p>RS 应该使用私有地址，RS 的网关必须指向 DIP</p>
</li>
<li><p>DIP 和 RIP 必须在同一个网段内</p>
</li>
<li><p>请求和响应报文都需要经过 Director Server，高负载场景中，Director Server 易成为性能瓶颈</p>
</li>
<li><p>支持端口映射</p>
</li>
<li><p>RS 可以使用任意操作系统</p>
</li>
<li><p>缺陷: 对 Director Server 压力会比较大，请求和响应都需经过 Director server</p>
</li>
</ul>
<h3 id="LVS-DR模式原理"><a href="#LVS-DR模式原理" class="headerlink" title="LVS-DR模式原理"></a>LVS-DR模式原理</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h6fnt21f6pj21au0pwwj5.jpg" alt="image-20220922203348356"></p>
<blockquote>
<p>  (1) 当用户请求到达 Director Server，此时请求的数据报文会先到内核空间的 PREROUTING 链。 此时报文的源IP为 CIP，目标 IP 为 VIP</p>
<p>  (2) PREROUTING 检查发现数据包的目标IP是本机，将数据包送至 INPUT 链</p>
<p>  (3)  IPVS比对数据包请求的服务是否为集群服务，若是，将请求报文中的源 MAC 地址修改为 DIP 的 MAC 地址，将目标 MAC 地址修改 RIP 的 MAC 地址，然后将数据包发至 POSTROUTING 链。 此时的源 IP 和目的 IP 均未修改，仅修改了源 MAC 地址为 DIP 的 MAC 地址，目标 MAC 地址为 RIP 的 MAC 地址</p>
<p>  (4) 由于 DS 和 RS 在同一个网络中，所以是通过二层来传输。POSTROUTING 链检查目标 MAC 地址为 RIP 的 MAC 地址，那么此时数据包将会发至Real Server。</p>
<p>  (5) RS 发现请求报文的 MAC 地址是自己的 MAC 地址，就接收此报文。处理完成之后，将响应报文通过 lo 接口传送给 eth0 网卡然后向外发出。 此时的源 IP 地址为 VIP，目标 IP 为 CIP</p>
<p>  (6) 响应报文最终送达至客户端</p>
</blockquote>
<h3 id="LVS-DR模型的特性"><a href="#LVS-DR模型的特性" class="headerlink" title="LVS-DR模型的特性"></a>LVS-DR模型的特性</h3><p>特点:</p>
<ul>
<li><p>保证前端路由将目标地址为 VIP 报文统统发给 Director Server，而不是 RS</p>
</li>
<li><p>RS 可以使用私有地址; 也可以是公网地址，如果使用公网地址，此时可以通过互联网对RIP进行直接访问</p>
</li>
<li><p>RS 跟 Director Server 必须在同一个物理网络中</p>
</li>
<li><p>所有的请求报文经由 Director Server，但响应报文不能经过 Director Server </p>
</li>
<li><p>不支持地址转换，也不支持端口映射</p>
</li>
<li><p>RS 可以是大多数常见的操作系统</p>
</li>
<li><p>RS 的网关绝不允许指向DIP(因为我们不允许他经过director) </p>
</li>
<li><p>RS 上的 lo 接口配置 VIP 的 IP 地址</p>
</li>
</ul>
<p>缺陷:</p>
<ul>
<li>RS 和 DS 必须在同一机房中</li>
</ul>
<h3 id="LVS三种负载均衡模式的比较"><a href="#LVS三种负载均衡模式的比较" class="headerlink" title="LVS三种负载均衡模式的比较"></a>LVS三种负载均衡模式的比较</h3><p>三种负载均衡: nat，tunneling，dr<br>|    类目    |    NAT     |      TUN      |        DR         |<br>| :——–: | :——–: | :———–: | :—————: |<br>|  操作系统  |    任意    |   支持隧道    | 多数(支持non-arp) |<br>| 服务器网络 |  私有网络  | 局域网/广域网 |      局域网       |<br>| 服务器数目 |   10-20    |      100      |      大于100      |<br>| 服务器网关 | 负载均衡器 |  自己的路由   |    自己的路由     |<br>|    效率    |    一般    |      高       |       最高        |</p>
<h3 id="LVS的负载调度算法"><a href="#LVS的负载调度算法" class="headerlink" title="LVS的负载调度算法"></a>LVS的负载调度算法</h3><ul>
<li>轮叫调度</li>
<li>加权轮叫调度</li>
<li>最小连接调度</li>
<li>加权最小连接调度</li>
<li>基于局部性能的最少连接</li>
<li>带复制的基于局部性能最小连接</li>
<li>目标地址散列调度</li>
<li>源地址散列调度</li>
</ul>
<h3 id="LVS与nginx的区别"><a href="#LVS与nginx的区别" class="headerlink" title="LVS与nginx的区别"></a>LVS与nginx的区别</h3><p><strong>lvs的优势(互联网老辛):</strong></p>
<ol>
<li>抗负载能力强，因为 lvs 工作方式的逻辑是非常简单的，而且工作在网络的第 4 层，仅作请求分发用，没有流量，所以在效率上基本不需要太过考虑。lvs 一般很少出现故障，即使出现故障一般也是其他地方(如内存、CPU等)出现问题导致 lvs 出现问题。</li>
<li>配置性低，这通常是一大劣势同时也是一大优势，因为没有太多的可配置的选项，所以除了增减服务器，并不需要经常去触碰它，大大减少了人为出错的几率。</li>
<li>工作稳定，因为其本身抗负载能力很强，所以稳定性高也是顺理成章的事，另外各种 lvs 都有完整的双机热备方案，所以一点不用担心均衡器本身会出什么问题，节点出现故障的话，lvs 会自动判别，所以系统整体是非常稳定的。</li>
<li>无流量，lvs 仅仅分发请求，而流量并不从它本身出去，所以可以利用它这点来做一些线路分流之用。没有流量同时也保住了均衡器的 IO 性能不会受到大流量的影响。</li>
<li>lvs 基本上能支持所有应用，因为 lvs 工作在第4层，所以它可以对几乎所有应用做负载均衡，包括 http、数据库、聊天室等。</li>
</ol>
<p><strong>nginx与LVS的对比:</strong></p>
<ul>
<li>nginx工作在网络的第7层，所以它可以针对 http 应用本身来做分流策略，比如针对域名、目录结构等，相比之下 lvs 并不具备这样的功能，所以 nginx 单凭这点可以利用的场合就远多于 lvs 了;但 nginx 有用的这些功能使其可调整度要高于lvs，所以经常要去触碰，由 lvs 的第2条优点来看，触碰多了，人为出现问题的几率也就会大。 </li>
<li>nginx对网络的依赖较小，理论上只要 ping 得通，网页访问正常，nginx就能连得通，nginx 同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路; lvs 就比较依赖于网络环境，目前来看服务器在同一网段内并且 lvs 使用 direct 方式分流，效果较能得到保证。另外注意，lvs 需要向托管商至少申请多于一个 ip 来做visual ip。 </li>
<li>nginx 安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。lvs 的安装和配置、测试就要花比较长的时间，因为同上所述，lvs 对网络依赖性比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦的多。</li>
<li>nginx也同样能承受很高负载且稳定，但负载度和稳定度差 lvs 还有几个等级:nginx处理所有流量所以受限于机器 IO 和配置;本身的bug也还是难以避免的;nginx没有现成的双机热备方案，所以跑在单机上还是风险比较大，单机上的事情全都很难说。 </li>
<li>nginx 可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前 lvs 中 ldirectd 也能支持针对服务器内部的情况来监控，但 lvs 的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，nginx 会把上传切到另一台服务器重新处理，而 lvs 就直接断掉了。</li>
</ul>
<p><strong>两者配合使用:</strong></p>
<p>nginx 用来做 http 的反向代理，能够 upsteam 实现 http 请求的多种方式的均衡转发。由于采用的是异步转发可以做到如果一个服务器请求失败，立即切换到其他服务器，直到请求成功或者最后一台服务器失败为止。这可以最大程度的提高系统的请求成功率。</p>
<p>lvs采用的是同步请求转发的策略。这里说一下同步转发和异步转发的区别。同步转发是在 lvs 服务器接收到请求之后，立即 redirect 到一个后端服务器，由客户端直接和后端服务器建立连接。异步转发是 nginx 在保持客户端连接的同时，发起一个相同内容的新请求到后端，等后端返回结果后，由 nginx 返回给客户端。</p>
<p>进一步来说:当做为负载均衡服务器的 nginx 和 lvs 处理相同的请求时，所有的请求和响应流量都会经过 nginx; 但是使用 lvs 时，仅请求流量经过 lvs 的网络，响应流量由后端服务器的网络返回。</p>
<p>也就是，当作为后端的服务器规模庞大时，nginx的网络带宽就成了一个巨大的瓶颈。</p>
<p>但是仅仅使用 lvs 作为负载均衡的话，一旦后端接受到请求的服务器出了问题，那么这次请求就失败了。 但是如果在lvs的后端在添加一层nginx(多个)，每个nginx后端再有几台应用服务器，那么结合两者的优势，既能避免单nginx的流量集中瓶颈，又能避免单lvs时一锤子买卖的问题。</p>
<h3 id="负载均衡的作用有哪些"><a href="#负载均衡的作用有哪些" class="headerlink" title="负载均衡的作用有哪些"></a>负载均衡的作用有哪些</h3><p>1、转发功能</p>
<p>按照一定的算法【权重、轮询】，将客户端请求转发到不同应用服务器上，减轻单个服务器压力，提高系统并发量。</p>
<p>2、故障移除</p>
<p>通过心跳检测的方式，判断应用服务器当前是否可以正常工作，如果服务器期宕掉，自动将请求发送到其他应用服务器。</p>
<p>3、恢复添加</p>
<p>如检测到发生故障的应用服务器恢复工作，自动将其添加到处理用户请求队伍中。</p>
<h2 id="Nginx与Apache相关"><a href="#Nginx与Apache相关" class="headerlink" title="Nginx与Apache相关"></a>Nginx与Apache相关</h2><p><a href="https://haicoder.net/note/nginx-interview/nginx-interview-nginx-feature.html" target="_blank" rel="noopener">常见问题</a></p>
<h3 id="nginx负载均衡实现的策略"><a href="#nginx负载均衡实现的策略" class="headerlink" title="nginx负载均衡实现的策略"></a>nginx负载均衡实现的策略</h3><ul>
<li><p>轮询(默认)</p>
</li>
<li><p>权重</p>
</li>
<li><p>ip_hash </p>
</li>
<li><p>fair(第三方插件) </p>
</li>
<li><p>url_hash(第三方插件)</p>
</li>
</ul>
<h3 id="nginx做负载均衡用到的模块"><a href="#nginx做负载均衡用到的模块" class="headerlink" title="nginx做负载均衡用到的模块"></a>nginx做负载均衡用到的模块</h3><ul>
<li>upstream 定义负载节点池。</li>
<li>location 模块进行URL匹配。</li>
<li>proxy模块发送请求给upstream定义的节点池。</li>
</ul>
<h3 id="负载均衡有哪些实现方式"><a href="#负载均衡有哪些实现方式" class="headerlink" title="负载均衡有哪些实现方式"></a>负载均衡有哪些实现方式</h3><ul>
<li><p>硬件负载 </p>
</li>
<li><p>HTTP重定向负载均衡 </p>
</li>
<li><p>DNS负载均衡 </p>
</li>
<li><p>反向代理负载均衡 </p>
</li>
<li><p>IP层负载均衡 </p>
</li>
<li><p>数据链路层负载均衡</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h6ipn8fu0nj21710u0acq.jpg" alt="image-20220925115401352"></p>
<h3 id="web服务有哪些"><a href="#web服务有哪些" class="headerlink" title="web服务有哪些"></a>web服务有哪些</h3><ul>
<li>apache </li>
<li>nginx</li>
<li>IIS </li>
<li>tomcat </li>
<li>lighttpd </li>
<li>weblogic</li>
</ul>
<h3 id="为什么要用nginx"><a href="#为什么要用nginx" class="headerlink" title="为什么要用nginx"></a>为什么要用nginx</h3><ul>
<li>跨平台、配置简单，非阻塞、高并发连接: 处理2-3万并发连接数，官方监测能支持5万并发 </li>
<li>内存消耗小: 开启10个nginx才占150M内存，nginx处理静态文件好,耗费内存少</li>
<li>内置的健康检查功能: 如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。 </li>
<li>节省宽带: 支持GZIP压缩，可以添加浏览器本地缓存</li>
<li>稳定性高: 宕机的概率非常小</li>
<li>接收用户请求是异步的</li>
</ul>
<h3 id="nginx的性能为什么比apache高"><a href="#nginx的性能为什么比apache高" class="headerlink" title="nginx的性能为什么比apache高"></a>nginx的性能为什么比apache高</h3><p>nginx采用的是epoll模型和kqueue网络模型，而apache采用的是select模型</p>
<p><strong><em>举一个例子来解释两种模型的区别:</em></strong></p>
<p>菜鸟驿站放着很多快件，以前去拿快件都是短信通知你有快件，然后你去了之后，负责菜鸟驿站的人在一堆快递里帮你找，直到找到为止。</p>
<p>但现在菜鸟驿站的方式变了，他会发你一个地址，比如 3-3-5009. 这个就是第三个货架的第三排，从做往右第九个。</p>
<p>如果有几百个人同时去找快递，这两种方式哪个更有效率，不言而喻。</p>
<p><strong><em>之前还看到这个例子也比较形象:</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 假设你在大学读书，住的宿舍楼有很多间房间，你的朋友要来找你。</span><br><span class="line">select版宿管大妈就会带着你的朋友挨个房间去找，直到找到你为止。</span><br><span class="line">而epoll版宿管大妈会先记下每位同学的房间号，</span><br><span class="line">你的朋友来时，只需告诉你的朋友你住在哪个房间即可，不用亲自带着你的朋友满大楼找人。</span><br><span class="line">如果来了10000个人，都要找自己住这栋楼的同学时，select版和epoll版宿管大妈，谁的效率更高，不言自明。</span><br><span class="line">同理，在高并发服务器中，轮询I/O是最耗时间的操作之一，select和epoll的性能谁的性能更高，同样十分明了</span><br></pre></td></tr></table></figure>

<p>select 采用的是轮询的方式来处理请求，轮询的次数越多，耗时也就越多。</p>
<h3 id="nginx和apache的区别"><a href="#nginx和apache的区别" class="headerlink" title="nginx和apache的区别"></a>nginx和apache的区别</h3><p><strong><em>Nginx</em></strong></p>
<ul>
<li><p>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</p>
</li>
<li><p>抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</p>
</li>
<li><p>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</p>
</li>
<li><p>nginx 的设计高度模块化，编写模块相对简单</p>
</li>
<li><p>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题， apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</p>
</li>
<li><p>nginx 作为负载均衡服务器，支持 7 层负载均衡<br>七层负载可以有效的防止ddos攻击 </p>
</li>
<li><p>nginx本身就是一个反向代理服务器，也可以左右邮件代理服务器来使用</p>
</li>
</ul>
<p><strong><em>Apache</em></strong></p>
<ul>
<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>
<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>
<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>
<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>
<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>
<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>
<li>两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接(万级别)可以对应一个进程。</li>
<li>需要稳定用 apache，需要高性能用 nginx</li>
</ul>
<h3 id="反向代理与正向代理以及区别"><a href="#反向代理与正向代理以及区别" class="headerlink" title="反向代理与正向代理以及区别"></a>反向代理与正向代理以及区别</h3><p><strong>正向代理:</strong></p>
<p>所谓的正向代理就是: 需要在用户端去配置的。配置完再去访问具体的服务，这叫正向代理</p>
<p>正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。 </p>
<p><em>正向代理的用途:</em></p>
<ul>
<li><p>提高访问速度</p>
</li>
<li><p>隐藏客户真实IP</p>
</li>
</ul>
<p><strong>反向代理:</strong></p>
<p>反向代理是在服务端的，不需要访问用户关心。用户访问服务器A, A服务器是代理服务器，将用户服务</p>
<p>再转发到服务器B.这就是反向代理</p>
<p><em>反向代理的作用:</em> </p>
<ul>
<li><p>缓存，将服务器的响应缓存在自己的内存中，减少服务器的压力。</p>
</li>
<li><p>负载均衡，将用户请求分配给多个服务器。</p>
</li>
<li><p>访问控制</p>
</li>
</ul>
<h3 id="nginx如何处理http请求"><a href="#nginx如何处理http请求" class="headerlink" title="nginx如何处理http请求"></a>nginx如何处理http请求</h3><p>四个步骤:</p>
<ul>
<li>读取解析请求行;</li>
<li>读取解析请求头;</li>
<li>开始最重要的部分，即多阶段处理;</li>
</ul>
<blockquote>
<p>  nginx 把请求处理划分成了11个阶段，也就是说当 nginx 读取了请求行和请求头之后，将请求封装了结构体ngx_http_request_t，然后每个阶段的 handler 都会根据这个 ngx_http_request_t，对请求进行处理，例如重写uri，权限控制，路径查找，生成内容以及记录日志等等;</p>
</blockquote>
<p>最后将结果返回给客户端。</p>
<p><strong><em>也可以这么回答:</em></strong></p>
<ul>
<li>首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master 进程里面先初始化好这个监控的Socket(创建 Socket，设置 addr、reuse 等选项，绑定到指定的 ip 地址端口，再 listen 监听)。</li>
<li>然后，再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程 )出多个子进程出来。</li>
<li>之后，子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与 nginx进行三次握手，与 nginx 建立好一个连接后。此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ，</li>
<li>然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体。</li>
<li>接着，设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。 </li>
<li>最后，Nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了。</li>
</ul>
<h3 id="nginx虚拟主机有哪些"><a href="#nginx虚拟主机有哪些" class="headerlink" title="nginx虚拟主机有哪些"></a>nginx虚拟主机有哪些</h3><ul>
<li>基于<strong>域名</strong>的虚拟主机</li>
<li>基于<strong>端口</strong>的虚拟主机</li>
<li>基于 <strong>IP</strong> 的虚拟主机</li>
</ul>
<h3 id="apache中的Worker和Prefork的区别"><a href="#apache中的Worker和Prefork的区别" class="headerlink" title="apache中的Worker和Prefork的区别"></a>apache中的Worker和Prefork的区别</h3><p>它们都是MPM, Worker 和 prefork 有它们各自在Apache上的运行机制. 它们完全依赖于你想要以哪一<br>种模式启动你的Apache.</p>
<ol>
<li>Worker 和 MPM 基本的区别在于它们产生子进程的处理过程, 在 Prefork MPM 中, 一个主 httpd 进行被启动，这个主进程会管理所有其它子进程为客户端请求提供服务. 而在worker MPM中一个httpd进程被激活，则会使用不同的线程来为客户端请求提供服务.</li>
<li>Prefork MPM 使用多个子进程，每一个进程带有一个线程; 而 worker MPM 使用多个子进程，每一个进程带有多个线程.</li>
<li>Prefork MPM中的连接处理, 每一个进程一次处理一个连接而在Worker mpm中每一个线程一次处理一个连接.</li>
<li>内存占用 Prefork MPM 占用庞大的内存, 而Worker占用更小的内存</li>
</ol>
<h3 id="nginx的优化"><a href="#nginx的优化" class="headerlink" title="nginx的优化"></a>nginx的优化</h3><ul>
<li>gzip压缩优化</li>
<li>expires缓存</li>
<li>网络IO事件模型优化</li>
<li>隐藏软件名称和版本号</li>
<li>防盗链优化</li>
<li>禁止恶意域名解析</li>
<li>禁止通过IP地址访问网站</li>
<li>HTTP请求方法优化</li>
<li>防DOS攻击单IP并发连接的控制，与连接速率控制</li>
<li>严格设置web站点目录的权限</li>
<li>将nginx进程以及站点运行于监牢模式</li>
<li>通过robot协议以及HTTP_USER_AGENT防爬虫优化</li>
<li>配置错误页面根据错误码指定网页反馈给用户</li>
<li>nginx日志相关优化访问日志切割轮询，不记录指定元素日志、最小化日志目录权限</li>
<li>限制上传到资源目录的程序被访问，防止木马入侵系统破坏文件</li>
<li>FastCGI参数buffer和cache配置文件的优化</li>
<li>php.ini和php-fpm.conf配置文件的优化</li>
<li>有关web服务的Linux内核方面深度优化(网络连接、IO、内存等)</li>
<li>nginx加密传输优化(SSL)</li>
<li>web服务器磁盘挂载及网络文件系统的优化</li>
<li>使用nginx cache</li>
</ul>
<h3 id="nginx的session不同步怎么办"><a href="#nginx的session不同步怎么办" class="headerlink" title="nginx的session不同步怎么办"></a>nginx的session不同步怎么办</h3><p>我们可以采用 ip_hash 指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。即每个访客固定访问一个后端服务器，可以解决 session 的问题。</p>
<p>其他办法: 那就是用 spring_session+redis，把session放到缓存中实现 session 共享。</p>
<h2 id="Tomcat相关"><a href="#Tomcat相关" class="headerlink" title="Tomcat相关"></a>Tomcat相关</h2><h3 id="Tomcat作为web的优缺点"><a href="#Tomcat作为web的优缺点" class="headerlink" title="Tomcat作为web的优缺点"></a>Tomcat作为web的优缺点</h3><p><strong>缺点:</strong><br>tomcat 只能用做 java 服务器，处理静态请求的能力不如 nginx 和 apache，高并发能力有限 </p>
<p><strong>优点:</strong></p>
<p>动态解析容器，处理动态请求，是编译 JSP/Servlet 的容器，轻量级</p>
<h3 id="tomcat的三个端口及作用"><a href="#tomcat的三个端口及作用" class="headerlink" title="tomcat的三个端口及作用"></a>tomcat的三个端口及作用</h3><ul>
<li>8005: 关闭Tomcat通信接口</li>
<li>8009: 与其他httpd服务器通信接口，用于http服务器的集合</li>
<li>8080: 建立httpd连接用，如浏览器访问</li>
</ul>
<h3 id="Tomcat缺省端口是多少，怎么修改"><a href="#Tomcat缺省端口是多少，怎么修改" class="headerlink" title="Tomcat缺省端口是多少，怎么修改"></a>Tomcat缺省端口是多少，怎么修改</h3><ol>
<li><p>找到Tomcat目录下的conf文件夹</p>
</li>
<li><p>进入conf文件夹里面找到server.xml文件</p>
</li>
<li><p>打开server.xml文件</p>
</li>
<li><p>在server.xml文件里面找到下列信息 </p>
</li>
<li><p>把Connector标签的8080端口改成你想要的端口</p>
</li>
</ol>
<h3 id="Tomcat的工作模式是什么"><a href="#Tomcat的工作模式是什么" class="headerlink" title="Tomcat的工作模式是什么"></a>Tomcat的工作模式是什么</h3><p>Tomcat作为servlet容器，有三种工作模式: </p>
<ol>
<li>独立的servlet容器，servlet容器是web服务器的一部分;</li>
<li>进程内的servlet容器，servlet容器是作为web服务器的插件和java容器的实现，web服务器插件在内部地址空间打开一个jvm使得java容器在内部得以运行。反应速度快但伸缩性不足;</li>
<li>进程外的servlet容器，servlet容器运行于web服务器之外的地址空间，并作为web服务器的插件和 java 容器实现的结合。反应时间不如进程内但伸缩性和稳定性比进程内优;</li>
</ol>
<p>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类: </p>
<ul>
<li><p>Tomcat作为应用程序服务器:请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等;</p>
</li>
<li><p>Tomcat作为独立服务器:请求来自于web浏览器;</p>
</li>
</ul>
<h3 id="Web请求在Tomcat请求中的请求流程"><a href="#Web请求在Tomcat请求中的请求流程" class="headerlink" title="Web请求在Tomcat请求中的请求流程"></a>Web请求在Tomcat请求中的请求流程</h3><ul>
<li>浏览器输入URL地址; </li>
<li>查询本机hosts文件寻找IP; </li>
<li>查询DNS服务器寻找IP; </li>
<li>向该IP发送Http请求; </li>
<li>Tomcat容器解析主机名; </li>
<li>Tomcat容器解析Web应用; </li>
<li>Tomcat容器解析资源名称; </li>
<li>Tomcat容器获取资源; </li>
<li>Tomcat响应浏览器。</li>
</ul>
<h3 id="Tomcat优化"><a href="#Tomcat优化" class="headerlink" title="Tomcat优化"></a>Tomcat优化</h3><ol>
<li>Tomcat的运行模式 : bio,nio, apr<br> 一般使用nio模式，bio效率低，apr对系统配置有一些更高的要求</li>
<li>关键配置<br>maxThreads: 最大线程数，默认是200，<br>minspareThread: 最小活跃线程数，默认是25<br>maxqueuesize: 最大等待队列个数 </li>
<li>影响性能的配置:<br>compression 设置成on，开启压缩<br>禁用AJP连接器: 用nginx+Tomcat的架构，用不到AJP<br>enableLookups=false 关闭反查域名，直接返回ip，提高效率<br>disableUploadTimeou=false 上传是否使用超时机制<br>acceptCount=300 , 当前所有可以使用的处理请求都被使用时，传入请求连接最大队列长队，超过个数不予处理，默认是100<br>keepalive timeout=120000 场链接保持时间</li>
<li>优化jvm<br> /bin/catalina.sh</li>
</ol>
<blockquote>
<p>  -server: jvm的server工作模式，对应的有client工作模式。使用“java -version”可以查看当前工作 模式</p>
<p>  -Xms1024m: 初始Heap大小，使用的最小内存</p>
<p>  -Xmx1024m: Java heap 最大值，使用的最大内存。经验: 设置 Xms 大小等于 Xmx 大小 </p>
<p>  -XX:NewSize=512m:表示新生代初始内存的大小，应该小于 -Xms 的值 </p>
<p>  -XX:MaxNewSize=1024M:表示新生代可被分配的内存的最大上限，应该小于 -Xmx 的值</p>
<p>  -XX:PermSize=1024m:设定内存的永久保存区域,内存的永久保存区域，VM 存放 Class 和 Meta 信息，JVM在运行期间不会清除该区域 </p>
<p>  -XX:MaxPermSize=1024m:设定最大内存的永久保存区域。经验: 设置PermSize大小等于 MaxPermSize大小</p>
<p>  -XX:+DisableExplicitGC:自动将System.gc() 调用转换成一个空操作，即应用中调用System.gc() 会变成一个空操作，避免程序员在代码里进行System.gc()这种危险操作。System.gc() 除非是到了万不得也的情况下使用，都应该交给 JVM。</p>
</blockquote>
<h2 id="fastcgi-和cgi的区别"><a href="#fastcgi-和cgi的区别" class="headerlink" title="fastcgi 和cgi的区别"></a>fastcgi 和cgi的区别</h2><p>cgi:</p>
<p>web 服务器会根据请求的内容，然后会 fork 一个新进程来运行外部 c 程序(或 perl 脚本…)， 这个进程会把处理完的数据返回给 web 服务器，最后 web 服务器把内容发送给用户，刚才 fork 的进程也随之退出。</p>
<p>如果下次用户还请求该动态脚本，那么 web 服务器又再次 fork 一个新进程，周而复始的进行</p>
<p>fastcgi:</p>
<p>web 服务器收到一个请求时，他不会重新 fork 一个进程(因为这个进程在 web 服务器启动时就开启了，而且不会退出)，web 服务器直接把内容传递给这个进程(进程间通信，但 fastcgi 使用了别的方式，tcp 方式通信)，这个进程收到请求后进行处理，把结果返回给 web 服务器，最后自己接着等待下一个请求的到来，而不是退出。</p>
<h2 id="Keepalived相关"><a href="#Keepalived相关" class="headerlink" title="Keepalived相关"></a>Keepalived相关</h2><h3 id="keepalived-是什么"><a href="#keepalived-是什么" class="headerlink" title="keepalived 是什么"></a>keepalived 是什么</h3><p>广义上讲是高可用，狭义上讲是主机的冗余和管理</p>
<p>Keepalived起初是为 LVS 设计的，专门用来监控集群系统中各个服务节点的状态，它根据 TCP/IP 参考模型的第三、第四层、第五层交换机制检测每个服务节点的状态，如果某个服务器节点出现异常，或者工作出现故障，Keepalived 将检测到，并将出现的故障的服务器节点从集群系统中剔除，这些工作全部是自动完成的，不需要人工干涉，需要人工完成的只是修复出现故障的服务节点。</p>
<p>后来 Keepalived 又加入了 VRRP 的功能，VRRP(VritrualRouterRedundancyProtocol,虚拟路由冗余协议)出现的目的是解决静态路由出现的单点故障问题，通过 VRRP 可以实现网络不间断稳定运行，因此 Keepalvied 一方面具有服务器状态检测和故障隔离功能，另外一方面也有 HAcluster 功能。</p>
<p>所以 keepalived 的核心功能就是健康检查和失败切换。 所谓的健康检查，就是采用 tcp 三次握手，icmp 请求，http 请求，udp echo 请求等方式对负载均衡器后面的实际的服务器(通常是承载真实业务的服务器)进行保活;</p>
<p>而失败切换主要是应用于配置了主备模式的负载均衡器，利用 VRRP 维持主备负载均衡器的心跳，当主负载均衡器出现问题时，由备负载均衡器承载对应的业务，从而在最大限度上减少流量损失，并提供服务的稳定性</p>
<h3 id="如何理解VRRP协议"><a href="#如何理解VRRP协议" class="headerlink" title="如何理解VRRP协议"></a>如何理解VRRP协议</h3><p>为什么使用 VRRP ? 主机之间的通信都是通过配置静态路由或者(默认网关)来完成的，而主机之间的路由器一旦发生故障，通信就会失效，因此这种通信模式当中，路由器就成了一个单点瓶颈，为了解决这个问题，就引入了 VRRP 协议。</p>
<p>VRRP 协议是一种容错的主备模式的协议，保证当主机的下一跳路由出现故障时，由另一台路由器来代替出现故障的路由器进行工作，通过 VRRP 可以在网络发生故障时透明的进行设备切换而不影响主机之间的数据通信。</p>
<p><strong>VRRP 的三种状态:</strong> </p>
<p><em>VRRP路由器在运行过程中有三种状态:</em></p>
<ol>
<li>Initialize状态: 系统启动后就进入Initialize，此状态下路由器不对 VRRP 报文做任何处理; </li>
<li>Master状态;</li>
<li>Backup状态;</li>
</ol>
<ul>
<li>一般主路由器处于Master状态，备份路由器处于Backup状态。</li>
</ul>
<h3 id="keepalived的工作原理"><a href="#keepalived的工作原理" class="headerlink" title="keepalived的工作原理"></a>keepalived的工作原理</h3><p>keepalived 采用是模块化设计，不同模块实现不同的功能。</p>
<p>keepalived 主要有三个模块，分别是 core、check 和 vrrp。</p>
<p><strong>core</strong>: 是 keepalived 的核心，负责主进程的启动和维护，全局配置文件的加载解析等</p>
<p><strong>check</strong>: 负责 healthchecker(健康检查)，包括了各种健康检查方式，以及对应的配置的解析包括LVS的配置解析;可基于脚本检查对IPVS后端服务器健康状况进行检查</p>
<p><strong>vrrp</strong>: VRRPD子进程，VRRPD 子进程就是来实现 VRRP 协议的</p>
<p>Keepalived 高可用对之间是通过 VRRP 进行通信的， VRRP是通过竞选机制来确定主备的，主的优先级高于备，因此，工作时主会优先获得所有的资源，备节点处于等待状态，当主宕机的时候，备节点就会接管主节点的资源，然后顶替主节点对外提供服务</p>
<p>在 Keepalived 服务对之间，只有作为主的服务器会一直发送 VRRP 广播包,告诉备它还活着，此时备不会抢占主，当主不可用时，即备监听不到主发送的广播包时，就会启动相关服务接管资源，保证业务的连续性.接管速度最快</p>
<h3 id="出现脑裂的原因"><a href="#出现脑裂的原因" class="headerlink" title="出现脑裂的原因"></a>出现脑裂的原因</h3><p><strong><em>什么是脑裂?</em></strong></p>
<ul>
<li><p>在高可用(HA)系统中，当联系2个节点的“心跳线”断开时，本来为一整体、动作协调的HA系统， 就分裂成为2个独立的个体。 </p>
</li>
<li><p>由于相互失去了联系，都以为是对方出了故障。两个节点上的HA软件像“裂脑人”一样，争抢“共享 资源”、争起“应用服务”，就会发生严重后果。共享资源被瓜分、两边“服务”都起不来了;或者两边 “服务”都起来了，但同时读写“共享存储”，导致数据损坏</p>
</li>
</ul>
<p><strong><em>都有哪些原因导致脑裂?</em></strong></p>
<ul>
<li><p>高可用服务器对之间心跳线链路发生故障，导致无法正常通信。</p>
</li>
<li><p>因心跳线坏了(包括断了，老化)。 </p>
</li>
<li><p>因网卡及相关驱动坏了，ip配置及冲突问题(网卡直连) </p>
</li>
<li><p>因心跳线间连接的设备故障(网卡及交换机) </p>
</li>
<li><p>因仲裁的机器出问题(采用仲裁的方案)</p>
</li>
<li><p>高可用服务器上开启了 iptables 防火墙阻挡了心跳消息传输。 </p>
</li>
<li><p>高可用服务器上心跳网卡地址等信息配置不正确，导致发送心跳失败</p>
</li>
<li><p>其他服务配置不当等原因，如心跳方式不同，心跳广插冲突、软件Bug等。</p>
</li>
</ul>
<h3 id="如何解决keepalived脑裂问题"><a href="#如何解决keepalived脑裂问题" class="headerlink" title="如何解决keepalived脑裂问题"></a>如何解决keepalived脑裂问题</h3><p><strong><em>在实际生产环境中，我们从以下方面防止脑裂:</em></strong></p>
<ul>
<li>同时使用串行电缆和以太网电缆连接、同时使用两条心跳线路，这样一条线路断了，另外一条还是好的，依然能传送心跳消息</li>
<li>当检查脑裂时强行关闭一个心跳节点(这个功能需要特殊设备支持，如stonith、fence)相当于备节点接收不到心跳消息，通过单独的线路发送关机命令关闭主节点的电源</li>
<li>做好对脑裂的监控报警</li>
</ul>
<p><strong><em>解决常见方案:</em></strong> </p>
<ul>
<li>如果开启防火墙，一定要让心跳消息通过，一般通过允许IP段的形式解决 </li>
<li>可以拉一条以太网网线或者串口线作为主被节点心跳线路的冗余 </li>
<li>开发检测程序通过监控软件检测脑裂</li>
</ul>
<h1 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h1><h2 id="常见日志文件与各自的用途"><a href="#常见日志文件与各自的用途" class="headerlink" title="常见日志文件与各自的用途"></a>常见日志文件与各自的用途</h2><table>
<thead>
<tr>
<th>路径</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>/var/log/messages</td>
<td>内核及公共消息日志</td>
</tr>
<tr>
<td>/var/log/cron</td>
<td>计划任务日志</td>
</tr>
<tr>
<td>/var/log/dmesg</td>
<td>系统引导日志</td>
</tr>
<tr>
<td>/var/log/maillog</td>
<td>邮件系统日志</td>
</tr>
<tr>
<td>/var/log/secure</td>
<td>记录与访问限制相关日志</td>
</tr>
<tr>
<td>/etc/logrotate.d</td>
<td>此目录下是各个服务的日志轮询配置文件</td>
</tr>
</tbody></table>
<h2 id="Linux系统的运行级别"><a href="#Linux系统的运行级别" class="headerlink" title="Linux系统的运行级别"></a>Linux系统的运行级别</h2><ul>
<li>0=&gt;关机</li>
<li>1=&gt;单用户</li>
<li>2=&gt;多用户有网络服务</li>
<li>3=&gt;多用户无网络服务</li>
<li>4=&gt;保留</li>
<li>5=&gt;图形界面</li>
<li>6=&gt;重启</li>
</ul>
<h2 id="Linux开机过程"><a href="#Linux开机过程" class="headerlink" title="Linux开机过程"></a>Linux开机过程</h2><p>1.开机<a href="https://so.csdn.net/so/search?q=BIOS&spm=1001.2101.3001.7020" target="_blank" rel="noopener">BIOS</a>自检</p>
<p>2.MBR引导</p>
<p>3.grub引导菜单</p>
<p>4.加载内核kernel</p>
<p>5.启动init进程</p>
<p>6.读取inittab文件，执行rc.sysinit,rc等脚本</p>
<p>7.启动mingetty，进入系统登陆界面</p>
<p>详情请参考链接:<a href="https://blog.csdn.net/changexhao/article/details/80913699?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165148004816781435489213%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=165148004816781435489213&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-80913699.142^v9^pc_search_result_cache,157^v4^control&utm_term=linux开机过程&spm=1018.2226.3001.4187" target="_blank" rel="noopener">Linux开机过程</a></p>
<h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h2 id="STP协议"><a href="#STP协议" class="headerlink" title="STP协议"></a>STP协议</h2><p><strong>主要用途：</strong></p>
<ol>
<li><p>STP通过阻塞冗余链路，来消除桥接网络中可能存在的路径回环；</p>
</li>
<li><p>当前活动路径发生故障时，STP激活冗余链路恢复网络连通性。</p>
</li>
</ol>
<p><strong>为什么要用STP:</strong></p>
<ul>
<li>原因：交换网络存在环路时引起：广播环路（广播风暴）；桥表损坏。</li>
</ul>
<p><strong>介绍一下ACL和NAT?</strong></p>
<p>ACL：</p>
<ol>
<li><p>访问控制列表（ACL）是应用在路由器接口的指令列表（规则），用来告诉路由器哪些数据包可以接收转发，哪些数据包需要拒绝；</p>
</li>
<li><p>ACL的工作原理 ：读取第三层及第四层包头中的信息，根据预先定义好的规则对包进行过滤；</p>
</li>
<li><p>使用ACL实现网络控制：实现访问控制列表的核心技术是包过滤；</p>
</li>
<li><p>ACL的两种基本类型（标准访问控制列表；扩展访问控制列表）</p>
</li>
</ol>
<p>NAT：</p>
<ul>
<li>改变IP包头使目的地址，源地址或两个地址在包头中被不同地址替换。</li>
</ul>
<p><strong>NAT有几种方式?</strong></p>
<ul>
<li><p>静态NAT</p>
</li>
<li><p>动态NAT</p>
</li>
<li><p>PAT</p>
</li>
</ul>
<h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><p>RIP是Routing Information Protocol（路由信息协议）的简称，它是一种较为简单的内部网关协议（Interior Gateway Protocol）。RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量来衡量到达目的网络的距离。RIP通过UDP报文进行路由信息的交换，使用的端口号为520。</p>
<p>RIP包括RIP-1和RIP-2两个版本，RIP-2对RIP-1进行了扩充，使其更具有优势。</p>
<p>RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离。在RIP网络中，缺省情况下，设备到与它直接相连网络的跳数为0，通过一个设备可达的网络的跳数为1，其余依此类推。也就是说，度量值等于从本网络到达目的网络间的设备数量。为限制收敛时间，RIP规定度量值取0～15之间的整数，大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达。由于这个限制，使得RIP不可能在大型网络中得到应用。</p>
<p><strong>静态路由的缺陷</strong></p>
<ol>
<li>配置量大</li>
<li>只能适用于小型网络中</li>
<li>维护麻烦，无法自动适应网络的拓扑变化</li>
</ol>
<p>动态路由协议：可以根据网络拓扑的变化根据协议来选择路径</p>
<p><strong>动态路由协议分为：</strong></p>
<ul>
<li>内部网关协议：运行在同一个AS号内的路由协议。如：RIP、OSPF、EIGRP（思科设备专用）</li>
<li>外部网关协议：运行在不同AS号之间的路由协议。如：BGP</li>
</ul>
<p><strong>内部网关协议分为：</strong></p>
<ul>
<li>距离矢量协议（RIP、EIGRP）</li>
<li>链路状态协议（OSPF）</li>
</ul>
<p>RIP协议：属于内部网关协议，是一个距离矢量协议，工作在UDP的520端口</p>
<p>有类路由协议：在发送路由更新的时候是不会携带子网掩码的（已经被淘汰）</p>
<p>无类路由协议：在发送路由更新的时候携带子网掩码。</p>
<p><strong>RIP的两个版本</strong></p>
<p>RIPv1：是一个有类路由协议，是通过广播（255.255.255.255）的形式来发送路由更新的。</p>
<p>RIPv2：是一个无类路由协议，是通过组播（224.0.0.9）的形式来发送路由更新的。</p>
<p>RIP的选路标准：通过跳数来衡量路径，RIP认为跳数越少，路径越优先。同时这也是它的缺陷，因为RIP有可能选择了一条次优路径。 </p>
<p><strong>RIPv1的特点：</strong></p>
<ol>
<li>有类别路由协议。</li>
<li>广播更新。</li>
<li>基于UDP，端口号520</li>
</ol>
<p>RIP是一个基于UDP的路由协议，并且RIPv1的数据包不能超过512字节（RIP报文头部占用4个字节,而每个路由条目占用20个八位组字节。因此,RIP消息最大为4+(25*20)=504个字节,再加上8个字节的UDP头部,所以RIP数据报的大小(不含IP包的头部)最大可达512个字节。）。RIPv1的协议报文中没有携带掩码信息，所以RIPv1在发送和接收路由更新时会根据主类网段掩码和接口地址掩码来处理路由条目。因此RIPv1无法支持路由聚合，也不支持不连续子网。RIPv1的协议报文中没有验证字段，所以RIPv1也不支持验证。</p>
<p><strong>RIPv2特点：</strong></p>
<ol>
<li>无类别路由协议。</li>
<li>组播更新，组播地址224.0.0.9</li>
<li>基于UDP，端口号520.</li>
<li>支持外部Tag。</li>
<li>支持路由聚合和CIDR</li>
<li>支持指定下一跳。</li>
<li>支持认证。</li>
</ol>
<h2 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h2><p>路由协议OSPF全称为Open Shortest Path First，也就开放的最短路径优先协议，因为OSPF是由IETF开发的，它的使用不受任何厂商限制，所有人都可以使用，所以称为开放的，而最短路径优先（SPF）只是OSPF的核心思想，其使用的算法是Dijkstra算法，最短路径优先并没有太多特殊的含义，并没有任何一个路由协议是最长路径优先的，所有协议，都会选最短的。</p>
<ul>
<li>OSPF的流量使用IP协议号89。</li>
<li>OSPF工作在单个AS，是个绝对的内部网关路由协议（Interior Gateway Protocol，即IGP）。</li>
<li>OSPF对网络没有跳数限制，支持 Classless Interdomain Routing (CIDR)和Variable-Length Subnet Masks (VLSMs)，没有自动汇总功能，但可以手工在任意比特位汇总，并且手工汇总没有任何条件限制，可以汇总到任意掩码长度。</li>
<li>OSPF支持认证，并且支持明文和MD5认证；OSPF不可以通过Offset list来改变路由的metric。</li>
<li>OSPF并不会周期性更新路由表，而采用增量更新，即只在路由有变化时，才会发送更新，并且只发送有变化的路由信息；事实上，OSPF是间接设置了周期性更新路由的规则，因为所有路由都是有刷新时间的，当达到刷新时间阀值时，该路由就会产生一次更新，默认时间为1800秒，即30分钟，所以OSPF路由的定期更新周期默认为30分钟。</li>
<li>OSPF所有路由的管理距离(Ddministrative Distance)为110，OSPF只支持等价负载均衡。</li>
<li>距离矢量路由协议的根本特征就是自己的路由表是完全从其它路由器学来的，并且将收到的路由条目一丝不变地放进自己的路由表，运行距离矢量路由协议的路由器之间交换的是路由表，距离矢量路由协议是没有大脑的，路由表从来不会自己计算，总是把别人的路由表拿来就用；而OSPF完全抛弃了这种不可靠的算法，OSPF是典型的链路状态路由协议，路由器之间交换的并不是路由表，而是链路状态，OSPF通过获得网络中所有的链路状态信息，从而计算出到达每个目标精确的网络路径。</li>
</ul>
<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><p>参考链接: <a href="https://www.zhihu.com/question/379143600" target="_blank" rel="noopener">https://www.zhihu.com/question/379143600</a></p>
<h3 id="1、简述etcd及其特点"><a href="#1、简述etcd及其特点" class="headerlink" title="1、简述etcd及其特点"></a><strong>1、简述etcd及其特点</strong></h3><p>etcd是CoreOS团队发起的开源项目，是一个管理配置信息和服务发现（service discovery）的项目，它的目标是构建一个高可用的分布式键值（key-value）数据库，基于Go语言实现。</p>
<p>特点：</p>
<ul>
<li>简单：支持REST风格的HTTP+JSON API</li>
<li>安全：支持HTTPS方式的访问</li>
<li>快速：支持并发1k/s的写操作</li>
<li>可靠：支持分布式结构，基于Raft的一致性算法，Raft是一套通过选举主节点来实现分布式系统一致性的算法。</li>
</ul>
<h3 id="2、简述etcd适应的场景"><a href="#2、简述etcd适应的场景" class="headerlink" title="2、简述etcd适应的场景"></a><strong>2、简述etcd适应的场景</strong></h3><p>etcd基于其优秀的特点，可广泛的应用于以下场景：</p>
<ul>
<li>服务发现（Service Discovery）：服务发现主要解决在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听UDP或TCP端口，并且通过名字就可以查找和连接。</li>
<li>消息发布与订阅：在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。应用中用到的一些配置信息放到etcd上进行集中管理。</li>
<li>负载均衡：在分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。etcd本身分布式架构存储的信息访问支持负载均衡。etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到etcd中也可以实现负载均衡的效果。</li>
<li>分布式通知与协调：与消息发布和订阅类似，都用到了etcd中的Watcher机制，通过注册与异步通知机制，实现<a href="https://www.zhihu.com/search?q=分布式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">分布式</a>环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。</li>
<li>分布式锁：因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</li>
<li>集群监控与Leader竞选：通过etcd来进行监控实现起来非常简单并且实时性强。</li>
</ul>
<h3 id="3、简述什么是Kubernetes"><a href="#3、简述什么是Kubernetes" class="headerlink" title="3、简述什么是Kubernetes"></a><strong>3、简述什么是Kubernetes</strong></h3><p>Kubernetes是一个全新的基于容器技术的分布式系统支撑平台。是Google开源的容器集群管理系统（谷歌内部：Borg）。在Docker技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。并且具有完备的集群管理能力，多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和发现机制、內建智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制以及多粒度的资源配额管理能力。</p>
<h3 id="4、简述Kubernetes和Docker的关系"><a href="#4、简述Kubernetes和Docker的关系" class="headerlink" title="4、简述Kubernetes和Docker的关系"></a><strong>4、简述Kubernetes和Docker的关系</strong></h3><p>Docker提供容器的生命周期管理和Docker镜像构建运行时容器。它的主要优点是将将软件/应用程序运行所需的设置和依赖项打包到一个容器中，从而实现了可移植性等优点。</p>
<p>Kubernetes用于关联和编排在多个主机上运行的容器。</p>
<h3 id="5、简述Minikube、Kubectl、Kubelet分别是什么"><a href="#5、简述Minikube、Kubectl、Kubelet分别是什么" class="headerlink" title="5、简述Minikube、Kubectl、Kubelet分别是什么"></a><strong>5、简述Minikube、Kubectl、Kubelet分别是什么</strong></h3><p>Minikube是一种可以在本地轻松运行一个单节点Kubernetes群集的工具。</p>
<p>Kubectl是一个命令行工具，可以使用该工具控制Kubernetes集群管理器，如检查<a href="https://www.zhihu.com/search?q=群集资源&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">群集资源</a>，创建、删除和更新组件，查看应用程序。</p>
<p>Kubelet是一个代理服务，它在每个节点上运行，并使从服务器与主服务器通信。</p>
<h3 id="6、简述Kubernetes常见的部署方式"><a href="#6、简述Kubernetes常见的部署方式" class="headerlink" title="6、简述Kubernetes常见的部署方式"></a><strong>6、简述Kubernetes常见的部署方式</strong></h3><p>常见的Kubernetes部署方式有：</p>
<ul>
<li>kubeadm，也是推荐的一种部署方式；</li>
<li><a href="https://www.zhihu.com/search?q=二进制&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">二进制</a>；</li>
<li>minikube，在本地轻松运行一个单节点Kubernetes群集的工具。</li>
</ul>
<h3 id="7、简述Kubernetes如何实现集群管理"><a href="#7、简述Kubernetes如何实现集群管理" class="headerlink" title="7、简述Kubernetes如何实现集群管理"></a><strong>7、简述Kubernetes如何实现集群管理</strong></h3><p>在集群管理方面，Kubernetes将集群中的机器划分为一个Master节点和一群工作节点Node。其中，在Master节点运行着集群管理相关的一组进程kube-apiserver、kube-controller-manager和kube-scheduler，这些进程实现了整个集群的资源管理、Pod调度、弹性伸缩、安全控制、系统监控和纠错等管理能力，并且都是全自动完成的。</p>
<h3 id="8、简述Kubernetes的优势、适应场景及其特点"><a href="#8、简述Kubernetes的优势、适应场景及其特点" class="headerlink" title="8、简述Kubernetes的优势、适应场景及其特点"></a><strong>8、简述Kubernetes的优势、适应场景及其特点</strong></h3><p>Kubernetes作为一个完备的分布式系统支撑平台，其主要优势：</p>
<ul>
<li>容器编排</li>
<li>轻量级</li>
<li>开源</li>
<li>弹性伸缩</li>
<li>负载均衡</li>
</ul>
<p>Kubernetes常见场景：</p>
<ul>
<li>快速部署应用</li>
<li>快速扩展应用</li>
<li>无缝对接新的应用功能</li>
<li>节省资源，优化硬件资源的使用</li>
</ul>
<p>Kubernetes相关特点：</p>
<ul>
<li>可移植：支持公有云、私有云、<a href="https://www.zhihu.com/search?q=混合云&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">混合云</a>、多重云（multi-cloud）。</li>
<li>可扩展: 模块化,、插件化、可挂载、可组合。</li>
<li>自动化: 自动部署、自动重启、自动复制、自动伸缩/扩展。</li>
</ul>
<h3 id="9、简述Kubernetes的缺点或当前的不足之处"><a href="#9、简述Kubernetes的缺点或当前的不足之处" class="headerlink" title="9、简述Kubernetes的缺点或当前的不足之处"></a><strong>9、简述Kubernetes的缺点或当前的不足之处</strong></h3><p>Kubernetes当前存在的缺点（不足）如下：</p>
<ul>
<li>安装过程和配置相对困难复杂。</li>
<li>管理服务相对繁琐。</li>
<li>运行和编译需要很多时间。</li>
<li>它比其他替代品更昂贵。</li>
<li>对于简单的应用程序来说，可能不需要涉及Kubernetes即可满足。</li>
</ul>
<h3 id="10、简述Kubernetes相关基础概念"><a href="#10、简述Kubernetes相关基础概念" class="headerlink" title="10、简述Kubernetes相关基础概念"></a><strong>10、简述Kubernetes相关基础概念</strong></h3><ul>
<li>Master：Kubernetes集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有etcd存储服务（可选），运行Api Server进程，Controller Manager服务进程及Scheduler服务进程。</li>
<li>Node（worker）：Node（worker）是Kubernetes集群架构中运行Pod的服务节点，是Kubernetes集群操作的单元，用来承载被分配Pod的运行，是Pod运行的宿主机。运行Docker Eninge服务，守护进程kunelet及负载均衡器kube-proxy。</li>
<li>Pod：运行于Node节点上，若干相关容器的组合。Pod内包含的容器运行在同一宿主机上，使用相同的网络命名空间、IP地址和端口，能够通过localhost进行通信。Pod是Kubernetes进行创建、调度和管理的最小单位，它提供了比容器更高层次的抽象，使得部署和管理更加灵活。一个Pod可以包含一个容器或者多个相关容器。</li>
<li>Label：Kubernetes中的Label实质是一系列的Key/Value键值对，其中key与value可自定义。Label可以附加到各种资源对象上，如Node、Pod、Service、RC等。一个资源对象可以定义任意数量的Label，同一个Label也可以被添加到任意数量的资源对象上去。Kubernetes通过Label Selector（标签选择器）查询和筛选资源对象。</li>
<li>Replication Controller：Replication Controller用来管理Pod的副本，保证集群中存在指定数量的Pod副本。集群中副本的数量大于指定数量，则会停止指定数量之外的多余容器数量。反之，则会启动少于指定数量个数的容器，保证数量不变。Replication Controller是实现弹性伸缩、动态扩容和滚动升级的核心。</li>
<li>Deployment：Deployment在内部使用了RS来实现目的，Deployment相当于RC的一次升级，其最大的特色为可以随时获知当前Pod的部署进度。</li>
<li>HPA（Horizontal Pod Autoscaler）：Pod的横向自动扩容，也是Kubernetes的一种资源，通过追踪分析RC控制的所有Pod目标的负载变化情况，来确定是否需要针对性的调整Pod副本数量。</li>
<li>Service：Service定义了Pod的逻辑集合和访问该集合的策略，是真实服务的抽象。Service提供了一个统一的服务访问入口以及服务代理和发现机制，关联多个相同Label的Pod，用户不需要了解后台Pod是如何运行。</li>
<li>Volume：Volume是Pod中能够被多个容器访问的共享目录，Kubernetes中的Volume是定义在Pod上，可以被一个或多个Pod中的容器挂载到某个目录下。</li>
<li>Namespace：Namespace用于实现多租户的资源隔离，可将集群内部的资源对象分配到不同的Namespace中，形成逻辑上的不同项目、小组或用户组，便于不同的Namespace在共享使用整个集群的资源的同时还能被分别管理。</li>
</ul>
<h3 id="11、简述Kubernetes集群相关组件"><a href="#11、简述Kubernetes集群相关组件" class="headerlink" title="11、简述Kubernetes集群相关组件"></a><strong>11、简述Kubernetes集群相关组件</strong></h3><p>Kubernetes Master控制组件，调度管理整个系统（集群），包含如下组件：</p>
<ul>
<li>Kubernetes API Server：作为Kubernetes系统的入口，其封装了核心对象的<a href="https://www.zhihu.com/search?q=增删改查&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">增删改查</a>操作，以RESTful API接口方式提供给外部客户和内部组件调用，集群内各个功能模块之间数据交互和通信的中心枢纽。</li>
<li>Kubernetes Scheduler：为新建立的Pod进行节点（Node）选择（即分配机器），负责集群的资源调度。</li>
<li>Kubernetes Controller：负责执行各种控制器，目前已经提供了很多控制器来保证Kubernetes的正常运行。</li>
<li>Replication Controller：管理维护Replication Controller，关联Replication Controller和Pod，保证Replication Controller定义的副本数量与实际运行Pod数量一致。</li>
<li>Node Controller：管理维护Node，定期检查Node的健康状态，标识出（失效|未失效）的Node节点。</li>
<li>Namespace Controller：管理维护Namespace，定期清理无效的Namespace，包括Namesapce下的API对象，比如Pod、Service等。</li>
<li>Service Controller：管理维护Service，提供负载以及服务代理。</li>
<li>EndPoints Controller：管理维护Endpoints，关联Service和Pod，创建Endpoints为Service的后端，当Pod发生变化时，实时更新Endpoints。</li>
<li>Service Account Controller：管理维护Service Account，为每个Namespace创建默认的Service Account，同时为Service Account创建Service Account Secret。</li>
<li>Persistent Volume Controller：管理维护Persistent Volume和Persistent Volume Claim，为新的Persistent Volume Claim分配Persistent Volume进行绑定，为释放的Persistent Volume执行清理回收。</li>
<li>Daemon Set Controller：管理维护Daemon Set，负责创建Daemon Pod，保证指定的Node上正常的运行Daemon Pod。</li>
<li>Deployment Controller：管理维护Deployment，关联Deployment和Replication Controller，保证运行指定数量的Pod。当Deployment更新时，控制实现Replication Controller和Pod的更新。</li>
<li>Job Controller：管理维护Job，为Jod创建一次性任务Pod，保证完成Job指定完成的任务数目</li>
<li>Pod Autoscaler Controller：实现Pod的自动伸缩，定时获取监控数据，进行策略匹配，当满足条件时执行Pod的伸缩动作。</li>
</ul>
<h3 id="12、简述Kubernetes-RC的机制"><a href="#12、简述Kubernetes-RC的机制" class="headerlink" title="12、简述Kubernetes RC的机制"></a><strong>12、简述Kubernetes RC的机制</strong></h3><p>Replication Controller用来管理Pod的副本，保证集群中存在指定数量的Pod副本。当定义了RC并提交至Kubernetes集群中之后，Master节点上的Controller Manager组件获悉，并同时巡检系统中当前存活的目标Pod，并确保目标Pod实例的数量刚好等于此RC的期望值，若存在过多的Pod副本在运行，系统会停止一些Pod，反之则自动创建一些Pod。</p>
<h3 id="13、简述Kubernetes-Replica-Set和Replication-Controller之间有什么区别"><a href="#13、简述Kubernetes-Replica-Set和Replication-Controller之间有什么区别" class="headerlink" title="13、简述Kubernetes Replica Set和Replication Controller之间有什么区别"></a><strong>13、简述Kubernetes Replica Set和Replication Controller之间有什么区别</strong></h3><p>Replica Set和Replication Controller类似，都是确保在任何给定时间运行指定数量的Pod副本。不同之处在于RS使用基于集合的选择器，而Replication Controller使用基于权限的选择器。</p>
<h3 id="14、简述kube-proxy的作用"><a href="#14、简述kube-proxy的作用" class="headerlink" title="14、简述kube-proxy的作用"></a><strong>14、简述kube-proxy的作用</strong></h3><p>kube-proxy运行在所有节点上，它监听apiserver中service和endpoint的变化情况，创建路由规则以提供服务IP和负载均衡功能。简单理解此进程是Service的透明代理兼<a href="https://www.zhihu.com/search?q=负载均衡器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">负载均衡器</a>，其核心功能是将到某个Service的访问请求转发到后端的多个Pod实例上。</p>
<h3 id="15、简述kube-proxy-iptables的原理"><a href="#15、简述kube-proxy-iptables的原理" class="headerlink" title="15、简述kube-proxy iptables的原理"></a><strong>15、简述kube-proxy iptables的原理</strong></h3><p>Kubernetes从1.2版本开始，将iptables作为kube-proxy的默认模式。iptables模式下的kube-proxy不再起到Proxy的作用，其核心功能：通过API Server的Watch接口实时跟踪Service与Endpoint的变更信息，并更新对应的iptables规则，Client的请求流量则通过iptables的NAT机制“直接路由”到目标Pod。</p>
<h3 id="16、简述kube-proxy-ipvs的原理"><a href="#16、简述kube-proxy-ipvs的原理" class="headerlink" title="16、简述kube-proxy ipvs的原理"></a><strong>16、简述kube-proxy ipvs的原理</strong></h3><p>IPVS在Kubernetes1.11中升级为GA稳定版。IPVS则专门用于高性能负载均衡，并使用更高效的数据结构（Hash表），允许几乎无限的规模扩张，因此被kube-proxy采纳为最新模式。</p>
<p>在IPVS模式下，使用iptables的扩展ipset，而不是直接调用iptables来生成规则链。iptables规则链是一个线性的数据结构，ipset则引入了带索引的数据结构，因此当规则很多时，也可以很高效地查找和匹配。</p>
<p>可以将ipset简单理解为一个IP（段）的集合，这个集合的内容可以是IP地址、IP网段、端口等，iptables可以直接添加规则对这个“可变的集合”进行操作，这样做的好处在于可以大大减少iptables规则的数量，从而减少性能损耗。</p>
<h3 id="17、简述kube-proxy-ipvs和iptables的异同"><a href="#17、简述kube-proxy-ipvs和iptables的异同" class="headerlink" title="17、简述kube-proxy ipvs和iptables的异同"></a><strong>17、简述kube-proxy ipvs和iptables的异同</strong></h3><p>iptables与IPVS都是基于Netfilter实现的，但因为定位不同，二者有着本质的差别：iptables是为防火墙而设计的；IPVS则专门用于高性能负载均衡，并使用更高效的数据结构（Hash表），允许几乎无限的规模扩张。</p>
<p>与iptables相比，IPVS拥有以下明显优势：</p>
<ul>
<li>为大型集群提供了更好的可扩展性和性能；</li>
<li>支持比iptables更复杂的复制均衡算法（最小负载、最少连接、加权等）；</li>
<li>支持服务器健康检查和连接重试等功能；</li>
<li>可以动态修改ipset的集合，即使iptables的规则正在使用这个集合。</li>
</ul>
<h3 id="18、简述Kubernetes中什么是静态Pod"><a href="#18、简述Kubernetes中什么是静态Pod" class="headerlink" title="18、简述Kubernetes中什么是静态Pod"></a><strong>18、简述Kubernetes中什么是静态Pod</strong></h3><p>静态Pod是由kubelet进行管理的仅存在于特定Node的Pod上，他们不能通过API Server进行管理，无法与ReplicationController、Deployment或者DaemonSet进行关联，并且kubelet无法对他们进行健康检查。静态Pod总是由kubelet进行创建，并且总是在kubelet所在的Node上运行。</p>
<h3 id="19、简述Kubernetes中Pod可能位于的状态"><a href="#19、简述Kubernetes中Pod可能位于的状态" class="headerlink" title="19、简述Kubernetes中Pod可能位于的状态"></a><strong>19、简述Kubernetes中Pod可能位于的状态</strong></h3><ul>
<li>Pending：API Server已经创建该Pod，且Pod内还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程。</li>
<li>Running：Pod内所有容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态。</li>
<li>Succeeded：Pod内所有容器均成功执行退出，且不会重启。</li>
<li>Failed：Pod内所有容器均已退出，但至少有一个容器退出为失败状态。</li>
<li>Unknown：由于某种原因无法获取该Pod状态，可能由于网络通信不畅导致。</li>
</ul>
<h3 id="20、简述Kubernetes创建一个Pod的主要流程？"><a href="#20、简述Kubernetes创建一个Pod的主要流程？" class="headerlink" title="20、简述Kubernetes创建一个Pod的主要流程？"></a><strong>20、简述Kubernetes创建一个Pod的主要流程？</strong></h3><p>Kubernetes中创建一个Pod涉及多个组件之间联动，主要流程如下：</p>
<ul>
<li>客户端提交Pod的配置信息（可以是yaml文件定义的信息）到kube-apiserver。</li>
<li>Apiserver收到指令后，通知给controller-manager创建一个资源对象。</li>
<li>Controller-manager通过api-server将Pod的配置信息存储到etcd数据中心中。</li>
<li>Kube-scheduler检测到Pod信息会开始调度预选，会先过滤掉不符合Pod资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行Pod的节点，然后将Pod的资源配置单发送到Node节点上的kubelet组件上。</li>
<li>Kubelet根据scheduler发来的资源配置单运行Pod，运行成功后，将Pod的运行信息返回给scheduler，scheduler将返回的Pod运行状况的信息存储到etcd数据中心。</li>
</ul>
<h3 id="21、简述Kubernetes中Pod的重启策略"><a href="#21、简述Kubernetes中Pod的重启策略" class="headerlink" title="21、简述Kubernetes中Pod的重启策略"></a><strong>21、简述Kubernetes中Pod的重启策略</strong></h3><p>Pod重启策略（RestartPolicy）应用于Pod内的所有容器，并且仅在Pod所处的Node上由kubelet进行判断和重启操作。当某个容器异常退出或者健康检查失败时，kubelet将根据RestartPolicy的设置来进行相应操作。</p>
<p>Pod的重启策略包括Always、OnFailure和Never，默认值为Always。</p>
<ul>
<li>Always：当容器失效时，由kubelet自动重启该容器；</li>
<li>OnFailure：当容器终止运行且退出码不为0时，由kubelet自动重启该容器；</li>
<li>Never：不论容器运行状态如何，kubelet都不会重启该容器。</li>
</ul>
<p>同时Pod的重启策略与控制方式关联，当前可用于管理Pod的控制器包括ReplicationController、Job、DaemonSet及直接管理kubelet管理（静态Pod）。</p>
<p>不同控制器的重启策略限制如下：</p>
<ul>
<li>RC和DaemonSet：必须设置为Always，需要保证该容器持续运行；</li>
<li>Job：OnFailure或Never，确保容器执行完成后不再重启；</li>
<li>kubelet：在Pod失效时重启，不论将RestartPolicy设置为何值，也不会对Pod进行健康检查。</li>
</ul>
<h3 id="22、简述Kubernetes中Pod的健康检查方式"><a href="#22、简述Kubernetes中Pod的健康检查方式" class="headerlink" title="22、简述Kubernetes中Pod的健康检查方式"></a><strong>22、简述Kubernetes中Pod的健康检查方式</strong></h3><p>对Pod的健康检查可以通过两类探针来检查：LivenessProbe和ReadinessProbe。</p>
<ul>
<li>LivenessProbe探针：用于判断容器是否存活（running状态），如果LivenessProbe探针探测到容器不健康，则kubelet将杀掉该容器，并根据容器的重启策略做相应处理。若一个容器不包含LivenessProbe探针，kubelet认为该容器的LivenessProbe探针返回值用于是“Success”。</li>
<li>ReadineeProbe探针：用于判断容器是否启动完成（ready状态）。如果ReadinessProbe探针探测到失败，则Pod的状态将被修改。Endpoint Controller将从Service的Endpoint中删除包含该容器所在Pod的Eenpoint。</li>
<li>startupProbe探针：启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉。</li>
</ul>
<h3 id="23、简述Kubernetes-Pod的LivenessProbe探针的常见方式"><a href="#23、简述Kubernetes-Pod的LivenessProbe探针的常见方式" class="headerlink" title="23、简述Kubernetes Pod的LivenessProbe探针的常见方式"></a><strong>23、简述Kubernetes Pod的LivenessProbe探针的常见方式</strong></h3><p>kubelet定期执行LivenessProbe探针来诊断容器的健康状态，通常有以下三种方式：</p>
<ul>
<li>ExecAction：在容器内执行一个命令，若返回码为0，则表明容器健康。</li>
<li>TCPSocketAction：通过容器的IP地址和端口号执行TCP检查，若能建立TCP连接，则表明容器健康。</li>
<li>HTTPGetAction：通过容器的IP地址、端口号及路径调用HTTP Get方法，若响应的状态码大于等于200且小于400，则表明容器健康。</li>
</ul>
<h3 id="24、简述Kubernetes-Pod的常见调度方式"><a href="#24、简述Kubernetes-Pod的常见调度方式" class="headerlink" title="24、简述Kubernetes Pod的常见调度方式"></a><strong>24、简述Kubernetes Pod的常见调度方式</strong></h3><p>Kubernetes中，Pod通常是容器的载体，主要有如下常见调度方式：</p>
<ul>
<li><p>Deployment或RC：该调度策略主要功能就是自动部署一个容器应用的多份副本，以及持续监控副本的数量，在集群内始终维持用户指定的副本数量。</p>
</li>
<li><p>NodeSelector：定向调度，当需要手动指定将Pod调度到特定Node上，可以通过Node的标签（Label）和Pod的nodeSelector属性相匹配。</p>
</li>
<li><p>NodeAffinity亲和性调度：亲和性调度机制极大的扩展了Pod的调度能力，目前有两种节点<a href="https://www.zhihu.com/search?q=亲和力&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">亲和力</a>表达：</p>
</li>
<li><ul>
<li>requiredDuringSchedulingIgnoredDuringExecution：硬规则，必须满足指定的规则，调度器才可以调度Pod至Node上（类似nodeSelector，语法不同）。</li>
<li>preferredDuringSchedulingIgnoredDuringExecution：软规则，优先调度至满足的Node的节点，但不强求，多个优先级规则还可以设置权重值。</li>
</ul>
</li>
</ul>
<ul>
<li><p>Taints和Tolerations（污点和容忍）：</p>
</li>
<li><ul>
<li>Taint：使Node拒绝特定Pod运行；</li>
<li>Toleration：为Pod的属性，表示Pod能容忍（运行）标注了Taint的Node。</li>
</ul>
</li>
</ul>
<h3 id="25、简述Kubernetes初始化容器（init-container）"><a href="#25、简述Kubernetes初始化容器（init-container）" class="headerlink" title="25、简述Kubernetes初始化容器（init container）"></a><strong>25、简述Kubernetes初始化容器（init container）</strong></h3><p>init container的运行方式与应用容器不同，它们必须先于应用容器执行完成，当设置了多个init container时，将按顺序逐个运行，并且只有前一个init container运行成功后才能运行后一个init container。当所有init container都成功运行后，Kubernetes才会初始化Pod的各种信息，并开始创建和运行应用容器。</p>
<h3 id="26、简述Kubernetes-deployment升级过程"><a href="#26、简述Kubernetes-deployment升级过程" class="headerlink" title="26、简述Kubernetes deployment升级过程"></a><strong>26、简述Kubernetes deployment升级过程</strong></h3><ul>
<li>初始创建Deployment时，系统创建了一个ReplicaSet，并按用户的需求创建了对应数量的Pod副本。</li>
<li>当更新Deployment时，系统创建了一个新的ReplicaSet，并将其副本数量扩展到1，然后将旧ReplicaSet缩减为2。</li>
<li>之后，系统继续按照相同的更新策略对新旧两个ReplicaSet进行逐个调整。</li>
<li>最后，新的ReplicaSet运行了对应个新版本Pod副本，旧的ReplicaSet副本数量则缩减为0。</li>
</ul>
<h3 id="27、简述Kubernetes-deployment升级策略"><a href="#27、简述Kubernetes-deployment升级策略" class="headerlink" title="27、简述Kubernetes deployment升级策略"></a><strong>27、简述Kubernetes deployment升级策略</strong></h3><p>在Deployment的定义中，可以通过spec.strategy指定Pod更新的策略，目前支持两种策略：Recreate（重建）和RollingUpdate（滚动更新），默认值为RollingUpdate。</p>
<ul>
<li>Recreate：设置spec.strategy.type=Recreate，表示Deployment在更新Pod时，会先杀掉所有正在运行的Pod，然后创建新的Pod。</li>
<li>RollingUpdate：设置spec.strategy.type=RollingUpdate，表示Deployment会以滚动更新的方式来逐个更新Pod。同时，可以通过设置spec.strategy.rollingUpdate下的两个参数（maxUnavailable和maxSurge）来控制滚动更新的过程。</li>
</ul>
<h3 id="28、简述Kubernetes-DaemonSet类型的资源特性"><a href="#28、简述Kubernetes-DaemonSet类型的资源特性" class="headerlink" title="28、简述Kubernetes DaemonSet类型的资源特性"></a><strong>28、简述Kubernetes DaemonSet类型的资源特性</strong></h3><p>DaemonSet资源对象会在每个Kubernetes集群中的节点上运行，并且每个节点只能运行一个Pod，这是它和Deployment资源对象的最大也是唯一的区别。因此，在定义yaml文件中，不支持定义replicas。</p>
<p>它的一般使用场景如下：</p>
<ul>
<li>在去做每个节点的日志收集工作。</li>
<li>监控每个节点的的运行状态。</li>
</ul>
<h3 id="29、简述Kubernetes自动扩容机制"><a href="#29、简述Kubernetes自动扩容机制" class="headerlink" title="29、简述Kubernetes自动扩容机制"></a><strong>29、简述Kubernetes自动扩容机制</strong></h3><p>Kubernetes使用Horizontal Pod Autoscaler（HPA）的控制器实现基于CPU使用率进行自动Pod扩缩容的功能。HPA控制器周期性地监测目标Pod的资源性能指标，并与HPA资源对象中的扩缩容条件进行对比，在满足条件时对Pod副本数量进行调整。</p>
<p>Kubernetes中的某个Metrics Server（Heapster或自定义Metrics Server）持续采集所有Pod副本的指标数据。HPA控制器通过Metrics Server的API（Heapster的API或聚合API）获取这些数据，基于用户定义的扩缩容规则进行计算，得到目标Pod副本数量。</p>
<p>当目标Pod副本数量与当前副本数量不同时，HPA控制器就向Pod的副本控制器（Deployment、RC或ReplicaSet）发起scale操作，调整Pod的副本数量，完成扩缩容操作。</p>
<h3 id="30、简述Kubernetes-Service类型"><a href="#30、简述Kubernetes-Service类型" class="headerlink" title="30、简述Kubernetes Service类型"></a><strong>30、简述Kubernetes Service类型</strong></h3><p>通过创建Service，可以为一组具有相同功能的容器应用提供一个统一的入口地址，并且将请求负载分发到后端的各个容器应用上。其主要类型有：</p>
<ul>
<li>ClusterIP：虚拟的服务IP地址，该地址用于Kubernetes集群内部的Pod访问，在Node上kube-proxy通过设置的iptables规则进行转发；</li>
<li>NodePort：使用宿主机的端口，使能够访问各Node的外部客户端通过Node的IP地址和端口号就能访问服务；</li>
<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，需要在spec.status.loadBalancer字段指定外部负载均衡器的IP地址，通常用于<a href="https://www.zhihu.com/search?q=公有云&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">公有云</a>。</li>
</ul>
<h3 id="31、简述Kubernetes-Service分发后端的策略"><a href="#31、简述Kubernetes-Service分发后端的策略" class="headerlink" title="31、简述Kubernetes Service分发后端的策略"></a><strong>31、简述Kubernetes Service分发后端的策略</strong></h3><p>Service负载分发的策略有：RoundRobin和SessionAffinity</p>
<ul>
<li>RoundRobin：默认为轮询模式，即轮询将请求转发到后端的各个Pod上。</li>
<li>SessionAffinity：基于客户端IP地址进行会话保持的模式，即第1次将某个客户端发起的请求转发到后端的某个Pod上，之后从相同的<a href="https://www.zhihu.com/search?q=客户端&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">客户端</a>发起的请求都将被转发到后端相同的Pod上。</li>
</ul>
<h3 id="32、简述Kubernetes-Headless-Service"><a href="#32、简述Kubernetes-Headless-Service" class="headerlink" title="32、简述Kubernetes Headless Service"></a><strong>32、简述Kubernetes Headless Service</strong></h3><p>在某些应用场景中，若需要人为指定负载均衡器，不使用Service提供的默认负载均衡的功能，或者应用程序希望知道属于同组服务的其他实例。Kubernetes提供了Headless Service来实现这种功能，即不为Service设置ClusterIP（入口IP地址），仅通过Label Selector将后端的Pod列表返回给调用的客户端。</p>
<h3 id="33、简述Kubernetes外部如何访问集群内的服务"><a href="#33、简述Kubernetes外部如何访问集群内的服务" class="headerlink" title="33、简述Kubernetes外部如何访问集群内的服务"></a><strong>33、简述Kubernetes外部如何访问集群内的服务</strong></h3><p>对于Kubernetes，集群外的客户端默认情况，无法通过Pod的IP地址或者Service的虚拟IP地址：虚拟端口号进行访问。通常可以通过以下方式进行访问Kubernetes集群内的服务：</p>
<ul>
<li>映射Pod到物理机：将Pod端口号映射到宿主机，即在Pod中采用hostPort方式，以使客户端应用能够通过物理机访问容器应用。</li>
<li>映射Service到物理机：将Service端口号映射到宿主机，即在Service中采用nodePort方式，以使客户端应用能够通过物理机访问容器应用。</li>
<li>映射Sercie到LoadBalancer：通过设置LoadBalancer映射到云服务商提供的LoadBalancer地址。这种用法仅用于在公有云服务提供商的云平台上设置Service的场景。</li>
</ul>
<h3 id="34、简述Kubernetes-ingress"><a href="#34、简述Kubernetes-ingress" class="headerlink" title="34、简述Kubernetes ingress"></a><strong>34、简述Kubernetes ingress</strong></h3><p>Kubernetes的Ingress资源对象，用于将不同URL的访问请求转发到后端不同的Service，以实现HTTP层的业务路由机制。</p>
<p>Kubernetes使用了Ingress策略和Ingress Controller，两者结合并实现了一个完整的Ingress负载均衡器。使用Ingress进行负载分发时，Ingress Controller基于Ingress规则将客户端请求直接转发到Service对应的后端Endpoint（Pod）上，从而跳过kube-proxy的转发功能，kube-proxy不再起作用，全过程为：ingress controller + ingress 规则 —-&gt; services。</p>
<p>同时当Ingress Controller提供的是对外服务，则实际上实现的是边缘路由器的功能。</p>
<h3 id="35、简述Kubernetes镜像的下载策略"><a href="#35、简述Kubernetes镜像的下载策略" class="headerlink" title="35、简述Kubernetes镜像的下载策略"></a><strong>35、简述Kubernetes镜像的下载策略</strong></h3><p>Kubernetes的镜像下载策略有三种：Always、Never、IFNotPresent。</p>
<ul>
<li>Always：镜像标签为latest时，总是从指定的仓库中获取镜像。</li>
<li>Never：禁止从仓库中下载镜像，也就是说只能使用本地镜像。</li>
<li>IfNotPresent：仅当本地没有对应镜像时，才从目标仓库中下载。默认的镜像下载策略是：当镜像标签是latest时，默认策略是Always；当镜像标签是自定义时（也就是标签不是latest），那么默认策略是IfNotPresent。</li>
</ul>
<h3 id="36、简述Kubernetes的负载均衡器"><a href="#36、简述Kubernetes的负载均衡器" class="headerlink" title="36、简述Kubernetes的负载均衡器"></a><strong>36、简述Kubernetes的负载均衡器</strong></h3><p>负载均衡器是暴露服务的最常见和标准方式之一。</p>
<p>根据工作环境使用两种类型的负载均衡器，即内部负载均衡器或外部负载均衡器。内部负载均衡器自动平衡负载并使用所需配置分配容器，而外部负载均衡器将流量从外部负载引导至后端容器。</p>
<h3 id="37、简述Kubernetes各模块如何与API-Server通信"><a href="#37、简述Kubernetes各模块如何与API-Server通信" class="headerlink" title="37、简述Kubernetes各模块如何与API Server通信"></a><strong>37、简述Kubernetes各模块如何与API Server通信</strong></h3><p>Kubernetes API Server作为集群的核心，负责集群各功能模块之间的通信。集群内的各个功能模块通过API Server将信息存入etcd，当需要获取和操作这些数据时，则通过API Server提供的REST接口（用GET、LIST或WATCH方法）来实现，从而实现各模块之间的信息交互。</p>
<p>如kubelet进程与API Server的交互：每个Node上的kubelet每隔一个时间周期，就会调用一次API Server的REST接口报告自身状态，API Server在接收到这些信息后，会将节点状态信息更新到etcd中。</p>
<p>如kube-controller-manager进程与API Server的交互：kube-controller-manager中的Node Controller模块通过API Server提供的Watch接口实时监控Node的信息，并做相应处理。</p>
<p>如kube-scheduler进程与API Server的交互：Scheduler通过API Server的Watch接口监听到新建Pod副本的信息后，会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑，在调度成功后将Pod绑定到目标节点上。</p>
<h3 id="38、简述Kubernetes-Scheduler作用及实现原理"><a href="#38、简述Kubernetes-Scheduler作用及实现原理" class="headerlink" title="38、简述Kubernetes Scheduler作用及实现原理"></a><strong>38、简述Kubernetes Scheduler作用及实现原理</strong></h3><p>Kubernetes Scheduler是负责Pod调度的重要功能模块，Kubernetes Scheduler在整个系统中承担了“承上启下”的重要功能，“承上”是指它负责接收Controller Manager创建的新Pod，为其调度至目标Node；“启下”是指调度完成后，目标Node上的kubelet服务进程接管后继工作，负责Pod接下来生命周期。</p>
<p>Kubernetes Scheduler的作用是将待调度的Pod（API新创建的Pod、Controller Manager为补足副本而创建的Pod等）按照特定的调度算法和调度策略绑定（Binding）到集群中某个合适的Node上，并将绑定信息写入etcd中。</p>
<p>在整个调度过程中涉及三个对象，分别是待调度Pod列表、可用Node列表，以及调度算法和策略。</p>
<p>Kubernetes Scheduler通过调度算法调度为待调度Pod列表中的每个Pod从Node列表中选择一个最适合的Node来实现Pod的调度。随后，目标节点上的kubelet通过API Server监听到Kubernetes Scheduler产生的Pod绑定事件，然后获取对应的Pod清单，下载Image镜像并启动容器。</p>
<h3 id="39、简述Kubernetes-Scheduler使用哪两种算法将Pod绑定到worker节点"><a href="#39、简述Kubernetes-Scheduler使用哪两种算法将Pod绑定到worker节点" class="headerlink" title="39、简述Kubernetes Scheduler使用哪两种算法将Pod绑定到worker节点"></a><strong>39、简述Kubernetes Scheduler使用哪两种算法将Pod绑定到worker节点</strong></h3><p>Kubernetes Scheduler根据如下两种调度算法将 Pod 绑定到最合适的工作节点：</p>
<ul>
<li>预选（Predicates）：输入是所有节点，输出是满足预选条件的节点。kube-scheduler根据预选策略过滤掉不满足策略的Nodes。如果某节点的资源不足或者不满足预选策略的条件则无法通过预选。如“Node的label必须与Pod的Selector一致”。</li>
<li>优选（Priorities）：输入是预选阶段筛选出的节点，优选会根据优先策略为通过预选的Nodes进行打分排名，选择得分最高的Node。例如，资源越富裕、负载越小的Node可能具有越高的排名。</li>
</ul>
<h3 id="40、简述Kubernetes-kubelet的作用"><a href="#40、简述Kubernetes-kubelet的作用" class="headerlink" title="40、简述Kubernetes kubelet的作用"></a><strong>40、简述Kubernetes kubelet的作用</strong></h3><p>在Kubernetes集群中，在每个Node（又称Worker）上都会启动一个kubelet服务进程。该进程用于处理Master下发到本节点的任务，管理Pod及Pod中的容器。每个kubelet进程都会在API Server上注册节点自身的信息，定期向Master汇报节点资源的使用情况，并通过cAdvisor监控容器和节点资源。</p>
<h3 id="41、简述Kubernetes-kubelet监控Worker节点资源是使用什么组件来实现的"><a href="#41、简述Kubernetes-kubelet监控Worker节点资源是使用什么组件来实现的" class="headerlink" title="41、简述Kubernetes kubelet监控Worker节点资源是使用什么组件来实现的"></a><strong>41、简述Kubernetes kubelet监控Worker节点资源是使用什么组件来实现的</strong></h3><p>kubelet使用cAdvisor对worker节点资源进行监控。在Kubernetes系统中，cAdvisor已被默认集成到kubelet组件内，当kubelet服务启动时，它会自动启动cAdvisor服务，然后cAdvisor会实时采集所在节点的性能指标及在节点上运行的容器的性能指标。</p>
<h3 id="42、简述Kubernetes如何保证集群的安全性"><a href="#42、简述Kubernetes如何保证集群的安全性" class="headerlink" title="42、简述Kubernetes如何保证集群的安全性"></a><strong>42、简述Kubernetes如何保证集群的安全性</strong></h3><p>Kubernetes通过一系列机制来实现集群的安全控制，主要有如下不同的维度：</p>
<ul>
<li><p>基础设施方面：保证容器与其所在宿主机的隔离；</p>
</li>
<li><p>权限方面：</p>
</li>
<li><ul>
<li>最小权限原则：合理限制所有组件的权限，确保组件只执行它被授权的行为，通过限制单个组件的能力来限制它的权限范围。</li>
<li>用户权限：划分普通用户和管理员的角色。</li>
</ul>
</li>
</ul>
<ul>
<li><p>集群方面：</p>
</li>
<li><ul>
<li>API Server的认证授权：Kubernetes集群中所有资源的访问和变更都是通过Kubernetes API Server来实现的，因此需要建议采用更安全的HTTPS或Token来识别和认证客户端身份（Authentication），以及随后访问权限的授权（Authorization）环节。</li>
<li>API Server的授权管理：通过授权策略来决定一个API调用是否合法。对合法用户进行授权并且随后在用户访问时进行鉴权，建议采用更安全的RBAC方式来提升集群安全授权。</li>
</ul>
</li>
</ul>
<ul>
<li>敏感数据引入Secret机制：对于集群敏感数据建议使用Secret方式进行保护。</li>
<li>AdmissionControl（准入机制）：对kubernetes api的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。</li>
</ul>
<h3 id="43、简述Kubernetes准入机制"><a href="#43、简述Kubernetes准入机制" class="headerlink" title="43、简述Kubernetes准入机制"></a><strong>43、简述Kubernetes准入机制</strong></h3><p>在对集群进行请求时，每个准入控制代码都按照一定顺序执行。如果有一个准入控制拒绝了此次请求，那么整个请求的结果将会立即返回，并提示用户相应的error信息。</p>
<p>准入控制（AdmissionControl）准入控制本质上为一段准入代码，在对kubernetes api的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。常用组件（控制代码）如下：</p>
<ul>
<li>AlwaysAdmit：允许所有请求</li>
<li>AlwaysDeny：禁止所有请求，多用于测试环境。</li>
<li>ServiceAccount：它将serviceAccounts实现了自动化，它会辅助serviceAccount做一些事情，比如如果pod没有serviceAccount属性，它会自动添加一个default，并确保pod的serviceAccount始终存在。</li>
<li>LimitRanger：观察所有的请求，确保没有违反已经定义好的约束条件，这些条件定义在namespace中LimitRange对象中。</li>
<li>NamespaceExists：观察所有的请求，如果请求尝试创建一个不存在的namespace，则这个请求被拒绝。</li>
</ul>
<h3 id="44、简述Kubernetes-RBAC及其特点（优势）"><a href="#44、简述Kubernetes-RBAC及其特点（优势）" class="headerlink" title="44、简述Kubernetes RBAC及其特点（优势）"></a><strong>44、简述Kubernetes RBAC及其特点（优势）</strong></h3><p>RBAC是基于角色的访问控制，是一种基于个人用户的角色来管理对计算机或网络资源的访问的方法。</p>
<p>相对于其他授权模式，RBAC具有如下优势：</p>
<ul>
<li>对集群中的资源和非资源权限均有完整的覆盖。</li>
<li>整个RBAC完全由几个API对象完成， 同其他API对象一样， 可以用kubectl或API进行操作。</li>
<li>可以在运行时进行调整，无须重新启动API Server。</li>
</ul>
<h3 id="45、简述Kubernetes-Secret作用"><a href="#45、简述Kubernetes-Secret作用" class="headerlink" title="45、简述Kubernetes Secret作用"></a><strong>45、简述Kubernetes Secret作用</strong></h3><p>Secret对象，主要作用是保管私密数据，比如密码、OAuth Tokens、SSH Keys等信息。将这些私密信息放在Secret对象中比直接放在Pod或Docker Image中更安全，也更便于使用和分发。</p>
<h3 id="46、简述Kubernetes-Secret有哪些使用方式"><a href="#46、简述Kubernetes-Secret有哪些使用方式" class="headerlink" title="46、简述Kubernetes Secret有哪些使用方式"></a><strong>46、简述Kubernetes Secret有哪些使用方式</strong></h3><p>创建完secret之后，可通过如下三种方式使用：</p>
<ul>
<li>在创建Pod时，通过为Pod指定Service Account来自动使用该Secret。</li>
<li>通过挂载该Secret到Pod来使用它。</li>
<li>在Docker镜像下载时使用，通过指定Pod的spc.ImagePullSecrets来引用它。</li>
</ul>
<h3 id="47、简述Kubernetes-PodSecurityPolicy机制"><a href="#47、简述Kubernetes-PodSecurityPolicy机制" class="headerlink" title="47、简述Kubernetes PodSecurityPolicy机制"></a><strong>47、简述Kubernetes PodSecurityPolicy机制</strong></h3><p>Kubernetes PodSecurityPolicy是为了更精细地控制Pod对资源的使用方式以及提升安全策略。在开启PodSecurityPolicy准入控制器后，Kubernetes默认不允许创建任何Pod，需要创建PodSecurityPolicy策略和相应的RBAC授权策略（Authorizing Policies），Pod才能创建成功。</p>
<h3 id="48、简述Kubernetes-PodSecurityPolicy机制能实现哪些安全策略"><a href="#48、简述Kubernetes-PodSecurityPolicy机制能实现哪些安全策略" class="headerlink" title="48、简述Kubernetes PodSecurityPolicy机制能实现哪些安全策略"></a><strong>48、简述Kubernetes PodSecurityPolicy机制能实现哪些安全策略</strong></h3><p>在PodSecurityPolicy对象中可以设置不同字段来控制Pod运行时的各种安全策略，常见的有：</p>
<ul>
<li>特权模式：privileged是否允许Pod以特权模式运行。</li>
<li>宿主机资源：控制Pod对宿主机资源的控制，如hostPID：是否允许Pod共享宿主机的进程空间。</li>
<li>用户和组：设置运行容器的用户ID（范围）或组（范围）。</li>
<li>提升权限：AllowPrivilegeEscalation：设置容器内的子进程是否可以提升权限，通常在设置非root用户（MustRunAsNonRoot）时进行设置。</li>
<li>SELinux：进行SELinux的相关配置。</li>
</ul>
<h3 id="49、简述Kubernetes网络模型"><a href="#49、简述Kubernetes网络模型" class="headerlink" title="49、简述Kubernetes网络模型"></a><strong>49、简述Kubernetes网络模型</strong></h3><p>Kubernetes网络模型中每个Pod都拥有一个独立的IP地址，并假定所有Pod都在一个可以直接连通的、扁平的网络空间中。所以不管它们是否运行在同一个Node（宿主机）中，都要求它们可以直接通过对方的IP进行访问。设计这个原则的原因是，用户不需要额外考虑如何建立Pod之间的连接，也不需要考虑如何将容器端口映射到主机端口等问题。</p>
<p>同时为每个Pod都设置一个IP地址的模型使得同一个Pod内的不同容器会共享同一个网络命名空间，也就是同一个Linux网络协议栈。这就意味着同一个Pod内的容器可以通过localhost来连接对方的端口。</p>
<p>在Kubernetes的集群里，IP是以Pod为单位进行分配的。一个Pod内部的所有容器共享一个网络堆栈（相当于一个网络命名空间，它们的IP地址、网络设备、配置等都是共享的）。</p>
<h3 id="50、简述Kubernetes-CNI模型"><a href="#50、简述Kubernetes-CNI模型" class="headerlink" title="50、简述Kubernetes CNI模型"></a><strong>50、简述Kubernetes CNI模型</strong></h3><p>CNI提供了一种应用容器的插件化网络解决方案，定义对容器网络进行操作和配置的规范，通过插件的形式对CNI接口进行实现。CNI仅关注在创建容器时分配网络资源，和在销毁容器时删除网络资源。在CNI模型中只涉及两个概念：容器和网络。</p>
<ul>
<li>容器（Container）：是拥有独立Linux网络命名空间的环境，例如使用Docker或rkt创建的容器。容器需要拥有自己的Linux网络命名空间，这是加入网络的必要条件。</li>
<li>网络（Network）：表示可以互连的一组实体，这些实体拥有各自独立、唯一的IP地址，可以是容器、物理机或者其他网络设备（比如路由器）等。</li>
</ul>
<p>对容器网络的设置和操作都通过插件（Plugin）进行具体实现，CNI插件包括两种类型：CNI Plugin和IPAM（IP Address Management）Plugin。CNI Plugin负责为容器配置网络资源，IPAM Plugin负责对容器的IP地址进行分配和管理。IPAM Plugin作为CNI Plugin的一部分，与CNI Plugin协同工作。</p>
<h3 id="51、简述Kubernetes网络策略"><a href="#51、简述Kubernetes网络策略" class="headerlink" title="51、简述Kubernetes网络策略"></a><strong>51、简述Kubernetes网络策略</strong></h3><p>为实现细粒度的容器间网络访问隔离策略，Kubernetes引入Network Policy。</p>
<p>Network Policy的主要功能是对Pod间的网络通信进行限制和准入控制，设置允许访问或禁止访问的客户端Pod列表。Network Policy定义网络策略，配合策略控制器（Policy Controller）进行策略的实现。</p>
<h3 id="52、简述Kubernetes网络策略原理"><a href="#52、简述Kubernetes网络策略原理" class="headerlink" title="52、简述Kubernetes网络策略原理"></a><strong>52、简述Kubernetes网络策略原理</strong></h3><p>Network Policy的工作原理主要为：policy controller需要实现一个API Listener，监听用户设置的Network Policy定义，并将网络访问规则通过各Node的Agent进行实际设置（Agent则需要通过CNI网络插件实现）。</p>
<h3 id="53、简述Kubernetes中flannel的作用"><a href="#53、简述Kubernetes中flannel的作用" class="headerlink" title="53、简述Kubernetes中flannel的作用"></a><strong>53、简述Kubernetes中flannel的作用</strong></h3><p>Flannel可以用于Kubernetes底层网络的实现，主要作用有：</p>
<ul>
<li>它能协助Kubernetes，给每一个Node上的Docker容器都分配互相不冲突的IP地址。</li>
<li>它能在这些IP地址之间建立一个覆盖网络（Overlay Network），通过这个覆盖网络，将数据包原封不动地传递到目标容器内。</li>
</ul>
<h3 id="54、简述Kubernetes-Calico网络组件实现原理"><a href="#54、简述Kubernetes-Calico网络组件实现原理" class="headerlink" title="54、简述Kubernetes Calico网络组件实现原理"></a><strong>54、简述Kubernetes Calico网络组件实现原理</strong></h3><p>Calico是一个基于BGP的纯三层的网络方案，与OpenStack、Kubernetes、AWS、GCE等云平台都能够良好地集成。</p>
<p>Calico在每个计算节点都利用Linux Kernel实现了一个高效的vRouter来负责数据转发。每个vRouter都通过BGP协议把在本节点上运行的容器的路由信息向整个Calico网络广播，并自动设置到达其他节点的路由转发规则。</p>
<p>Calico保证所有容器之间的数据流量都是通过IP路由的方式完成互联互通的。Calico节点组网时可以直接利用数据中心的网络结构（L2或者L3），不需要额外的NAT、隧道或者Overlay Network，没有额外的封包解包，能够节约CPU运算，提高网络效率。</p>
<h3 id="55、简述Kubernetes共享存储的作用"><a href="#55、简述Kubernetes共享存储的作用" class="headerlink" title="55、简述Kubernetes共享存储的作用"></a><strong>55、简述Kubernetes共享存储的作用</strong></h3><p>Kubernetes对于有状态的容器应用或者对数据需要持久化的应用，因此需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。因此需要使用共享存储。</p>
<h3 id="56、简述Kubernetes数据持久化的方式有哪些"><a href="#56、简述Kubernetes数据持久化的方式有哪些" class="headerlink" title="56、简述Kubernetes数据持久化的方式有哪些"></a><strong>56、简述Kubernetes数据持久化的方式有哪些</strong></h3><p>Kubernetes通过数据持久化来持久化保存重要数据，常见的方式有：</p>
<ul>
<li><p>EmptyDir（空目录）：没有指定要挂载宿主机上的某个目录，直接由Pod内保部映射到宿主机上。类似于docker中的manager volume。</p>
</li>
<li><p>场景：</p>
</li>
<li><ul>
<li>只需要临时将数据保存在磁盘上，比如在合并/排序算法中；</li>
<li>作为两个容器的共享存储。</li>
</ul>
</li>
</ul>
<ul>
<li><p>特性：</p>
</li>
<li><ul>
<li>同个pod里面的不同容器，共享同一个持久化目录，当pod节点删除时，volume的数据也会被删除。</li>
<li>emptyDir的数据持久化的生命周期和使用的pod一致，一般是作为临时存储使用。</li>
</ul>
</li>
</ul>
<ul>
<li>Hostpath：将宿主机上已存在的目录或文件挂载到容器内部。类似于docker中的bind mount挂载方式。</li>
<li>特性：增加了Pod与节点之间的耦合。</li>
</ul>
<p>PersistentVolume（简称PV）：如基于NFS服务的PV，也可以基于GFS的PV。它的作用是统一数据持久化目录，方便管理。</p>
<h3 id="57、简述Kubernetes-PV和PVC"><a href="#57、简述Kubernetes-PV和PVC" class="headerlink" title="57、简述Kubernetes PV和PVC"></a><strong>57、简述Kubernetes PV和PVC</strong></h3><p>PV是对底层网络共享存储的抽象，将共享存储定义为一种“资源”。</p>
<p>PVC则是用户对存储资源的一个“申请”。</p>
<h3 id="58、简述Kubernetes-PV生命周期内的阶段"><a href="#58、简述Kubernetes-PV生命周期内的阶段" class="headerlink" title="58、简述Kubernetes PV生命周期内的阶段"></a><strong>58、简述Kubernetes PV生命周期内的阶段</strong></h3><p>某个PV在生命周期中可能处于以下4个阶段（Phaes）之一。</p>
<ul>
<li>Available：可用状态，还未与某个PVC绑定。</li>
<li>Bound：已与某个PVC绑定。</li>
<li>Released：绑定的PVC已经删除，资源已释放，但没有被集群回收。</li>
<li>Failed：自动资源回收失败。</li>
</ul>
<h3 id="59、简述Kubernetes所支持的存储供应模式"><a href="#59、简述Kubernetes所支持的存储供应模式" class="headerlink" title="59、简述Kubernetes所支持的存储供应模式"></a><strong>59、简述Kubernetes所支持的存储供应模式</strong></h3><p>Kubernetes支持两种资源的存储供应模式：静态模式（Static）和动态模式（Dynamic）。</p>
<ul>
<li>静态模式：集群管理员手工创建许多PV，在定义PV时需要将后端存储的特性进行设置。</li>
<li>动态模式：集群管理员无须手工创建PV，而是通过StorageClass的设置对后端存储进行描述，标记为某种类型。此时要求PVC对存储的类型进行声明，系统将自动完成PV的创建及与PVC的绑定。</li>
</ul>
<h3 id="60、简述Kubernetes-CSI模型"><a href="#60、简述Kubernetes-CSI模型" class="headerlink" title="60、简述Kubernetes CSI模型"></a><strong>60、简述Kubernetes CSI模型</strong></h3><p>Kubernetes CSI是Kubernetes推出与容器对接的存储接口标准，存储提供方只需要基于标准接口进行存储插件的实现，就能使用Kubernetes的原生存储机制为容器提供存储服务。CSI使得存储提供方的代码能和Kubernetes代码彻底解耦，部署也与Kubernetes核心组件分离，显然，存储插件的开发由提供方自行维护，就能为Kubernetes用户提供更多的存储功能，也更加安全可靠。</p>
<p>CSI包括CSI Controller和CSI Node：</p>
<ul>
<li>CSI Controller的主要功能是提供存储服务视角对存储资源和存储卷进行管理和操作。</li>
<li>CSI Node的主要功能是对主机（Node）上的Volume进行管理和操作。</li>
</ul>
<h3 id="61、简述Kubernetes-Worker节点加入集群的过程"><a href="#61、简述Kubernetes-Worker节点加入集群的过程" class="headerlink" title="61、简述Kubernetes Worker节点加入集群的过程"></a><strong>61、简述Kubernetes Worker节点加入集群的过程</strong></h3><p>通常需要对Worker节点进行扩容，从而将应用系统进行水平扩展。主要过程如下：</p>
<ul>
<li>在该Node上安装Docker、kubelet和kube-proxy服务；</li>
<li>然后配置kubelet和kubeproxy的启动参数，将Master URL指定为当前Kubernetes集群Master的地址，最后启动这些服务；</li>
<li>通过kubelet默认的自动注册机制，新的Worker将会自动加入现有的Kubernetes集群中；</li>
<li>Kubernetes Master在接受了新Worker的注册之后，会自动将其纳入当前集群的调度范围。</li>
</ul>
<h3 id="62、简述Kubernetes-Pod如何实现对节点的资源控制"><a href="#62、简述Kubernetes-Pod如何实现对节点的资源控制" class="headerlink" title="62、简述Kubernetes Pod如何实现对节点的资源控制"></a><strong>62、简述Kubernetes Pod如何实现对节点的资源控制</strong></h3><p>Kubernetes集群里的节点提供的资源主要是计算资源，计算资源是可计量的能被申请、分配和使用的基础资源。当前Kubernetes集群中的计算资源主要包括CPU、GPU及Memory。CPU与Memory是被Pod使用的，因此在配置Pod时可以通过参数CPU Request及Memory Request为其中的每个容器指定所需使用的CPU与Memory量，Kubernetes会根据Request的值去查找有足够资源的Node来调度此Pod。</p>
<p>通常，一个程序所使用的CPU与Memory是一个动态的量，确切地说，是一个范围，跟它的负载密切相关：负载增加时，CPU和Memory的使用量也会增加。</p>
<h3 id="63、简述Kubernetes-Requests和Limits如何影响Pod的调度"><a href="#63、简述Kubernetes-Requests和Limits如何影响Pod的调度" class="headerlink" title="63、简述Kubernetes Requests和Limits如何影响Pod的调度"></a><strong>63、简述Kubernetes Requests和Limits如何影响Pod的调度</strong></h3><p>当一个Pod创建成功时，Kubernetes调度器（Scheduler）会为该Pod选择一个节点来执行。对于每种计算资源（CPU和Memory）而言，每个节点都有一个能用于运行Pod的最大容量值。调度器在调度时，首先要确保调度后该节点上所有Pod的CPU和内存的Requests总和，不超过该节点能提供给Pod使用的CPU和Memory的最大容量值。</p>
<h3 id="64、简述Kubernetes-Metric-Service"><a href="#64、简述Kubernetes-Metric-Service" class="headerlink" title="64、简述Kubernetes Metric Service"></a><strong>64、简述Kubernetes Metric Service</strong></h3><p>在Kubernetes从1.10版本后采用Metrics Server作为默认的性能数据采集和监控，主要用于提供核心指标（Core Metrics），包括Node、Pod的CPU和内存使用指标。</p>
<p>对其他自定义指标（Custom Metrics）的监控则由Prometheus等组件来完成。</p>
<h3 id="65、简述Kubernetes中，如何使用EFK实现日志的统一管理"><a href="#65、简述Kubernetes中，如何使用EFK实现日志的统一管理" class="headerlink" title="65、简述Kubernetes中，如何使用EFK实现日志的统一管理"></a><strong>65、简述Kubernetes中，如何使用EFK实现日志的统一管理</strong></h3><p>在Kubernetes集群环境中，通常一个完整的应用或服务涉及组件过多，建议对日志系统进行集中化管理，通常采用EFK实现。</p>
<p>EFK是 Elasticsearch、Fluentd 和 Kibana 的组合，其各组件功能如下：</p>
<ul>
<li>Elasticsearch：是一个<a href="https://www.zhihu.com/search?q=搜索引擎&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">搜索引擎</a>，负责存储日志并提供查询接口；</li>
<li>Fluentd：负责从 Kubernetes 搜集日志，每个Node节点上面的Fluentd监控并收集该节点上面的系统日志，并将处理过后的日志信息发送给Elasticsearch；</li>
<li>Kibana：提供了一个 Web GUI，用户可以浏览和搜索存储在 Elasticsearch 中的日志。</li>
</ul>
<p>通过在每台Node上部署一个以DaemonSet方式运行的Fluentd来收集每台Node上的日志。Fluentd将Docker日志目录/var/lib/docker/containers和/var/log目录挂载到Pod中，然后Pod会在Node节点的/var/log/pods目录中创建新的目录，可以区别不同的容器日志输出，该目录下有一个日志文件链接到/var/lib/docker/contianers目录下的容器日志输出。</p>
<h3 id="66、简述Kubernetes如何进行优雅的节点关机维护"><a href="#66、简述Kubernetes如何进行优雅的节点关机维护" class="headerlink" title="66、简述Kubernetes如何进行优雅的节点关机维护"></a><strong>66、简述Kubernetes如何进行优雅的节点关机维护</strong></h3><p>由于Kubernetes节点运行大量Pod，因此在进行关机维护之前，建议先使用kubectl drain将该节点的Pod进行驱逐，然后进行关机维护。</p>
<h3 id="67、简述Kubernetes集群联邦"><a href="#67、简述Kubernetes集群联邦" class="headerlink" title="67、简述Kubernetes集群联邦"></a><strong>67、简述Kubernetes集群联邦</strong></h3><p>Kubernetes集群联邦可以将多个Kubernetes集群作为一个集群进行管理。因此，可以在一个数据中心/云中创建多个Kubernetes集群，并使用集群联邦在一个地方控制/管理所有集群。</p>
<h3 id="68、简述Helm及其优势"><a href="#68、简述Helm及其优势" class="headerlink" title="68、简述Helm及其优势"></a><strong>68、简述Helm及其优势</strong></h3><p>Helm是Kubernetes的软件包管理工具。类似Ubuntu中使用的APT、CentOS中使用的yum 或者Python中的 pip 一样。</p>
<p>Helm能够将一组Kubernetes资源打包统一管理, 是查找、共享和使用为Kubernetes构建的软件的最佳方式。</p>
<p>Helm中通常每个包称为一个Chart，一个Chart是一个目录（一般情况下会将目录进行打包压缩，形成name-version.tgz格式的单一文件，方便传输和存储）。</p>
<p>在Kubernetes中部署一个可以使用的应用，需要涉及到很多的 Kubernetes 资源的共同协作。使用Helm则具有如下优势：</p>
<ul>
<li>统一管理、配置和更新这些分散的Kubernetes的应用资源文件；</li>
<li>分发和复用一套应用模板；</li>
<li>将应用的一系列资源当做一个软件包管理。</li>
<li>对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。</li>
</ul>
<p>对于使用者而言，使用Helm后不用需要编写复杂的应用部署文件，可以以简单的方式在Kubernetes上查找、安装、升级、回滚、卸载应用程序。</p>
<h3 id="69、k8s是什么？请说出你的了解？"><a href="#69、k8s是什么？请说出你的了解？" class="headerlink" title="69、k8s是什么？请说出你的了解？"></a><strong>69、k8s是什么？请说出你的了解？</strong></h3><p>答：Kubenetes是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</p>
<p>K8S是Google公司推出的，它来源于由Google公司内部使用了15年的Borg系统，集结了Borg的精华。</p>
<h3 id="70、K8s架构的组成是什么？"><a href="#70、K8s架构的组成是什么？" class="headerlink" title="70、K8s架构的组成是什么？"></a><strong>70、K8s架构的组成是什么？</strong></h3><p>答：和大多数分布式系统一样，K8S集群至少需要一个<a href="https://www.zhihu.com/search?q=主节点&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={" sourcetype"%3a"answer"%2c"sourceid"%3a2200949037}" target="_blank" rel="noopener">主节点</a>（Master）和多个计算节点（Node）。</p>
<ul>
<li>主节点主要用于暴露API，调度部署和节点的管理；</li>
<li>计算节点运行一个容器运行环境，一般是docker环境（类似docker环境的还有rkt），同时运行一个K8s的代理（kubelet）用于和master通信。计算节点也会运行一些额外的组件，像记录日志，节点监控，服务发现等等。计算节点是k8s集群中真正工作的节点。</li>
</ul>
<h3 id="K8S架构细分："><a href="#K8S架构细分：" class="headerlink" title="K8S架构细分："></a><strong>K8S架构细分：</strong></h3><p>1、Master节点（默认不参加实际工作）：</p>
<ul>
<li>Kubectl：客户端命令行工具，作为整个K8s集群的操作入口；</li>
<li>Api Server：在K8s架构中承担的是“桥梁”的角色，作为资源操作的唯一入口，它提供了认证、授权、访问控制、API注册和发现等机制。客户端与k8s群集及K8s内部组件的通信，都要通过Api Server这个组件；</li>
<li>Controller-manager：负责维护群集的状态，比如故障检测、自动扩展、滚动更新等；</li>
<li>Scheduler：负责资源的调度，按照预定的调度策略将pod调度到相应的node节点上；</li>
<li>Etcd：担任数据中心的角色，保存了整个群集的状态；</li>
</ul>
<p>2、Node节点：</p>
<ul>
<li>Kubelet：负责维护容器的生命周期，同时也负责Volume和网络的管理，一般运行在所有的节点，是Node节点的代理，当Scheduler确定某个node上运行pod之后，会将pod的具体信息（image，volume）等发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向master返回运行状态。（自动修复功能：如果某个节点中的容器宕机，它会尝试重启该容器，若重启无效，则会将该pod杀死，然后重新创建一个容器）；</li>
<li>Kube-proxy：Service在逻辑上代表了后端的多个pod。负责为Service提供cluster内部的服务发现和负载均衡（外界通过Service访问pod提供的服务时，Service接收到的请求后就是通过kube-proxy来转发到pod上的）；</li>
<li>container-runtime：是负责管理运行容器的软件，比如docker</li>
<li>Pod：是k8s集群里面最小的单位。每个pod里边可以运行一个或多个container（容器），如果一个pod中有两个container，那么container的USR（用户）、MNT（挂载点）、PID（进程号）是相互隔离的，UTS（主机名和域名）、IPC（消息队列）、NET（网络栈）是相互共享的。我比较喜欢把pod来当做豌豆夹，而豌豆就是pod中的container；</li>
</ul>
<h3 id="71、容器和主机部署应用的区别是什么？"><a href="#71、容器和主机部署应用的区别是什么？" class="headerlink" title="71、容器和主机部署应用的区别是什么？"></a><strong>71、容器和主机部署应用的区别是什么？</strong></h3><p>答：容器的中心思想就是秒级启动；一次封装、到处运行；这是主机部署应用无法达到的效果，但同时也更应该注重容器的数据持久化问题。</p>
<p>另外，容器部署可以将各个服务进行隔离，互不影响，这也是容器的另一个核心概念。</p>
<h3 id="72、请你说一下kubenetes针对pod资源对象的健康监测机制？"><a href="#72、请你说一下kubenetes针对pod资源对象的健康监测机制？" class="headerlink" title="72、请你说一下kubenetes针对pod资源对象的健康监测机制？"></a><strong>72、请你说一下kubenetes针对pod资源对象的健康监测机制？</strong></h3><p>答：K8s中对于pod资源对象的健康状态检测，提供了三类probe（探针）来执行对pod的健康监测：</p>
<p>1） <code>livenessProbe</code>探针</p>
<p>可以根据用户自定义规则来判定pod是否健康，如果livenessProbe探针探测到容器不健康，则kubelet会根据其重启策略来决定是否重启，如果一个容器不包含livenessProbe探针，则kubelet会认为容器的livenessProbe探针的返回值永远成功。</p>
<p>2） <code>ReadinessProbe</code>探针</p>
<p>同样是可以根据用户自定义规则来判断pod是否健康，如果探测失败，控制器会将此pod从对应service的endpoint列表中移除，从此不再将任何请求调度到此Pod上，直到下次探测成功。</p>
<p>3） <code>startupProbe</code>探针</p>
<p>启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉，这个问题也可以换另一种方式解决，就是定义上面两类探针机制时，初始化时间定义的长一些即可。</p>
<p>每种探测方法能支持以下几个相同的检查参数，用于设置控制检查时间：</p>
<ul>
<li><code>initialDelaySeconds</code>：初始第一次探测间隔，用于应用启动的时间，防止应用还没启动而健康检查失败</li>
<li><code>periodSeconds</code>：检查间隔，多久执行probe检查，默认为10s；</li>
<li><code>timeoutSeconds</code>：检查超时时长，探测应用timeout后为失败；</li>
<li><code>successThreshold</code>：成功探测阈值，表示探测多少次为健康正常，默认探测1次。</li>
</ul>
<p>上面两种探针都支持以下三种探测方法：</p>
<p>1）Exec：通过执行命令的方式来检查服务是否正常，比如使用cat命令查看pod中的某个重要配置文件是否存在，若存在，则表示pod健康。反之异常。</p>
<p>Exec探测方式的yaml文件语法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">liveness</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">k8s.gcr.io/busybox</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/bin/sh</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">touch</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">30</span><span class="string">;</span> <span class="string">rm</span> <span class="bullet">-rf</span> <span class="string">/tmp/healthy;</span> <span class="string">sleep</span> <span class="number">600</span></span><br><span class="line"><span class="attr">    livenessProbe:</span>         <span class="comment">#选择livenessProbe的探测机制</span></span><br><span class="line"><span class="attr">      exec:</span>                      <span class="comment">#执行以下命令</span></span><br><span class="line"><span class="attr">        command:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">5</span>          <span class="comment">#在容器运行五秒后开始探测</span></span><br><span class="line"><span class="attr">      periodSeconds:</span> <span class="number">5</span>               <span class="comment">#每次探测的时间间隔为5秒</span></span><br></pre></td></tr></table></figure>

<p>在上面的配置文件中，探测机制为在容器运行5秒后，每隔五秒探测一次，如果cat命令返回的值为“0”，则表示健康，如果为非0，则表示异常。</p>
<p>2）Httpget：通过发送http/htps请求检查服务是否正常，返回的状态码为200-399则表示容器健康（注http get类似于命令<code>curl -I</code>）。</p>
<p>Httpget探测方式的yaml文件语法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">liveness</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">k8s.gcr.io/liveness</span></span><br><span class="line"><span class="attr">    livenessProbe:</span>              <span class="comment">#采用livenessProbe机制探测</span></span><br><span class="line"><span class="attr">      httpGet:</span>                  <span class="comment">#采用httpget的方式</span></span><br><span class="line"><span class="attr">    scheme:</span><span class="string">HTTP</span>         <span class="comment">#指定协议，也支持https</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/healthz</span>          <span class="comment">#检测是否可以访问到网页根目录下的healthz网页文件</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span>              <span class="comment">#监听端口是8080</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">3</span>     <span class="comment">#容器运行3秒后开始探测</span></span><br><span class="line"><span class="attr">      periodSeconds:</span> <span class="number">3</span>                <span class="comment">#探测频率为3秒</span></span><br></pre></td></tr></table></figure>

<p>上述配置文件中，探测方式为项容器发送HTTP GET请求，请求的是8080端口下的healthz文件，返回任何大于或等于200且小于400的状态码表示成功。任何其他代码表示异常。</p>
<p>3）tcpSocket：通过容器的IP和Port执行TCP检查，如果能够建立TCP连接，则表明容器健康，这种方式与HTTPget的探测机制有些类似，tcpsocket健康检查适用于TCP业务。</p>
<p>tcpSocket探测方式的yaml文件语法如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">goproxy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">k8s.gcr.io/goproxy:0.1</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">- containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="comment">#这里两种探测机制都用上了，都是为了和容器的8080端口建立TCP连接</span></span><br><span class="line"><span class="attr">    readinessProbe:</span></span><br><span class="line"><span class="attr">      tcpSocket:</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      tcpSocket:</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line"><span class="attr">      periodSeconds:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>在上述的yaml配置文件中，两类探针都使用了，在容器启动5秒后，kubelet将发送第一个readinessProbe探针，这将连接容器的8080端口，如果探测成功，则该pod为健康，十秒后，kubelet将进行第二次连接。</p>
<p>除了readinessProbe探针外，在容器启动15秒后，kubelet将发送第一个livenessProbe探针，仍然尝试连接容器的8080端口，如果连接失败，则重启容器。</p>
<p>探针探测的结果无外乎以下三者之一：</p>
<ul>
<li>Success：Container通过了检查；</li>
<li>Failure：Container没有通过检查；</li>
<li>Unknown：没有执行检查，因此不采取任何措施（通常是我们没有定义探针检测，默认为成功）。</li>
</ul>
<p>若觉得上面还不够透彻，可以移步其官网文档：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/</a></p>
<h3 id="73、如何控制滚动更新过程？"><a href="#73、如何控制滚动更新过程？" class="headerlink" title="73、如何控制滚动更新过程？"></a><strong>73、如何控制滚动更新过程？</strong></h3><p>答：可以通过下面的命令查看到更新时可以控制的参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master yaml]<span class="comment"># kubectl explain deploy.spec.strategy.rollingUpdate</span></span><br></pre></td></tr></table></figure>

<p><code>maxSurge</code>： 此参数控制滚动更新过程，副本总数超过预期pod数量的上限。可以是百分比，也可以是具体的值。默认为1。</p>
<p>（上述参数的作用就是在更新过程中，值若为3，那么不管三七二一，先运行三个pod，用于替换旧的pod，以此类推）</p>
<p><code>maxUnavailable</code>：此参数控制滚动更新过程中，不可用的Pod的数量。</p>
<p>（这个值和上面的值没有任何关系，举个例子：我有十个pod，但是在更新的过程中，我允许这十个pod中最多有三个不可用，那么就将这个参数的值设置为3，在更新的过程中，只要不可用的pod数量小于或等于3，那么更新过程就不会停止）。</p>
<h3 id="74、K8s中镜像的下载策略是什么？"><a href="#74、K8s中镜像的下载策略是什么？" class="headerlink" title="74、K8s中镜像的下载策略是什么？"></a><strong>74、K8s中镜像的下载策略是什么？</strong></h3><p>答：可通过命令“kubectl explain pod.spec.containers”来查看imagePullPolicy这行的解释。</p>
<p>K8s的镜像下载策略有三种：Always、Never、IFNotPresent；</p>
<ul>
<li>Always：镜像标签为latest时，总是从指定的仓库中获取镜像；</li>
<li>Never：禁止从仓库中下载镜像，也就是说只能使用本地镜像；</li>
<li>IfNotPresent：仅当本地没有对应镜像时，才从目标仓库中下载。</li>
<li>默认的镜像下载策略是：当镜像标签是latest时，默认策略是Always；当镜像标签是自定义时（也就是标签不是latest），那么默认策略是IfNotPresent。</li>
</ul>
<h3 id="75、image的状态有哪些？"><a href="#75、image的状态有哪些？" class="headerlink" title="75、image的状态有哪些？"></a><strong>75、image的状态有哪些？</strong></h3><ul>
<li>Running：Pod所需的容器已经被成功调度到某个节点，且已经成功运行，</li>
<li>Pending：APIserver创建了pod资源对象，并且已经存入etcd中，但它尚未被调度完成或者仍然处于仓库中下载镜像的过程</li>
<li>Unknown：APIserver无法正常获取到pod对象的状态，通常是其无法与所在工作节点的kubelet通信所致。</li>
</ul>
<h3 id="76、pod的重启策略是什么？"><a href="#76、pod的重启策略是什么？" class="headerlink" title="76、pod的重启策略是什么？"></a><strong>76、pod的重启策略是什么？</strong></h3><p>答：可以通过命令“kubectl explain pod.spec”查看pod的重启策略。（restartPolicy字段）</p>
<ul>
<li>Always：但凡pod对象终止就重启，此为默认策略。</li>
<li>OnFailure：仅在pod对象出现错误时才重启</li>
</ul>
<h3 id="77、Service这种资源对象的作用是什么？"><a href="#77、Service这种资源对象的作用是什么？" class="headerlink" title="77、Service这种资源对象的作用是什么？"></a><strong>77、Service这种资源对象的作用是什么？</strong></h3><p>答：用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。</p>
<h3 id="78、版本回滚相关的命令？"><a href="#78、版本回滚相关的命令？" class="headerlink" title="78、版本回滚相关的命令？"></a><strong>78、版本回滚相关的命令？</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master httpd-web]<span class="comment"># kubectl apply -f httpd2-deploy1.yaml  --record  </span></span><br><span class="line"><span class="comment">#运行yaml文件，并记录版本信息；</span></span><br><span class="line">[root@master httpd-web]<span class="comment"># kubectl rollout history deployment httpd-devploy1  </span></span><br><span class="line"><span class="comment">#查看该deployment的历史版本</span></span><br><span class="line">[root@master httpd-web]<span class="comment"># kubectl rollout undo deployment httpd-devploy1 --to-revision=1    </span></span><br><span class="line"><span class="comment">#执行回滚操作，指定回滚到版本1</span></span><br><span class="line"><span class="comment">#在yaml文件的spec字段中，可以写以下选项（用于限制最多记录多少个历史版本）：</span></span><br><span class="line">spec:</span><br><span class="line">  revisionHistoryLimit: 5            </span><br><span class="line"><span class="comment">#这个字段通过 kubectl explain deploy.spec  命令找到revisionHistoryLimit   &lt;integer&gt;行获得</span></span><br></pre></td></tr></table></figure>

<h3 id="79、标签与标签选择器的作用是什么？"><a href="#79、标签与标签选择器的作用是什么？" class="headerlink" title="79、标签与标签选择器的作用是什么？"></a><strong>79、标签与标签选择器的作用是什么？</strong></h3><p>标签：是当相同类型的资源对象越来越多的时候，为了更好的管理，可以按照标签将其分为一个组，为的是提升资源对象的管理效率。</p>
<p>标签选择器：就是标签的查询过滤条件。目前API支持两种标签选择器：</p>
<ul>
<li>基于等值关系的，如：“=”、“”“==”、“！=”（注：“==”也是等于的意思，yaml文件中的matchLabels字段）；</li>
<li>基于集合的，如：in、notin、exists（yaml文件中的matchExpressions字段）；</li>
</ul>
<p>注：in:在这个集合中；notin：不在这个集合中；exists：要么全在（exists）这个集合中，要么都不在（notexists）；</p>
<p>使用标签选择器的操作逻辑：</p>
<ul>
<li>在使用基于集合的标签选择器同时指定多个选择器之间的逻辑关系为“与”操作（比如：- {key: name,operator: In,values: [zhangsan,lisi]} ，那么只要拥有这两个值的资源，都会被选中）；</li>
<li>使用空值的标签选择器，意味着每个资源对象都被选中（如：标签选择器的键是“A”，两个资源对象同时拥有A这个键，但是值不一样，这种情况下，如果使用空值的标签选择器，那么将同时选中这两个资源对象）</li>
<li>空的标签选择器（注意不是上面说的空值，而是空的，都没有定义键的名称），将无法选择出任何资源；</li>
</ul>
<p>在基于集合的选择器中，使用“In”或者“Notin”操作时，其values可以为空，但是如果为空，这个标签选择器，就没有任何意义了。</p>
<p>两种标签选择器类型（基于等值、基于集合的书写方法）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">  matchLabels:</span>           <span class="comment">#基于等值</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  matchExpressions:</span>         <span class="comment">#基于集合</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;key:</span> <span class="string">name,operator:</span> <span class="string">In,values:</span> <span class="string">[zhangsan,lisi]&#125;</span>     <span class="comment">#key、operator、values这三个字段是固定的</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&#123;key:</span> <span class="string">age,operator:</span> <span class="string">Exists,values:&#125;</span>   <span class="comment">#如果指定为exists，那么values的值一定要为空</span></span><br></pre></td></tr></table></figure>

<h3 id="80、常用的标签分类有哪些？"><a href="#80、常用的标签分类有哪些？" class="headerlink" title="80、常用的标签分类有哪些？"></a><strong>80、常用的标签分类有哪些？</strong></h3><p>标签分类是可以自定义的，但是为了能使他人可以达到一目了然的效果，一般会使用以下一些分类：</p>
<ul>
<li>版本类标签（release）：stable（稳定版）、canary（金丝雀版本，可以将其称之为测试版中的测试版）、beta（测试版）；</li>
<li>环境类标签（environment）：dev（开发）、qa（测试）、production（生产）、op（运维）；</li>
<li>应用类（app）：ui、as、pc、sc；</li>
<li>架构类（tier）：frontend（前端）、backend（后端）、cache（缓存）；</li>
<li>分区标签（partition）：customerA（客户A）、customerB（客户B）；</li>
<li>品控级别（Track）：daily（每天）、weekly（每周）。</li>
</ul>
<h3 id="81、有几种查看标签的方式？"><a href="#81、有几种查看标签的方式？" class="headerlink" title="81、有几种查看标签的方式？"></a><strong>81、有几种查看标签的方式？</strong></h3><p>答：常用的有以下三种查看方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl get pod --show-labels    #查看pod，并且显示标签内容</span></span><br><span class="line">[root@master ~]<span class="comment"># kubectl get pod -L env,tier      #显示资源对象标签的值</span></span><br><span class="line">[root@master ~]<span class="comment"># kubectl get pod -l env,tier      #只显示符合键值资源对象的pod，而“-L”是显示所有的pod</span></span><br></pre></td></tr></table></figure>

<h3 id="82、添加、修改、删除标签的命令？"><a href="#82、添加、修改、删除标签的命令？" class="headerlink" title="82、添加、修改、删除标签的命令？"></a><strong>82、添加、修改、删除标签的命令？</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对pod标签的操作</span></span><br><span class="line">[root@master ~]<span class="comment"># kubectl label pod label-pod abc=123     #给名为label-pod的pod添加标签</span></span><br><span class="line">[root@master ~]<span class="comment"># kubectl label pod label-pod abc=456 --overwrite       #修改名为label-pod的标签</span></span><br><span class="line">[root@master ~]<span class="comment"># kubectl label pod label-pod abc-             #删除名为label-pod的标签</span></span><br><span class="line">[root@master ~]<span class="comment"># kubectl get pod --show-labels</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#对node节点的标签操作   </span></span><br><span class="line">[root@master ~]<span class="comment"># kubectl label nodes node01 disk=ssd      #给节点node01添加disk标签</span></span><br><span class="line">[root@master ~]<span class="comment"># kubectl label nodes node01 disk=sss –overwrite    #修改节点node01的标签</span></span><br><span class="line">[root@master ~]<span class="comment"># kubectl label nodes node01 disk-         #删除节点node01的disk标签</span></span><br></pre></td></tr></table></figure>

<h3 id="83、DaemonSet资源对象的特性？"><a href="#83、DaemonSet资源对象的特性？" class="headerlink" title="83、DaemonSet资源对象的特性？"></a><strong>83、DaemonSet资源对象的特性？</strong></h3><p>DaemonSet这种资源对象会在每个k8s集群中的节点上运行，并且每个节点只能运行一个pod，这是它和deployment资源对象的最大也是唯一的区别。所以，在其yaml文件中，不支持定义replicas，除此之外，与Deployment、RS等资源对象的写法相同。</p>
<p>它的一般使用场景如下：</p>
<ul>
<li>在去做每个节点的日志收集工作；</li>
<li>监控每个节点的的运行状态；</li>
</ul>
<h3 id="84、说说你对Job这种资源对象的了解？"><a href="#84、说说你对Job这种资源对象的了解？" class="headerlink" title="84、说说你对Job这种资源对象的了解？"></a><strong>84、说说你对Job这种资源对象的了解？</strong></h3><p>答：Job与其他服务类容器不同，Job是一种工作类容器（一般用于做一次性任务）。使用常见不多，可以忽略这个问题。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提高Job执行效率的方法：</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  parallelism:</span> <span class="number">2</span>           <span class="comment">#一次运行2个</span></span><br><span class="line"><span class="attr">  completions:</span> <span class="number">8</span>           <span class="comment">#最多运行8个</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">metadata:</span></span><br></pre></td></tr></table></figure>

<h3 id="85、描述一下pod的生命周期有哪些状态？"><a href="#85、描述一下pod的生命周期有哪些状态？" class="headerlink" title="85、描述一下pod的生命周期有哪些状态？"></a><strong>85、描述一下pod的生命周期有哪些状态？</strong></h3><ul>
<li>Pending：表示pod已经被同意创建，正在等待kube-scheduler选择合适的节点创建，一般是在准备镜像；</li>
<li>Running：表示pod中所有的容器已经被创建，并且至少有一个容器正在运行或者是正在启动或者是正在重启；</li>
<li>Succeeded：表示所有容器已经成功终止，并且不会再启动；</li>
<li>Failed：表示pod中所有容器都是非0（不正常）状态退出；</li>
<li>Unknown：表示无法读取Pod状态，通常是kube-controller-manager无法与Pod通信。</li>
</ul>
<h3 id="86、创建一个pod的流程是什么？"><a href="#86、创建一个pod的流程是什么？" class="headerlink" title="86、创建一个pod的流程是什么？"></a><strong>86、创建一个pod的流程是什么？</strong></h3><ul>
<li>客户端提交Pod的配置信息（可以是yaml文件定义好的信息）到kube-apiserver；</li>
<li>Apiserver收到指令后，通知给controller-manager创建一个资源对象；</li>
<li>Controller-manager通过api-server将pod的配置信息存储到ETCD数据中心中；</li>
<li>Kube-scheduler检测到pod信息会开始调度预选，会先过滤掉不符合Pod资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行pod的节点，然后将pod的资源配置单发送到node节点上的kubelet组件上。</li>
<li>Kubelet根据scheduler发来的资源配置单运行pod，运行成功后，将pod的运行信息返回给scheduler，scheduler将返回的pod运行状况的信息存储到etcd数据中心。</li>
</ul>
<h3 id="87、删除一个Pod会发生什么事情？"><a href="#87、删除一个Pod会发生什么事情？" class="headerlink" title="87、删除一个Pod会发生什么事情？"></a><strong>87、删除一个Pod会发生什么事情？</strong></h3><p>答：Kube-apiserver会接受到用户的删除指令，默认有30秒时间等待优雅退出，超过30秒会被标记为死亡状态，此时Pod的状态Terminating，kubelet看到pod标记为Terminating就开始了关闭Pod的工作；</p>
<p>关闭流程如下：</p>
<ul>
<li>pod从service的endpoint列表中被移除；</li>
<li>如果该pod定义了一个停止前的钩子，其会在pod内部被调用，停止钩子一般定义了如何优雅的结束进程；</li>
<li>进程被发送TERM信号（kill -14）</li>
<li>当超过优雅退出的时间后，Pod中的所有进程都会被发送SIGKILL信号（kill -9）。</li>
</ul>
<h3 id="88、K8s的Service是什么？"><a href="#88、K8s的Service是什么？" class="headerlink" title="88、K8s的Service是什么？"></a><strong>88、K8s的Service是什么？</strong></h3><p>答：Pod每次重启或者重新部署，其IP地址都会产生变化，这使得pod间通信和pod与外部通信变得困难，这时候，就需要Service为pod提供一个固定的入口。</p>
<p>Service的Endpoint列表通常绑定了一组相同配置的pod，通过负载均衡的方式把外界请求分配到多个pod上</p>
<h3 id="89、k8s是怎么进行服务注册的？"><a href="#89、k8s是怎么进行服务注册的？" class="headerlink" title="89、k8s是怎么进行服务注册的？"></a><strong>89、k8s是怎么进行服务注册的？</strong></h3><p>答：Pod启动后会加载当前环境所有Service信息，以便不同Pod根据Service名进行通信。</p>
<h3 id="90、k8s集群外流量怎么访问Pod？"><a href="#90、k8s集群外流量怎么访问Pod？" class="headerlink" title="90、k8s集群外流量怎么访问Pod？"></a><strong>90、k8s集群外流量怎么访问Pod？</strong></h3><p>答：可以通过Service的NodePort方式访问，会在所有节点监听同一个端口，比如：30000，访问节点的流量会被重定向到对应的Service上面。</p>
<h3 id="91、k8s数据持久化的方式有哪些？"><a href="#91、k8s数据持久化的方式有哪些？" class="headerlink" title="91、k8s数据持久化的方式有哪些？"></a><strong>91、k8s数据持久化的方式有哪些？</strong></h3><p>答：</p>
<h3 id="1）EmptyDir（空目录）："><a href="#1）EmptyDir（空目录）：" class="headerlink" title="1）EmptyDir（空目录）："></a><strong>1）EmptyDir（空目录）：</strong></h3><p>没有指定要挂载宿主机上的某个目录，直接由Pod内保部映射到宿主机上。类似于docker中的manager volume。</p>
<p>主要使用场景：</p>
<ul>
<li>只需要临时将数据保存在磁盘上，比如在合并/排序算法中；</li>
<li>作为两个容器的共享存储，使得第一个内容管理的容器可以将生成的数据存入其中，同时由同一个webserver容器对外提供这些页面。</li>
</ul>
<p>emptyDir的特性：</p>
<p>同个pod里面的不同容器，共享同一个持久化目录，当pod节点删除时，volume的数据也会被删除。如果仅仅是容器被销毁，pod还在，则不会影响volume中的数据。</p>
<p>总结来说：emptyDir的数据持久化的生命周期和使用的pod一致。一般是作为临时存储使用。</p>
<h3 id="2）Hostpath："><a href="#2）Hostpath：" class="headerlink" title="2）Hostpath："></a><strong>2）Hostpath：</strong></h3><p>将宿主机上已存在的目录或文件挂载到容器内部。类似于docker中的bind mount挂载方式。</p>
<p>这种数据持久化方式，运用场景不多，因为它增加了pod与节点之间的耦合。</p>
<p>一般对于k8s集群本身的数据持久化和docker本身的数据持久化会使用这种方式，可以自行参考apiService的yaml文件，位于：/etc/kubernetes/main…目录下。</p>
<h3 id="3）PersistentVolume（简称PV）："><a href="#3）PersistentVolume（简称PV）：" class="headerlink" title="3）PersistentVolume（简称PV）："></a><strong>3）PersistentVolume（简称PV）：</strong></h3><p>基于NFS服务的PV，也可以基于GFS的PV。它的作用是统一数据持久化目录，方便管理。</p>
<p>在一个PV的yaml文件中，可以对其配置PV的大小，指定PV的访问模式：</p>
<ul>
<li><code>ReadWriteOnce</code>：只能以读写的方式挂载到单个节点；</li>
<li><code>ReadOnlyMany</code>：能以只读的方式挂载到多个节点；</li>
<li><code>ReadWriteMany</code>：能以读写的方式挂载到多个节点。以及指定pv的回收策略：</li>
<li><code>recycle</code>：清除PV的数据，然后自动回收；</li>
<li><code>Retain</code>：需要手动回收；</li>
<li><code>delete</code>：删除云存储资源，云存储专用；</li>
</ul>
<p>PS：这里的回收策略指的是在PV被删除后，在这个PV下所存储的源文件是否删除）。</p>
<p>若需使用PV，那么还有一个重要的概念：PVC，PVC是向PV申请应用所需的容量大小，K8s集群中可能会有多个PV，PVC和PV若要关联，其定义的访问模式必须一致。定义的storageClassName也必须一致，若群集中存在相同的（名字、访问模式都一致）两个PV，那么PVC会选择向它所需容量接近的PV去申请，或者随机申请。</p>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="Mysql性能优化"><a href="#Mysql性能优化" class="headerlink" title="Mysql性能优化"></a>Mysql性能优化</h2><p>优化思路：</p>
<ul>
<li>开启慢查询日志，查看哪些sql耗时长</li>
<li>查看执行慢的sql的执行计划（为优化提供方向）</li>
<li>优化查询sql（怎么优化）</li>
<li>使用【show profils】查看问题sql的使用情况（使用方法是啥）</li>
<li>调整操作系统参数优化（怎么调整）</li>
<li>升级服务硬件（什么条件下升级）</li>
</ul>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a><strong>慢查询日志</strong></h3><p><strong>1、MySQL的慢查询日志功能默认是关闭的，需要手动开启</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%slow_query%&apos;</span><br><span class="line">- 【slow_query_log】 ：是否开启慢查询日志，1为开启，0为关闭。</span><br><span class="line">- 【slow-query-log-file】：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置</span><br><span class="line">该参数，系统则会默认给一个缺省的文件host_name-slow.log</span><br><span class="line">show variables like &apos;long_query_time%&apos;</span><br><span class="line">- 【long_query_time】 ：慢查询阈值，当查询时间多于设定的阈值时，记录日志，【单位为秒】。</span><br></pre></td></tr></table></figure>

<p><strong>2、临时开启慢查询功能</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global slow_query_log = ON;</span><br><span class="line">set global long_query_time = 1;</span><br></pre></td></tr></table></figure>

<p><strong>3、永久开启慢查询功能</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#修改/etc/my.cnf配置文件，重启 MySQL, 这种永久生效.</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log=ON</span><br><span class="line">long_query_time=1</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-1c44ad58e68f9997dcb5c28d55ce1dbd_1440w.jpg" alt="img"></p>
<ul>
<li>第一行：SQL查询执行的具体时间</li>
<li>第二行：执行SQL查询的连接信息，用户和连接IP</li>
<li>第三行：记录了一些我们比较有用的信息</li>
</ul>
<ol>
<li>Query_time：这条SQL执行的时间，越长则越慢</li>
<li>Lock_time：在MySQL服务器阶段(不是在存储引擎阶段)等待表锁时间</li>
<li>Rows_sent：查询返回的行数</li>
<li>Rows_examined：查询检查的行数，越长就当然越费时间</li>
</ol>
<h3 id="分析慢查询日志的工具"><a href="#分析慢查询日志的工具" class="headerlink" title="分析慢查询日志的工具"></a>分析慢查询日志的工具</h3><p><strong>mysqldumpslow</strong>工具：是MySQL自带的慢查询日志工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/localhost-slow.log</span><br></pre></td></tr></table></figure>

<p>常用参数说明：</p>
<p>-s：是表示按照何种方式排序</p>
<ul>
<li>al 平均锁定时间</li>
<li>ar 平均返回记录时间</li>
<li>at 平均查询时间（默认）</li>
<li>c 计数</li>
<li>l 锁定时间</li>
<li>r 返回记录</li>
<li>t <strong>查询时间</strong></li>
</ul>
<p>-t：<strong>是top n的意思</strong>，即为返回前面多少条的数据</p>
<p>-g：后边可以写一个<strong>正则匹配模式</strong>，大小写不敏感的</p>
<h3 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create table tuser(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">	name varchar(100),</span><br><span class="line">	age int,</span><br><span class="line">	sex char(1),</span><br><span class="line">	address varchar(100)</span><br><span class="line">);</span><br><span class="line">alter table tuser add index idx_name_age(name(100),age);</span><br><span class="line">alter table tuser add index idx_sex(sex(1));</span><br><span class="line">insert into tuser(id,name,age,sex,address) values (1,&apos;张三&apos;,20,&apos;1&apos;,&apos;北京&apos;);</span><br><span class="line">insert into tuser(id,name,age,sex,address) values (2,&apos;李四&apos;,16,&apos;1&apos;,&apos;上海&apos;);</span><br><span class="line">insert into tuser(id,name,age,sex,address) values (3,&apos;王五&apos;,34,&apos;1&apos;,&apos;杭州&apos;);</span><br><span class="line">insert into tuser(id,name,age,sex,address) values (4,&apos;方六&apos;,26,&apos;2&apos;,&apos;广州&apos;);</span><br><span class="line">insert into tuser(id,name,age,sex,address) values (5,&apos;季七&apos;,18,&apos;2&apos;,&apos;上海&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">explain select * from tuser where id = 2</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/80/v2-9d44bdbdfd3e2d1ab5dab401796230da_1440w.png" alt="img"></p>
<ul>
<li>id: SELECT 查询的标识符. <strong>每个 SELECT 都会自动分配一个唯一的标识符</strong>.</li>
<li><strong>select_type: SELECT 查询的类型。（普通查询、联合查询(union、union all)、子查询等复杂查询）</strong></li>
<li>table: 查询的是<strong>哪个表</strong></li>
<li>partitions: 匹配的<strong>分区</strong></li>
<li>type: join 类型</li>
<li>possible_keys: 此次查询中<strong>可能选用的索引</strong></li>
<li>key: 此次查询中<strong>确切使用到的索引</strong>.</li>
<li>ref: 哪个字段或常数与 key 一起被使用</li>
<li>rows: 显示此查询<strong>一共扫描了多少行</strong>. 这个是一个估计值.</li>
<li>filtered: 表示此查询条件所<strong>过滤的数据的百分比</strong></li>
<li>extra: 额外的信息</li>
</ul>
<h3 id="select-type（重要）"><a href="#select-type（重要）" class="headerlink" title="select_type（重要）"></a>select_type（重要）</h3><p>1、simple</p>
<ul>
<li>不需要union操作或者不包含子查询的简单select查询</li>
</ul>
<p>2、primary</p>
<ul>
<li>个需要union操作或者含有子查询的select</li>
</ul>
<p>3、union</p>
<ul>
<li>union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union</li>
</ul>
<p>4、dependent union</p>
<ul>
<li>出现在union 或union all语句中，但是这个查询要受到外部查询的影响</li>
</ul>
<p>5、union result</p>
<ul>
<li>包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null</li>
</ul>
<p>6、subquery</p>
<ul>
<li>除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery</li>
</ul>
<p>7、dependent subquery</p>
<ul>
<li>表示这个subquery的查询要受到外部表查询的影响</li>
</ul>
<p>8、derived</p>
<ul>
<li>from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select</li>
</ul>
<h3 id="type（重要）"><a href="#type（重要）" class="headerlink" title="type（重要）"></a>type（重要）</h3><ul>
<li>system：表中只有一行数据或者是空表</li>
<li><strong>const：使用唯一索引或者主键</strong></li>
<li><strong>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。</strong></li>
<li><strong>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。</strong></li>
<li>fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</li>
<li>ref_or_null：与ref方法类似，只是增加了null值的比较。</li>
<li>unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值</li>
<li>index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</li>
<li><strong>range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。</strong></li>
<li>index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引</li>
<li><strong>index：select结果列中使用到了索引，type会显示为index。</strong></li>
<li><strong>ALL：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</strong></li>
</ul>
<h3 id="extra（重要）"><a href="#extra（重要）" class="headerlink" title="extra（重要）"></a><strong>extra（重要）</strong></h3><ul>
<li>Using filesort：说明mysql会对数据<strong>使用一个外部的索引排序</strong>，而不是按照表内的索引顺序进行读取。</li>
<li>Using temporary：MySQL在对查询结果排序时使用临时表。</li>
<li><strong>using index：查询时不需要回表查询，直接通过索引就可以获取查询的结果数据。（使用到了覆盖索引）</strong></li>
<li><strong>using where：Mysql将对storage engine提取的结果进行过滤，过滤条件字段无索引；</strong></li>
<li>Using join buffer：使用了连接缓存,比如说在查询的时候，多表join的次数非常多，那么将配置文件中的缓冲区的joinbuffer调大一些。</li>
<li>impossible where：where子句的值总是false ，不能用来获取任何元组（SELECT * FROM t_user WHERE id = ‘1’ and id = ‘2’）</li>
</ul>
<h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><ul>
<li>为<strong>搜索字段</strong>（where中的条件）、<strong>排序字段</strong>、<strong>select查询列</strong>，创建合适的索引，不过要考虑数据业务场景：<strong>查询多还是增删多</strong>？</li>
<li><strong>尽量建立组合索引</strong>并<strong>注意组合索引的创建顺序</strong>，按照顺序组织查询条件、尽量将筛选粒度大的查询条件放到最左边。</li>
<li><strong>尽量使用覆盖索引</strong>，SELECT语句中尽量不要使用*。</li>
<li><strong>索引长度尽量短</strong>，短索引可以节省索引空间，使查找的速度得到提升，同时内存中也可以装载更多的索引键值。<strong>太长的列，可以选择建立前缀索引</strong>。</li>
<li><strong>索引更新不能频繁</strong>，更新非常频繁的数据不适宜建索引，因为维护索引的成本。<br><strong>order by、group by语句要尽量使用到索引</strong></li>
<li><strong>order by的索引生效，order by排序应该遵循最左前缀查询</strong>，如果是使用多个索引字段进行排序，那么排序的规则必须相同（同是升序或者降序），否则索引同样会失效。</li>
</ul>
<h3 id="LIMIT优化"><a href="#LIMIT优化" class="headerlink" title="LIMIT优化"></a>LIMIT优化</h3><ul>
<li>如果预计SELECT语句的查询结果是一条，最好使用 LIMIT 1，可以停止全表扫描。</li>
<li>处理分页会使用到LIMIT ，当翻页到非常靠后的页面的时候，<strong>偏移量会非常大</strong>，这时<strong>LIMIT的效率会非常差</strong>。（单表分页时，使用自增主键排序之后，<strong>先使用where条件 id &gt; offset值</strong>，<strong>limit后面只写rows</strong>） （select * from (select * from tuser2 <strong>where id &gt; 1000000 and id &lt; 1000500 ORDER BY id</strong>) t <strong>limit 0, 20）</strong></li>
</ul>
<ol>
<li><strong>小表驱动大表，建议使用left join时，以小表关联大表（使用join的话，第一张表是必须全扫描的，以少关联多就可以减少这个扫描次数。）</strong></li>
<li><strong>避免全表扫描</strong></li>
<li><strong>避免mysql放弃索引查询</strong></li>
<li><strong>尽量不使用count(*)、尽量使用count（主键）</strong></li>
<li><strong>JOIN两张表的关联字段最好都建立索引</strong></li>
<li><strong>WHERE条件中尽量不要使用not in语句</strong></li>
<li><strong>合理利用慢查询日志、explain执行计划查询、show profile查看SQL执行时的资源使用情况</strong></li>
</ol>
<h3 id="profile分析语句"><a href="#profile分析语句" class="headerlink" title="profile分析语句"></a><strong>profile分析语句</strong></h3><ul>
<li>Query Profiler是<strong>MySQL自带</strong>的一种query诊断分析工具</li>
<li>通过它可以分析出一条SQL语句的<strong>硬件性能瓶颈</strong>在什么地方</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%profil%&apos;;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-91a75c8f444894425aab4dc1bcda3d27_1440w.jpg" alt="img"></p>
<p>profiling ： ON 表示开启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#开启profile功能</span><br><span class="line">set profiling=1; --1是开启、0是关闭</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>show profile: 展示最近一条语句执行的详细资源占用信息,默认显示 Status和Duration两列</strong></li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-7218789ff54d1e5173ebbccb1fca7b52_1440w.jpg" alt="img"></p>
<ul>
<li>show profile 还可<strong>根据 show profiles 列表中的 Query_ID</strong> ,选择显示某条记录的性能分析信息</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-e2b95d909d2c82d9320faef7a4e30484_1440w.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-5689efac56e639b1688abd2cb3b9bc9c_1440w.jpg" alt="img"></p>
<h3 id="服务器层面优化"><a href="#服务器层面优化" class="headerlink" title="服务器层面优化"></a>服务器层面优化</h3><p><strong>1、缓冲区优化</strong></p>
<ul>
<li>设置<strong>足够大的innodb_buffer_pool_size</strong> ，将数据读取到内存中</li>
<li>建议innodb_buffer_pool_size<strong>设置为总内存大小的3/4或者4/5</strong></li>
</ul>
<p><strong>2、降低磁盘写入次数</strong></p>
<ul>
<li><strong>生产环境，很多日志是不需要开启的，比如：通用查询日志、慢查询日志、错误日志</strong></li>
<li><strong>使用足够大的写入缓存 innodb_log_file_size（0.25 * innodb_buffer_pool_size）</strong></li>
</ul>
<p><strong>3、MySQL数据库配置优化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size #总内存大小的3/4或者4/5</span><br><span class="line">innodb_flush_log_at_trx_commit=1 #控制redo log刷新到磁盘的策略</span><br><span class="line">sync_binlog=1 #每提交1次事务同步写到磁盘中</span><br><span class="line">innodb_max_dirty_pages_pct=30 #脏页占innodb_buffer_pool_size的比例时，触发刷脏页到磁盘。 推荐值为25%~50%。</span><br><span class="line">innodb_io_capacity=200 #后台进程最大IO性能指标。默认200，如果SSD，调整为5000~20000</span><br><span class="line">innodb_data_file_path  #指定innodb共享表空间文件的大小</span><br><span class="line">ong_qurey_time=0.3 #慢查询日志的阈值设置，单位秒</span><br><span class="line">binlog_format=row #mysql复制的形式，row为MySQL8.0的默认形式。</span><br><span class="line">max_connections=200 #调高该参数则应降低interactive_timeout、wait_timeout的值</span><br><span class="line">innodb_log_file_size #过大，实例恢复时间长；过小，造成日志切换频繁。</span><br><span class="line">general_log=0 #全量日志建议关闭，默认关闭</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-a68f90cbe319f0cf041340ccc3b319cd_1440w.jpg" alt="img"></p>
<h3 id="操作系统优化"><a href="#操作系统优化" class="headerlink" title="操作系统优化"></a>操作系统优化</h3><p><strong>内核参数优化</strong></p>
<p><strong>CentOS系统针对mysql的参数优化，内核相关参数(/etc/sysctl.conf)，以下参数可以直接放到sysctl.conf文件的末尾。</strong></p>
<ul>
<li><strong>增加监听队列上限：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.core.somaxconn = 65535</span><br><span class="line">net.core.netdev_max_backlog = 65535</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 65535</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>加快TCP连接的回收：</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_fin_timeout = 10</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure>

<ul>
<li>TCP连接接收和发送缓冲区大小的默认值和最大值:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.core.wmem_default = 87380</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.core.rmem_default = 87380</span><br><span class="line">net.core.rmem_max = 16777216</span><br></pre></td></tr></table></figure>

<ul>
<li>减少失效连接所占用的TCP资源的数量，加快资源回收的效率：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time = 120</span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 30</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br></pre></td></tr></table></figure>

<ul>
<li>单个共享内存段的最大值：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel.shmmax = 4294967295</span><br><span class="line">#这个参数应该设置的足够大，以便能在一个共享内存段下容纳整个的Innodb缓冲池的大小。</span><br><span class="line">#这个值的大小对于64位linux系统，可取的最大值为(物理内存值-1)byte，建议值为大于物理</span><br><span class="line">内存的一半，一般取值大于Innodb缓冲池的大小即可。</span><br></pre></td></tr></table></figure>

<ul>
<li>控制换出运行时内存的相对权重</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness = 0</span><br><span class="line">#这个参数当内存不足时会对性能产生比较明显的影响</span><br><span class="line">#设置为0，表示Linux内核虚拟内存完全被占用，才会要使用交换区</span><br></pre></td></tr></table></figure>

<p><strong>增加资源限制</strong></p>
<ul>
<li><strong>打开文件数的限制(/etc/security/limit.conf)</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br><span class="line"></span><br><span class="line">*：表示对所有用户有效</span><br><span class="line">soft：表示当前系统生效的设置（soft不能大于hard ）</span><br><span class="line">hard：表明系统中所能设定的最大值</span><br><span class="line">nofile：表示所限制的资源是打开文件的最大数目</span><br><span class="line">65535：限制的数量</span><br></pre></td></tr></table></figure>

<ul>
<li>磁盘调度策略（选用deadline）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">查看调度策略的方法：</span><br><span class="line">cat /sys/block/devname/queue/scheduler</span><br><span class="line">修改调度策略的方法：</span><br><span class="line">echo &gt; /sys/block/devname/queue/scheduler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#该模式按进程创建多个队列，各个进程发来的IO请求会被cfq以轮循方式处理，对每个IO请求都是公平</span><br><span class="line">#的。该策略适合离散读的应用。</span><br><span class="line">cfq (完全公平队列策略，Linux2.6.18之后内核的系统默认策略)</span><br><span class="line"></span><br><span class="line">#deadline，包含读和写两个队列，确保在一个截止时间内服务请求（截止时间是可调整的），而默认读</span><br><span class="line">#期限短于写期限。这样就防止了写操作因为不能被读取而饿死的现象，deadline对数据库类应用是最好的选择。</span><br><span class="line">deadline (截止时间调度策略)</span><br><span class="line"></span><br><span class="line">#noop只实现一个简单的FIFO队列，倾向饿死读而利于写，因此noop对于闪存设备、RAM及嵌入式系统是最好的选择。</span><br><span class="line">noop (电梯式调度策略)</span><br><span class="line"></span><br><span class="line">#本质上与deadline策略一样，但在最后一次读操作之后，要等待6ms，才能继续进行对其它I/O请求进</span><br><span class="line">#行调度。它会在每个6ms中插入新的I/O操作，合并写入流，用写入延时换取最大的写入吞吐量。</span><br><span class="line">#anticipatory适合于写入较多的环境，比如文件服务器。该策略对数据库环境表现很差。</span><br><span class="line">anticipatory (预料I/O调度策略)</span><br></pre></td></tr></table></figure>

<h3 id="服务器硬件优化"><a href="#服务器硬件优化" class="headerlink" title="服务器硬件优化"></a>服务器硬件优化</h3><ul>
<li>尽量选择高频率的内存</li>
<li>提升网络带宽</li>
<li>使用SSD高速磁盘</li>
<li>提升CPU性能（对于数据库并发比较高的场景，CPU的数量比频率重要；对于CPU密集型场景和频繁执行复杂SQL的场景，CPU的频率越高越好）</li>
</ul>
<h1 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h1><p><a href="https://blog.csdn.net/weixin_38569499/article/details/86693916?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-5-86693916-blog-121605819.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-5-86693916-blog-121605819.pc_relevant_aa&utm_relevant_index=9" target="_blank" rel="noopener">知识点总结</a></p>
<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><h2 id="HTTP-状态码分类"><a href="#HTTP-状态码分类" class="headerlink" title="HTTP 状态码分类"></a>HTTP 状态码分类</h2><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：</p>
<table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<h2 id="HTTP状态码列表"><a href="#HTTP状态码列表" class="headerlink" title="HTTP状态码列表"></a>HTTP状态码列表</h2><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>

      
    </div>
    
    
    

    <div>
    
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>Linux运维常见问题</p>
  <p><span>文章作者:</span>尚先森</p>
  <p><span>发布时间:</span>2022年05月01日 - 21:42:58</p>
  <p><span>最后更新:</span>2022年09月28日 - 12:41:19</p>
  <p><span>原始链接:</span><a href="/2022/05/01/Linux运维常见问题/" title="Linux运维常见问题">https://imauu.gitee.io/2022/05/01/Linux运维常见问题/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://imauu.gitee.io/2022/05/01/Linux运维常见问题/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: '复制成功',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>

    
    </div>

    
        
        <div>
            <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/syz.png" alt="尚先森 wechat" style="width: 200px; max-width: 100%;">
    <div>有任何问题可以扫描上方二维码私聊我哦😊</div>
</div>

        </div>
    
    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持是我创作的最大动力^_^</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/weixin.png" alt="尚先森 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/zhifubao.png" alt="尚先森 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"><img src="/images/tag.png"> Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/04/20/HTML-基础篇/" rel="next" title="HTML-基础篇">
                <i class="fa fa-chevron-left"></i> HTML-基础篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/06/02/Golang学习笔记/" rel="prev" title="Golang学习笔记">
                Golang学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4nm4ry4apj205i05ia9y.jpg" alt="尚先森">
            
              <p class="site-author-name" itemprop="name">尚先森</p>
              <p class="site-description motion-element" itemprop="description">最后一刻，都不可以放弃希望！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/shang-code" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:syz15822409222@126.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://a4.qpic.cn/psb?/V10taC184UP7Xd/DBrT8JfiC4.Cbt9gOoLq3EMz6VxjKNILvuMgpLI*L80!/c/dJ8AAAAAAAAA&ek=1&kp=1&pt=0&bo=rgGuAa4BrgERFyA!&tl=1&vuin=1093999475&tm=1566439200&sce=60-2-2&rf=0-0" target="_blank" title="微信">
                      
                        <i class="fa fa-fw fa-globe"></i>微信</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://a4.qpic.cn/psb?/V10taC184UP7Xd/ZzGxvjixd59IA0smjXXNRNqr.iYN*upaiO01bWSzGWE!/c/dJ8AAAAAAAAA&ek=1&kp=1&pt=0&bo=HALkAhwC5AIRFyA!&tl=1&vuin=1093999475&tm=1566439200&sce=60-2-2&rf=0-0" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-globe"></i>QQ</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.runoob.com/" title="菜鸟教程" target="_blank">菜鸟教程</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.imooc.com/" title="慕课网" target="_blank">慕课网</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#查看系统相关信息"><span class="nav-number">1.</span> <span class="nav-text">查看系统相关信息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查看网卡流量"><span class="nav-number">1.1.</span> <span class="nav-text">查看网卡流量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#watch"><span class="nav-number">1.1.1.</span> <span class="nav-text">watch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dstat"><span class="nav-number">1.1.2.</span> <span class="nav-text">dstat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sysstat"><span class="nav-number">1.1.3.</span> <span class="nav-text">sysstat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cat直接查看"><span class="nav-number">1.1.4.</span> <span class="nav-text">cat直接查看</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看进程"><span class="nav-number">1.2.</span> <span class="nav-text">查看进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看进程已运行时间"><span class="nav-number">1.2.1.</span> <span class="nav-text">查看进程已运行时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程相关"><span class="nav-number">1.2.2.</span> <span class="nav-text">进程相关</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看Linux系统每个IP的连接数"><span class="nav-number">1.3.</span> <span class="nav-text">查看Linux系统每个IP的连接数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#awk数量统计"><span class="nav-number">1.4.</span> <span class="nav-text">awk数量统计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看inode信息"><span class="nav-number">1.5.</span> <span class="nav-text">查看inode信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能相关"><span class="nav-number">1.6.</span> <span class="nav-text">性能相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘IO检查"><span class="nav-number">1.7.</span> <span class="nav-text">磁盘IO检查</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#概念"><span class="nav-number">2.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程与线程"><span class="nav-number">2.1.</span> <span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-1"><span class="nav-number">2.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#区别"><span class="nav-number">2.1.2.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程和线程的关系"><span class="nav-number">2.1.3.</span> <span class="nav-text">进程和线程的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与线程的区别"><span class="nav-number">2.1.4.</span> <span class="nav-text">进程与线程的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软链接与硬链接的区别"><span class="nav-number">2.2.</span> <span class="nav-text">软链接与硬链接的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie与session的区别："><span class="nav-number">2.3.</span> <span class="nav-text">cookie与session的区别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CDN访问流程"><span class="nav-number">2.4.</span> <span class="nav-text">CDN访问流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程间如何通信"><span class="nav-number">2.5.</span> <span class="nav-text">进程间如何通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是rootkit"><span class="nav-number">2.6.</span> <span class="nav-text">什么是rootkit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是蜜罐"><span class="nav-number">2.7.</span> <span class="nav-text">什么是蜜罐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux中什么是Watchdog"><span class="nav-number">2.8.</span> <span class="nav-text">Linux中什么是Watchdog</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问一个网站的流程"><span class="nav-number">2.9.</span> <span class="nav-text">访问一个网站的流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三次握手，四次挥手"><span class="nav-number">2.10.</span> <span class="nav-text">三次握手，四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LVS相关"><span class="nav-number">2.11.</span> <span class="nav-text">LVS相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS-负载均衡有哪些策略"><span class="nav-number">2.11.1.</span> <span class="nav-text">LVS 负载均衡有哪些策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#谈谈你对LVS的理解"><span class="nav-number">2.11.2.</span> <span class="nav-text">谈谈你对LVS的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载均衡的原理是什么"><span class="nav-number">2.11.3.</span> <span class="nav-text">负载均衡的原理是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS由哪两部分组成的"><span class="nav-number">2.11.4.</span> <span class="nav-text">LVS由哪两部分组成的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS相关的术语"><span class="nav-number">2.11.5.</span> <span class="nav-text">LVS相关的术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS-NAT模式的原理"><span class="nav-number">2.11.6.</span> <span class="nav-text">LVS-NAT模式的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS-NAT模型的特性"><span class="nav-number">2.11.7.</span> <span class="nav-text">LVS-NAT模型的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS-DR模式原理"><span class="nav-number">2.11.8.</span> <span class="nav-text">LVS-DR模式原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS-DR模型的特性"><span class="nav-number">2.11.9.</span> <span class="nav-text">LVS-DR模型的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS三种负载均衡模式的比较"><span class="nav-number">2.11.10.</span> <span class="nav-text">LVS三种负载均衡模式的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS的负载调度算法"><span class="nav-number">2.11.11.</span> <span class="nav-text">LVS的负载调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LVS与nginx的区别"><span class="nav-number">2.11.12.</span> <span class="nav-text">LVS与nginx的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载均衡的作用有哪些"><span class="nav-number">2.11.13.</span> <span class="nav-text">负载均衡的作用有哪些</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx与Apache相关"><span class="nav-number">2.12.</span> <span class="nav-text">Nginx与Apache相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#nginx负载均衡实现的策略"><span class="nav-number">2.12.1.</span> <span class="nav-text">nginx负载均衡实现的策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nginx做负载均衡用到的模块"><span class="nav-number">2.12.2.</span> <span class="nav-text">nginx做负载均衡用到的模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载均衡有哪些实现方式"><span class="nav-number">2.12.3.</span> <span class="nav-text">负载均衡有哪些实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#web服务有哪些"><span class="nav-number">2.12.4.</span> <span class="nav-text">web服务有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要用nginx"><span class="nav-number">2.12.5.</span> <span class="nav-text">为什么要用nginx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nginx的性能为什么比apache高"><span class="nav-number">2.12.6.</span> <span class="nav-text">nginx的性能为什么比apache高</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nginx和apache的区别"><span class="nav-number">2.12.7.</span> <span class="nav-text">nginx和apache的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反向代理与正向代理以及区别"><span class="nav-number">2.12.8.</span> <span class="nav-text">反向代理与正向代理以及区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nginx如何处理http请求"><span class="nav-number">2.12.9.</span> <span class="nav-text">nginx如何处理http请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nginx虚拟主机有哪些"><span class="nav-number">2.12.10.</span> <span class="nav-text">nginx虚拟主机有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apache中的Worker和Prefork的区别"><span class="nav-number">2.12.11.</span> <span class="nav-text">apache中的Worker和Prefork的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nginx的优化"><span class="nav-number">2.12.12.</span> <span class="nav-text">nginx的优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nginx的session不同步怎么办"><span class="nav-number">2.12.13.</span> <span class="nav-text">nginx的session不同步怎么办</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tomcat相关"><span class="nav-number">2.13.</span> <span class="nav-text">Tomcat相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat作为web的优缺点"><span class="nav-number">2.13.1.</span> <span class="nav-text">Tomcat作为web的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tomcat的三个端口及作用"><span class="nav-number">2.13.2.</span> <span class="nav-text">tomcat的三个端口及作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat缺省端口是多少，怎么修改"><span class="nav-number">2.13.3.</span> <span class="nav-text">Tomcat缺省端口是多少，怎么修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat的工作模式是什么"><span class="nav-number">2.13.4.</span> <span class="nav-text">Tomcat的工作模式是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web请求在Tomcat请求中的请求流程"><span class="nav-number">2.13.5.</span> <span class="nav-text">Web请求在Tomcat请求中的请求流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat优化"><span class="nav-number">2.13.6.</span> <span class="nav-text">Tomcat优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fastcgi-和cgi的区别"><span class="nav-number">2.14.</span> <span class="nav-text">fastcgi 和cgi的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Keepalived相关"><span class="nav-number">2.15.</span> <span class="nav-text">Keepalived相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#keepalived-是什么"><span class="nav-number">2.15.1.</span> <span class="nav-text">keepalived 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何理解VRRP协议"><span class="nav-number">2.15.2.</span> <span class="nav-text">如何理解VRRP协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#keepalived的工作原理"><span class="nav-number">2.15.3.</span> <span class="nav-text">keepalived的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#出现脑裂的原因"><span class="nav-number">2.15.4.</span> <span class="nav-text">出现脑裂的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何解决keepalived脑裂问题"><span class="nav-number">2.15.5.</span> <span class="nav-text">如何解决keepalived脑裂问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux系统"><span class="nav-number">3.</span> <span class="nav-text">Linux系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常见日志文件与各自的用途"><span class="nav-number">3.1.</span> <span class="nav-text">常见日志文件与各自的用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux系统的运行级别"><span class="nav-number">3.2.</span> <span class="nav-text">Linux系统的运行级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux开机过程"><span class="nav-number">3.3.</span> <span class="nav-text">Linux开机过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络协议"><span class="nav-number">4.</span> <span class="nav-text">网络协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#STP协议"><span class="nav-number">4.1.</span> <span class="nav-text">STP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RIP协议"><span class="nav-number">4.2.</span> <span class="nav-text">RIP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OSPF协议"><span class="nav-number">4.3.</span> <span class="nav-text">OSPF协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kubernetes"><span class="nav-number">5.</span> <span class="nav-text">Kubernetes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常见面试题"><span class="nav-number">5.1.</span> <span class="nav-text">常见面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、简述etcd及其特点"><span class="nav-number">5.1.1.</span> <span class="nav-text">1、简述etcd及其特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、简述etcd适应的场景"><span class="nav-number">5.1.2.</span> <span class="nav-text">2、简述etcd适应的场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、简述什么是Kubernetes"><span class="nav-number">5.1.3.</span> <span class="nav-text">3、简述什么是Kubernetes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、简述Kubernetes和Docker的关系"><span class="nav-number">5.1.4.</span> <span class="nav-text">4、简述Kubernetes和Docker的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、简述Minikube、Kubectl、Kubelet分别是什么"><span class="nav-number">5.1.5.</span> <span class="nav-text">5、简述Minikube、Kubectl、Kubelet分别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、简述Kubernetes常见的部署方式"><span class="nav-number">5.1.6.</span> <span class="nav-text">6、简述Kubernetes常见的部署方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7、简述Kubernetes如何实现集群管理"><span class="nav-number">5.1.7.</span> <span class="nav-text">7、简述Kubernetes如何实现集群管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8、简述Kubernetes的优势、适应场景及其特点"><span class="nav-number">5.1.8.</span> <span class="nav-text">8、简述Kubernetes的优势、适应场景及其特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9、简述Kubernetes的缺点或当前的不足之处"><span class="nav-number">5.1.9.</span> <span class="nav-text">9、简述Kubernetes的缺点或当前的不足之处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10、简述Kubernetes相关基础概念"><span class="nav-number">5.1.10.</span> <span class="nav-text">10、简述Kubernetes相关基础概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11、简述Kubernetes集群相关组件"><span class="nav-number">5.1.11.</span> <span class="nav-text">11、简述Kubernetes集群相关组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12、简述Kubernetes-RC的机制"><span class="nav-number">5.1.12.</span> <span class="nav-text">12、简述Kubernetes RC的机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13、简述Kubernetes-Replica-Set和Replication-Controller之间有什么区别"><span class="nav-number">5.1.13.</span> <span class="nav-text">13、简述Kubernetes Replica Set和Replication Controller之间有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14、简述kube-proxy的作用"><span class="nav-number">5.1.14.</span> <span class="nav-text">14、简述kube-proxy的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15、简述kube-proxy-iptables的原理"><span class="nav-number">5.1.15.</span> <span class="nav-text">15、简述kube-proxy iptables的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16、简述kube-proxy-ipvs的原理"><span class="nav-number">5.1.16.</span> <span class="nav-text">16、简述kube-proxy ipvs的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17、简述kube-proxy-ipvs和iptables的异同"><span class="nav-number">5.1.17.</span> <span class="nav-text">17、简述kube-proxy ipvs和iptables的异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18、简述Kubernetes中什么是静态Pod"><span class="nav-number">5.1.18.</span> <span class="nav-text">18、简述Kubernetes中什么是静态Pod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19、简述Kubernetes中Pod可能位于的状态"><span class="nav-number">5.1.19.</span> <span class="nav-text">19、简述Kubernetes中Pod可能位于的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20、简述Kubernetes创建一个Pod的主要流程？"><span class="nav-number">5.1.20.</span> <span class="nav-text">20、简述Kubernetes创建一个Pod的主要流程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21、简述Kubernetes中Pod的重启策略"><span class="nav-number">5.1.21.</span> <span class="nav-text">21、简述Kubernetes中Pod的重启策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22、简述Kubernetes中Pod的健康检查方式"><span class="nav-number">5.1.22.</span> <span class="nav-text">22、简述Kubernetes中Pod的健康检查方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23、简述Kubernetes-Pod的LivenessProbe探针的常见方式"><span class="nav-number">5.1.23.</span> <span class="nav-text">23、简述Kubernetes Pod的LivenessProbe探针的常见方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24、简述Kubernetes-Pod的常见调度方式"><span class="nav-number">5.1.24.</span> <span class="nav-text">24、简述Kubernetes Pod的常见调度方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25、简述Kubernetes初始化容器（init-container）"><span class="nav-number">5.1.25.</span> <span class="nav-text">25、简述Kubernetes初始化容器（init container）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26、简述Kubernetes-deployment升级过程"><span class="nav-number">5.1.26.</span> <span class="nav-text">26、简述Kubernetes deployment升级过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27、简述Kubernetes-deployment升级策略"><span class="nav-number">5.1.27.</span> <span class="nav-text">27、简述Kubernetes deployment升级策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28、简述Kubernetes-DaemonSet类型的资源特性"><span class="nav-number">5.1.28.</span> <span class="nav-text">28、简述Kubernetes DaemonSet类型的资源特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29、简述Kubernetes自动扩容机制"><span class="nav-number">5.1.29.</span> <span class="nav-text">29、简述Kubernetes自动扩容机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30、简述Kubernetes-Service类型"><span class="nav-number">5.1.30.</span> <span class="nav-text">30、简述Kubernetes Service类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31、简述Kubernetes-Service分发后端的策略"><span class="nav-number">5.1.31.</span> <span class="nav-text">31、简述Kubernetes Service分发后端的策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32、简述Kubernetes-Headless-Service"><span class="nav-number">5.1.32.</span> <span class="nav-text">32、简述Kubernetes Headless Service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33、简述Kubernetes外部如何访问集群内的服务"><span class="nav-number">5.1.33.</span> <span class="nav-text">33、简述Kubernetes外部如何访问集群内的服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34、简述Kubernetes-ingress"><span class="nav-number">5.1.34.</span> <span class="nav-text">34、简述Kubernetes ingress</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35、简述Kubernetes镜像的下载策略"><span class="nav-number">5.1.35.</span> <span class="nav-text">35、简述Kubernetes镜像的下载策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36、简述Kubernetes的负载均衡器"><span class="nav-number">5.1.36.</span> <span class="nav-text">36、简述Kubernetes的负载均衡器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37、简述Kubernetes各模块如何与API-Server通信"><span class="nav-number">5.1.37.</span> <span class="nav-text">37、简述Kubernetes各模块如何与API Server通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38、简述Kubernetes-Scheduler作用及实现原理"><span class="nav-number">5.1.38.</span> <span class="nav-text">38、简述Kubernetes Scheduler作用及实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39、简述Kubernetes-Scheduler使用哪两种算法将Pod绑定到worker节点"><span class="nav-number">5.1.39.</span> <span class="nav-text">39、简述Kubernetes Scheduler使用哪两种算法将Pod绑定到worker节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40、简述Kubernetes-kubelet的作用"><span class="nav-number">5.1.40.</span> <span class="nav-text">40、简述Kubernetes kubelet的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41、简述Kubernetes-kubelet监控Worker节点资源是使用什么组件来实现的"><span class="nav-number">5.1.41.</span> <span class="nav-text">41、简述Kubernetes kubelet监控Worker节点资源是使用什么组件来实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42、简述Kubernetes如何保证集群的安全性"><span class="nav-number">5.1.42.</span> <span class="nav-text">42、简述Kubernetes如何保证集群的安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43、简述Kubernetes准入机制"><span class="nav-number">5.1.43.</span> <span class="nav-text">43、简述Kubernetes准入机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44、简述Kubernetes-RBAC及其特点（优势）"><span class="nav-number">5.1.44.</span> <span class="nav-text">44、简述Kubernetes RBAC及其特点（优势）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45、简述Kubernetes-Secret作用"><span class="nav-number">5.1.45.</span> <span class="nav-text">45、简述Kubernetes Secret作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46、简述Kubernetes-Secret有哪些使用方式"><span class="nav-number">5.1.46.</span> <span class="nav-text">46、简述Kubernetes Secret有哪些使用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47、简述Kubernetes-PodSecurityPolicy机制"><span class="nav-number">5.1.47.</span> <span class="nav-text">47、简述Kubernetes PodSecurityPolicy机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48、简述Kubernetes-PodSecurityPolicy机制能实现哪些安全策略"><span class="nav-number">5.1.48.</span> <span class="nav-text">48、简述Kubernetes PodSecurityPolicy机制能实现哪些安全策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49、简述Kubernetes网络模型"><span class="nav-number">5.1.49.</span> <span class="nav-text">49、简述Kubernetes网络模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50、简述Kubernetes-CNI模型"><span class="nav-number">5.1.50.</span> <span class="nav-text">50、简述Kubernetes CNI模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51、简述Kubernetes网络策略"><span class="nav-number">5.1.51.</span> <span class="nav-text">51、简述Kubernetes网络策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52、简述Kubernetes网络策略原理"><span class="nav-number">5.1.52.</span> <span class="nav-text">52、简述Kubernetes网络策略原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53、简述Kubernetes中flannel的作用"><span class="nav-number">5.1.53.</span> <span class="nav-text">53、简述Kubernetes中flannel的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54、简述Kubernetes-Calico网络组件实现原理"><span class="nav-number">5.1.54.</span> <span class="nav-text">54、简述Kubernetes Calico网络组件实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55、简述Kubernetes共享存储的作用"><span class="nav-number">5.1.55.</span> <span class="nav-text">55、简述Kubernetes共享存储的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56、简述Kubernetes数据持久化的方式有哪些"><span class="nav-number">5.1.56.</span> <span class="nav-text">56、简述Kubernetes数据持久化的方式有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57、简述Kubernetes-PV和PVC"><span class="nav-number">5.1.57.</span> <span class="nav-text">57、简述Kubernetes PV和PVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58、简述Kubernetes-PV生命周期内的阶段"><span class="nav-number">5.1.58.</span> <span class="nav-text">58、简述Kubernetes PV生命周期内的阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59、简述Kubernetes所支持的存储供应模式"><span class="nav-number">5.1.59.</span> <span class="nav-text">59、简述Kubernetes所支持的存储供应模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60、简述Kubernetes-CSI模型"><span class="nav-number">5.1.60.</span> <span class="nav-text">60、简述Kubernetes CSI模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61、简述Kubernetes-Worker节点加入集群的过程"><span class="nav-number">5.1.61.</span> <span class="nav-text">61、简述Kubernetes Worker节点加入集群的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62、简述Kubernetes-Pod如何实现对节点的资源控制"><span class="nav-number">5.1.62.</span> <span class="nav-text">62、简述Kubernetes Pod如何实现对节点的资源控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63、简述Kubernetes-Requests和Limits如何影响Pod的调度"><span class="nav-number">5.1.63.</span> <span class="nav-text">63、简述Kubernetes Requests和Limits如何影响Pod的调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64、简述Kubernetes-Metric-Service"><span class="nav-number">5.1.64.</span> <span class="nav-text">64、简述Kubernetes Metric Service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#65、简述Kubernetes中，如何使用EFK实现日志的统一管理"><span class="nav-number">5.1.65.</span> <span class="nav-text">65、简述Kubernetes中，如何使用EFK实现日志的统一管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66、简述Kubernetes如何进行优雅的节点关机维护"><span class="nav-number">5.1.66.</span> <span class="nav-text">66、简述Kubernetes如何进行优雅的节点关机维护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#67、简述Kubernetes集群联邦"><span class="nav-number">5.1.67.</span> <span class="nav-text">67、简述Kubernetes集群联邦</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#68、简述Helm及其优势"><span class="nav-number">5.1.68.</span> <span class="nav-text">68、简述Helm及其优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69、k8s是什么？请说出你的了解？"><span class="nav-number">5.1.69.</span> <span class="nav-text">69、k8s是什么？请说出你的了解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70、K8s架构的组成是什么？"><span class="nav-number">5.1.70.</span> <span class="nav-text">70、K8s架构的组成是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#K8S架构细分："><span class="nav-number">5.1.71.</span> <span class="nav-text">K8S架构细分：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#71、容器和主机部署应用的区别是什么？"><span class="nav-number">5.1.72.</span> <span class="nav-text">71、容器和主机部署应用的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72、请你说一下kubenetes针对pod资源对象的健康监测机制？"><span class="nav-number">5.1.73.</span> <span class="nav-text">72、请你说一下kubenetes针对pod资源对象的健康监测机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73、如何控制滚动更新过程？"><span class="nav-number">5.1.74.</span> <span class="nav-text">73、如何控制滚动更新过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74、K8s中镜像的下载策略是什么？"><span class="nav-number">5.1.75.</span> <span class="nav-text">74、K8s中镜像的下载策略是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75、image的状态有哪些？"><span class="nav-number">5.1.76.</span> <span class="nav-text">75、image的状态有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76、pod的重启策略是什么？"><span class="nav-number">5.1.77.</span> <span class="nav-text">76、pod的重启策略是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77、Service这种资源对象的作用是什么？"><span class="nav-number">5.1.78.</span> <span class="nav-text">77、Service这种资源对象的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#78、版本回滚相关的命令？"><span class="nav-number">5.1.79.</span> <span class="nav-text">78、版本回滚相关的命令？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79、标签与标签选择器的作用是什么？"><span class="nav-number">5.1.80.</span> <span class="nav-text">79、标签与标签选择器的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#80、常用的标签分类有哪些？"><span class="nav-number">5.1.81.</span> <span class="nav-text">80、常用的标签分类有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#81、有几种查看标签的方式？"><span class="nav-number">5.1.82.</span> <span class="nav-text">81、有几种查看标签的方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#82、添加、修改、删除标签的命令？"><span class="nav-number">5.1.83.</span> <span class="nav-text">82、添加、修改、删除标签的命令？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#83、DaemonSet资源对象的特性？"><span class="nav-number">5.1.84.</span> <span class="nav-text">83、DaemonSet资源对象的特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#84、说说你对Job这种资源对象的了解？"><span class="nav-number">5.1.85.</span> <span class="nav-text">84、说说你对Job这种资源对象的了解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#85、描述一下pod的生命周期有哪些状态？"><span class="nav-number">5.1.86.</span> <span class="nav-text">85、描述一下pod的生命周期有哪些状态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86、创建一个pod的流程是什么？"><span class="nav-number">5.1.87.</span> <span class="nav-text">86、创建一个pod的流程是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#87、删除一个Pod会发生什么事情？"><span class="nav-number">5.1.88.</span> <span class="nav-text">87、删除一个Pod会发生什么事情？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#88、K8s的Service是什么？"><span class="nav-number">5.1.89.</span> <span class="nav-text">88、K8s的Service是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#89、k8s是怎么进行服务注册的？"><span class="nav-number">5.1.90.</span> <span class="nav-text">89、k8s是怎么进行服务注册的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90、k8s集群外流量怎么访问Pod？"><span class="nav-number">5.1.91.</span> <span class="nav-text">90、k8s集群外流量怎么访问Pod？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#91、k8s数据持久化的方式有哪些？"><span class="nav-number">5.1.92.</span> <span class="nav-text">91、k8s数据持久化的方式有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1）EmptyDir（空目录）："><span class="nav-number">5.1.93.</span> <span class="nav-text">1）EmptyDir（空目录）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）Hostpath："><span class="nav-number">5.1.94.</span> <span class="nav-text">2）Hostpath：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3）PersistentVolume（简称PV）："><span class="nav-number">5.1.95.</span> <span class="nav-text">3）PersistentVolume（简称PV）：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql"><span class="nav-number">6.</span> <span class="nav-text">Mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mysql性能优化"><span class="nav-number">6.1.</span> <span class="nav-text">Mysql性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#慢查询日志"><span class="nav-number">6.1.1.</span> <span class="nav-text">慢查询日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析慢查询日志的工具"><span class="nav-number">6.1.2.</span> <span class="nav-text">分析慢查询日志的工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看执行计划"><span class="nav-number">6.1.3.</span> <span class="nav-text">查看执行计划</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select-type（重要）"><span class="nav-number">6.1.4.</span> <span class="nav-text">select_type（重要）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type（重要）"><span class="nav-number">6.1.5.</span> <span class="nav-text">type（重要）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extra（重要）"><span class="nav-number">6.1.6.</span> <span class="nav-text">extra（重要）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL语句优化"><span class="nav-number">6.1.7.</span> <span class="nav-text">SQL语句优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LIMIT优化"><span class="nav-number">6.1.8.</span> <span class="nav-text">LIMIT优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#profile分析语句"><span class="nav-number">6.1.9.</span> <span class="nav-text">profile分析语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器层面优化"><span class="nav-number">6.1.10.</span> <span class="nav-text">服务器层面优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统优化"><span class="nav-number">6.1.11.</span> <span class="nav-text">操作系统优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器硬件优化"><span class="nav-number">6.1.12.</span> <span class="nav-text">服务器硬件优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Prometheus"><span class="nav-number">7.</span> <span class="nav-text">Prometheus</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP状态码"><span class="nav-number">8.</span> <span class="nav-text">HTTP状态码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-状态码分类"><span class="nav-number">8.1.</span> <span class="nav-text">HTTP 状态码分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP状态码列表"><span class="nav-number">8.2.</span> <span class="nav-text">HTTP状态码列表</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <img src="http://www.icosky.com/icon/48/Cartoon/Bleach%20Chibi%20Icons%20for%20mac/Bleach%20Chibi%20Nr%20%206%20Rukia%20by%20rukichen.png">
  </span>
  <span class="author" itemprop="copyrightHolder">尚先森</span>

  
</div>

<!-- 
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>
 -->



        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'hU7o1mDSLSyDeK4wE4hDgcIG-gzGzoHsz',
        appKey: 'SezjNE3ljsOzb5og8uQs51FR',
        placeholder: '回复时请填写个人邮箱和昵称，网址选填。',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  


  

  

  
  
<!-- 自定义的js文件 -->
<script type="text/javascript" src="/js/src/custom.js"></script>


<!-- 页面点击小红心，在末尾添加，避免找不到 -->
<script type="text/javascript" src="/js/src/love.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/kesyoban.model.json"},"display":{"superSample":2,"width":150,"height":200,"position":"left","hOffset":10,"vOffset":25},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>