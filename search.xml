<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Rsync+inotify实时备份]]></title>
    <url>%2F2022%2F09%2F07%2FRsync-inotify%E5%AE%9E%E6%97%B6%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[安装inotify123sudo apt install inotify -yinotifywait -hinotifywatch -h 安装rsync12345sudo apt install rsync# 因为是在自己本地做测试,做一个自己的登录免密ssh-keygenssh-copy-id -i 10.0.3.26 编写脚本实现同步1234567891011121314151617181920vim miner_dir_backup.sh#!/bin/bashdst_ip='10.0.3.26'src_dir='/home/caslx/disk_md0/lotusminer'dst_dir='/home/caslx/disk_md0/nfs_storage/backup/lotusminer'inotifywait -mrq --format '%w%f' -e modify,delete,create,attrib $&#123;src_dir&#125; \| while read filedo if [ ! -e $file ]; then ssh $&#123;dst_ip&#125; rm -rf $&#123;dst_dir&#125;/`basename $&#123;file&#125;` &amp;&gt;/dev/null else rsync -avz --progress $&#123;file&#125; caslx@$&#123;dst_ip&#125;:$&#123;dst_dir&#125;/`basename $&#123;file&#125;` &amp;&gt;/dev/null fidone# 后台运行nohup bash miner_dir_backup.sh &amp; zabbix监控实时备份状态 编写脚本判断是否实时同步，将状态写入到指定文件 1234567891011121314151617181920212223242526272829303132#!/bin/bash### 检查备份目录是否同步正常time=`date "+%Y-%m-%d %H:%M:%S"`src_dir='/home/caslx/disk_md0/lotusminer'dst_dir='/home/caslx/disk_md0/nfs_storage/backup/lotusminer'echo $&#123;time&#125; &gt;&gt; $&#123;src_dir&#125;/check.txtsleep 3# 判断校验文件是否存在if [ ! -f $&#123;dst_dir&#125;/check.txt ]then # 如果不存在输出0 echo 0else # 判断校验文件的内容是否同步过去 num=grep "$&#123;time&#125;" $&#123;dst_dir&#125;/check.txt | wc -l # 如果没有同步过去,输出0 if [ $&#123;num&#125; -eq 0 ] then echo 0 else # 同步过去输出1 echo 1 fifi 编辑zabbix-agent配置 1234567891011sudo vim /etc/zabbix/zabbix_agentd.conf# 判断目录实时同步状态UserParameter=miner_dir_sync_status,/usr/bin/bash /home/caslx/zabbix/scripts/zabbix_agent_run_scripts/check_miner_dir_backup.sh# 重启agent服务systemctl restart zabbix-agent### 赋予check.txt权限chmod 777 /home/caslx/disk_md0/lotusminer/check.txt]]></content>
      <categories>
        <category>数据备份</category>
        <category>Rsync+inotify</category>
      </categories>
      <tags>
        <tag>Rsync</tag>
        <tag>inotify</tag>
        <tag>数据备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grep的使用方法]]></title>
    <url>%2F2022%2F09%2F06%2Fgrep%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常用参数可选参数: -c 统计匹配行的个数 -i 忽略大小写匹配 -n 显示匹配行行号 -x 显示完全匹配的行 -v 取反 -A 匹配行的后多少行 -B 匹配行的前多少行 -E 扩展正则 基本使用 命令格式 1grep [可选参数] "[被过滤字符串]" [文件名称] -c 统计匹配行的个数 样例文本 123456789 ~/grep  cat a.txthellohellohelloworldworldworldhelloworld 演示案例 1234 ~/grep  grep -c "hello" a.txt4 ~/grep  grep -c "world" a.txt4 -i 忽略大小写匹配 样例文本 123456789 ~/grep  cat b.txthelloHellohelloWorldWorldworldHELLOWORLD 演示案例 1234567891011121314151617181920 ~/grep  grep -i "HELLO" b.txthelloHellohelloHELLO ~/grep  grep -i "hello" b.txthelloHellohelloHELLO ~/grep  grep -i "World" b.txtWorldWorldworldWORLD ~/grep  grep -i "worLD" b.txtWorldWorldworldWORLD -n 显示匹配行行号 样例文本 123456789 ~/grep  cat b.txthelloHellohelloWorldWorldworldHELLOWORLD 演示案例 123456789 ~/grep  grep -n "world" b.txt6:world ~/grep  grep -n "hello" b.txt1:hello3:hello ~/grep  grep -n "world" b.txt6:world ~/grep  grep -n "HELLO" b.txt7:HELLO -x 显示完全匹配的行 样例文本 123456 ~/grep  cat c.txthelloHELLOhelloworldHelloWorldHELLOWORLD 演示案例 可以观察到,只能显示出完全匹配的行 12345678 ~/grep  grep -x "hello" c.txthello~/grep  grep -x "HELLO" c.txtHELLO ~/grep  grep -x "HELLOWORLD" c.txtHELLOWORLD ~/grep  grep -x "HelloWorld" c.txtHelloWorld -v 取反 样例文本 123456 ~/grep  cat c.txthelloHELLOhelloworldHelloWorldHELLOWORLD 演示案例 123456789 ~/grep  grep -v "hello" c.txtHELLOHelloWorldHELLOWORLD ~/grep  grep -v "world" c.txthelloHELLOHelloWorldHELLOWORLD 上面的演示结果是区分大小写的,下面加上-i参数使其不区分大小写 123 ~/grep  grep -iv "world" c.txthelloHELLO -A&amp;-B 匹配行的后多少行 -B 和 -A 在某些情况下还是比较有用的,例如在排查日志时,可能就会需要查看指定字段的上下几行来定位程序的错误原因 样例文本 123456789101112131415 ~/grep  cat d.txtabcdefghijklmn 演示案例 1234567891011121314151617181920212223# -A~/grep  grep -A 3 "g" d.txtghij ~/grep  grep -A 3 "c" d.txtcdef# -B ~/grep  grep -B 3 "g" d.txtdefg ~/grep  grep -B 3 "k" d.txthijk -E 正则表达式 这里直接看下面”正则表达式”中的演示案例 正则表达式 正则表达式的一些基础知识就不在这篇文章中讲解了,若想深入了解可以参考我的另一篇博客”正则表达式”. 这里只举几个简单的例子来让你快速了解上手 以下三个符号表示匹配的次数 *:零次或多次匹配前面的字符或表达式 +:一次或多次匹配前面的字符或表达式 ?:零次或一次匹配前面的字符或表达式 还有一个特殊的符号”.“,可以表示除了换行符以外的任意字符 样本文件 12345678910 ~/grep  cat demo.txthelloHelloHelloWorldabcdefgABCDEFGABcdEFgabbbbccccaaaabbbcccaaa111bbb222 演示案例 1234567891011121314151617181920212223242526272829303132333435363738# 匹配 he + 任意个数的字符~/grep  grep "he.*" demo.txthello# 匹配 he + 任意数量的英文小写字符 ~/grep  grep "he[a-z]*" demo.txthello# 匹配 he + 后面指定数量的英文小写字符 ~/grep  grep -Ex "he[a-z]&#123;3&#125;" demo.txthello ~/grep  grep -Ex "he[a-z]&#123;2&#125;" demo.txt # 错误示范,找不到指定行# 匹配全部为大写字母的行 ~/grep  grep -x "[A-Z]*" demo.txtABCDEFG# 匹配 1到3个a &amp; 3个b的行 ~/grep  grep "a\&#123;1,3\&#125;b\&#123;3\&#125;.*" demo.txtabbbbccccaaaabbbccc# 完全匹配 1到3个a &amp; 3个b的行 ~/grep  grep -x "a\&#123;1,3\&#125;b\&#123;3\&#125;.*" demo.txtabbbbcccc# 匹配 h 开头的行 ~/grep  grep "^h.*" demo.txthello# 匹配 H 开头的行 ~/grep  grep "^H.*" demo.txtHelloHelloWorld# 匹配 H开头 d结尾的行 ~/grep  grep "^H.*d$" demo.txtHelloWorld]]></content>
      <categories>
        <category>Linux</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell命令记录]]></title>
    <url>%2F2022%2F09%2F05%2Fshell%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[如何去除shell中字符串的首尾字符参考链接: https://blog.csdn.net/weixin_28746207/article/details/116606020 例如当前有如下变量,值为字符串: 1var="[[&#123;"/": "bafy2bzacea3buvu24ws5r2juchuwrhkbqbym6blkqyccw52adzvzvx4vrpjx4"&#125;,&#123;"/": "bafy2bzacedo3v6yrjslwrinrjtsiajuol2iht2tm5mywzjnbwuhwa3bkcdijk"&#125;]]" 我们想要去掉var变量的首个字符[和结尾字符],其实可以这样做: 1var=`echo $&#123;var:1:-1&#125;` 输出结果为 1[&#123;"/": "bafy2bzacea3buvu24ws5r2juchuwrhkbqbym6blkqyccw52adzvzvx4vrpjx4"&#125;,&#123;"/": "bafy2bzacedo3v6yrjslwrinrjtsiajuol2iht2tm5mywzjnbwuhwa3bkcdijk"&#125;]]]></content>
      <categories>
        <category>Linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang学习笔记]]></title>
    <url>%2F2022%2F06%2F02%2FGolang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Golang语言简介图标上的动物 这个动物叫做金花鼠,英文名称为gordon Go语言的由来目的: 用更少的代码，更短的编译时间，创建运行更快的程序，享受更多的乐趣。 Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：Robert Griesemer，参与开发 Java HotSpot 虚拟机；Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。自 2008 年 1 月起，Ken Thompson 就开始研发一款以 C 语言为目标结果的编译器来拓展 Go 语言的设计思想。 这是一个由计算机领域 “发明之父” 所组成的黄金团队，他们对系统编程语言，操作系统和并行都有着非常深刻的见解 在 2008 年年中，Go 语言的设计工作接近尾声，一些员工开始以全职工作状态投入到这个项目的编译器和运行实现上。Ian Lance Taylor 也加入到了开发团队中，并于 2008 年 5 月创建了一个 gcc 前端。 Russ Cox 加入开发团队后着手语言和类库方面的开发，也就是 Go 语言的标准包。在 2009 年 10 月 30 日，Rob Pike 以 Google Techtalk 的形式第一次向人们宣告了 Go 语言的存在。 直到 2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上的版本。Hector Chu 于同年 11 月 22 日公布了 Windows 版本。 作为一个开源项目，Go 语言借助开源社区的有生力量达到快速地发展，并吸引更多的开发者来使用并改善它。自该开源项目发布以来，超过 200 名非谷歌员工的贡献者对 Go 语言核心部分提交了超过 1000 个修改建议。在过去的 18 个月里，又有 150 开发者贡献了新的核心代码。这俨然形成了世界上最大的开源团队，并使该项目跻身 Ohloh 前 2% 的行列。大约在 2011 年 4 月 10 日，谷歌开始抽调员工进入全职开发 Go 语言项目。开源化的语言显然能够让更多的开发者参与其中并加速它的发展速度。Andrew Gerrand 在 2010 年加入到开发团队中成为共同开发者与支持者。 在 Go 语言在 2010 年 1 月 8 日被 Tiobe（闻名于它的编程语言流行程度排名）宣布为 “2009 年年度语言” 后，引起各界很大的反响。目前 Go 语言在这项排名中的最高记录是在 2017 年 1 月创下的第13名，流行程度 2.325%。 时间轴： 2007 年 9 月 21 日：雏形设计 2009 年 11 月 10日：首次公开发布 2010 年 1 月 8 日：当选 2009 年年度语言 2010 年 5 月：谷歌投入使用 2011 年 5 月 5 日：Google App Engine 支持 Go 语言 从 2010 年 5 月起，谷歌开始将 Go 语言投入到后端基础设施的实际开发中，例如开发用于管理后端复杂环境的项目。有句话叫 “吃你自己的狗食”，这也体现了谷歌确实想要投资这门语言，并认为它是有生产价值的。 Go 语言的官方网站是 golang.org，这个站点采用 Python 作为前端，并且使用 Go 语言自带的工具 godoc 运行在 Google App Engine 上来作为 Web 服务器提供文本内容。在官网的首页有一个功能叫做 Go Playground，是一个 Go 代码的简单编辑器的沙盒，它可以在没有安装 Go 语言的情况下在你的浏览器中编译并运行 Go，它提供了一些示例，其中包括国际惯例 “Hello, World!”。 Go语言的特点 从 C 语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等 等，也保留了和 C 语言一样的编译执行方式及弱化的指针 举一个案例(体验): 1234//go 语言的指针的使用特点(体验) func testPtr(num *int) &#123; *num = 20&#125; 引入包的概念，用于组织程序结构，Go 语言的一个文件都要归属于一个包，而不能单独存在。 1package main //一个go文件需要在一个包里 垃圾回收机制，内存自动回收，不需开发人员管理 天然并发 (重要特点) (1) 从语言层面支持并发，实现简单 (2) goroutine，轻量级线程，可实现大并发处理，高效利用多核。 (3) 基于 CPS 并发模型(Communicating Sequential Processes )实现 吸收了管道通信机制，形成 Go 语言特有的管道 channel 通过管道 channel , 可以实现不同的 goroute 之间的相互通信。 函数可以返回多个值。举例: //写一个函数，实现同时返回 和，差 123456//go 函数支持返回多个值func getSumAndSub(n1 int, n2 int) (int, int ) &#123; sum := n1 + n2 //go 语句后面不要带分号. sub := n1 - n2 return sum , sub&#125; 新的创新:比如切片 slice、延时执行 defer Golang环境配置Mac 下搭建 Go 开发环境-安装和配置 SDK安装SDK安装包名称: go1.9.2.darwin-amd64.tar.gz 链接: https://pan.baidu.com/s/19GZeuyrJl8B7nByqtk5FDQ 提取码: 4cqv 上传位置: Mac 一般放在用户目录下 go_dev/go 下 12345678910111213 ~ mkdir -p go_dev/go ~ cd go_dev/go ~/go_dev/go lsgo1.9.2.darwin-amd64.tar.gz# 解压压缩包 ~/go_dev/go tar xf go1.9.2.darwin-amd64.tar.gz ~/go_dev/go lsgo go1.9.2.darwin-amd64.tar.gz ~/go_dev/go ls goAUTHORS CONTRIBUTORS PATENTS VERSION bin doc lib pkg srcCONTRIBUTING.md LICENSE README.md api blog favicon.ico misc robots.txt test Mac 下配置 Golang 环境变量使用 root 用户，修改 /etc/profile 增加环境变量的配置 123456789101112~ sudo vim /etc/profile# 最下方添加如下内容export GOROOT=$HOME/go_dev/go/goexport PATH=$PATH:$GOROOT/binexport GOPATH=$HOME/goproject# 配置立即生效~ source /etc/profile# 查看golang版本~ go versiongo version go1.9.2 darwin/amd64 Mac下如何开发Go程序准备工作打开VSCode,创建对应的目录 123456package mainimport "fmt"func main()&#123; fmt.Println("hello world")&#125; 生成可执行文件并运行12345678 ~  cd goproject/src/go_code/project01/main ~/goproject/src/go_code/project01/main  lshello.go ~/goproject/src/go_code/project01/main  go build hello.go ~/goproject/src/go_code/project01/main  lshello hello.go ~/goproject/src/go_code/project01/main  ./hellohello world 我们也可以使用-o指定当前生成的二进制文件的名称 1~/goproject/src/go_code/project01/main  go build -o hello1 hello.go 生成linux平台可执行的二进制文件 1GOOS=linux GOARCH=amd64 go build -o hello1 hello.go 直接运行Go文件12 ~/goproject/src/go_code/project01/main  go run hello.gohello world Go开发须知Go程序开发的注意事项1) Go 源文件以 “go” 为扩展名。2) Go应用程序的执行入口是main()函数。这个是和其它编程语言(比如java/c)3) Go语言严格区分大小写。4) Go方法由一条条语句构成，每个语句后不需要分号(Go语言会在每行后自动加分号)，这也体现出 Golang 的简洁性。5) Go编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一个，否则报错6) Go语言定义的变量或者import的包如果没有使用到，代码不能编译通过。7) 大括号都是成对出现的，缺一不可。 Go 语言的转义字符(escape char)说明:常用的转义字符有如下:1) \t : 表示一个制表符，通常使用它可以排版。1) \n :换行符3) \ :一个4) &quot; :一个”5) \r :一个回车 fmt.Println(“天龙八部雪山飞狐\r 张飞”); 举例: 1234567package mainimport "fmt" //fmt 包中提供格式化，输出，输入的函数.func main() &#123;//要求:要求:请使用一句输出语句，达到输入如下图形的效果 fmt.Println("姓名\t 年龄\t 籍贯\t 地址\njohn\t20\t 河北\t 北京")&#125; 输出如下: 注释Go中的注释分为行注释与块注释 行注释:// 块注释:/* 内容 */ 代码风格正确格式: 12345package mainimport "fmt"func main()&#123; fmt.Println("hello,world!") &#125; 错误格式: 123456package mainimport "fmt"func main()&#123; fmt.Println("hello,world!") &#125; 一行字符最长不超过 80 个字符，超过的请使用换行展示，尽量保持格式优雅 官方指南在线调试地址: https://go.dev/play/ 包使用查询: https://pkg.go.dev/ 中文版在线标准库文档地址: https://studygolang.com/pkgdoc 变量Golang变量使用的三种方式 第一种:指定变量类型，声明后若不赋值，使用默认值 第二种:根据值自行判定变量类型(类型推导) 第三种:省略 var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误 多变量声明 在编程中，有时我们需要一次性声明多个变量，Golang 也提供这样的语法 举例说明: 1234567891011121314151617package mainimport "fmt"func main()&#123; //一次性声明多个变量 //方式一 // var n1, n2, n3 int // fmt.Println("n1=",n1, "n2=",n2, "n3=",n3) //方式二 // var n1, name, n3 = 100, "tom", 888 // fmt.Println("n1=",n1, "name=", name, "n3=", n3) //方式三 n1, name, n3 := 100, "tom~", 888 fmt.Println("n1=",n1, "name=", name, "n3=", n3)&#125; 如何一次性声明多个全局变量【在 go 中函数外部定义变量就是全局变量】: 12345678910//定义全局变量var n1 = 100var n2 = 200var name = "jack"//上面的声明方式,也可以改成一次性声明var ( n3 = 300 n4 = 900 name2 = "mary") 该区域的数据值可以在同一类型范围内不断变化(重点) 1234567891011121314package mainimport "fmt"// 变量使用的注意事项func main()&#123; var i int = 10 i = 20 i = 30 fmt.Println("i=", i) i = 1.2 // 这样写是错误的,不可以改变数据的类型&#125; 变量在同一个作用域(在一个函数或者在代码块)内不能重名 12345678910111213141516171819package mainimport "fmt"// 变量使用的注意事项func main()&#123; var i int = 10 i = 20 i = 30 fmt.Println("i=", i) //i = 1.2 // 这样写是错误的,不可以改变数据的类型 // 变量在同一个作用域(在一个函数或者在代码块)内不能重名 var i int = 66 i := 77&#125; 变量=变量名+值+数据类型，这一点请大家注意，变量的三要素 Golang 的变量如果没有赋初值，编译器会使用默认值, 比如 int 默认值 0,string 默认值为空串，小数默认为 0 变量的声明/初始化/赋值声明变量基本语法: var 变量名 数据类型 123//举例子var i int //声明一个int类型的变量 i,若不赋值,默认值为0var s string //声明一个string类型的变量 s,若不赋值,默认值为"" 初始化变量基本语法: var 变量名 数据类型 = 值 123//举例子var i int = 10var s string = "hello world" 给变量赋值 先声明变量,再给变量赋值 123456//举例子var i inti = 10//上面这种写法等于下面这种i := 10 //自动判断数值类型 +号的使用 当左右两边都是数值型时，则做加法运算 当左右两边都是字符串，则做字符串拼接 1234567891011121314151617package mainimport "fmt"func main() &#123; // 数值相加 i := 1 j := 2 sum := i + j fmt.Println(sum) // 字符拼接 s1 := "hello" s2 := "world" s := s1 + s2 fmt.Println(s)&#125; 数据类型 整数类型 类型 占用存储空间 表数范围 int8 1字节 -128-127 int16 2字节 -2^15-2^15-1 int32 4字节 -2^31-2^31-1 int64 8字节 -2^63-2^63-1 其他整数类型 类型 有无符号 占用存储空间 表数范围 备注 int 有 32位系统4个字节64位系统8个字节 -2^31 ~ 2^31-1-2^63 ~ 2^63-1 uint 无 32位系统4个字节64位系统8个字节 0 ~ 2^32-10 ~ 2^64-1 rune 有 与int32一样 -2^31 ~ 2^31-1 等价int32,表示一个Unicode码 byte 无 与uint8一样 0 ~ 255 当要存储字符时选用byte 整数型使用细节 Golang 各整数类型分:有符号和无符号，int uint 的大小和系统有关。 Golang 的整型默认声明为 int 型 123456789package mainimport "fmt"func main() &#123; var i = 100 //此时 i 是什么类型? //查看数据类型 fmt.Printf("i的数据类型为 %T \n", i)&#125; 如何在程序查看某个变量的字节大小和数据类型 (使用较多) 12345678910111213package mainimport ( "fmt" "unsafe")func main() &#123; var i int64 = 100 //此时 i 是什么类型? //查看数据类型 fmt.Printf("i的数据类型为 %T , 占用字节数为 %d\n", i, unsafe.Sizeof(i))&#125; Golang程序中整型变量在使用时，遵守保小不保大的原则，即:在保证程序正确运行下，尽量使用占用空间小的数据类型。【如:年龄】 bit: 计算机中的最小存储单位。byte:计算机中基本存储单元。[二进制再详细说] 1byte = 8 bit 浮点数类型 类型 占用存储空间 表数范围 单精度float32 4字节 -3.403E38 ~ 3.403E38 双精度float64 8字节 -1.798E308 ~ 1.798E308 关于浮点数在机器中存放形式的简单说明,浮点数=符号位+指数位+尾数位说明:浮点数都是有符号的. 12345678910package mainimport "fmt"func main() &#123; var i float32 = 12.34 var n1 float32 = -0.00089 var n2 float64 = -7809656.09 fmt.Println("i=", i, "n1=", n1, "n2=", n2)&#125; 尾数部分可能丢失，造成精度损失。 -123.0000901 123456789package mainimport "fmt"func main() &#123; var n1 float32 = -123.0000901 var n2 float64 = -123.0000901 fmt.Println("n1=", n1, "n2=", n2)&#125; 说明: float64 的精度比 float32 的要准确.如果我们要保存一个精度高的数，则应该选用 float64 浮点型的存储分为三部分:符号位+指数位+尾数位 在存储过程中，精度会有丢失 浮点型使用细节 Golang浮点类型有固定的范围和字段长度,不受具体OS(操作系统)的影响 Golang 的浮点型默认声明为 float64 类型。 浮点型常量有两种表示形式 十进制数形式:如:5.12 .512 (必须有小数点) 科学计数法形式:如:5.1234e2 = 5.12 * 10 的 2 次方 5.12E-2 = 5.12/10 的 2 次方 通常情况下，应该使用 float64 ，因为它比 float32 更精确。 字符类型 Golang 中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存。 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。也 就是说对于传统的字符串是由字符组成的，而 Go 的字符串不同，它是由字节组成的。 123456789101112131415161718package mainimport "fmt"func main() &#123; var c1 byte = 'a' var c2 byte = 'o' // 当我们直接输出byte值,就是输出了对应的字符的码值 fmt.Println("c1=", c1) fmt.Println("c2=", c2) // 如果想要输出对应的字符,需要使用格式化输出 fmt.Printf("c1=%c, c2=%c", c1, c2) var c3 byte = "北" //报错,overflow溢出 fmt.Printf("c3=%c, 对应的码值为%d", c3, c3)&#125; 对上面代码说明: 1) 如果我们保存的字符在 ASCII 表的,比如[0-1, a-z,A-Z..]直接可以保存到 byte2) 如果我们保存的字符对应码值大于 255,这时我们可以考虑使用 int 类型保存3) 如果我们需要安装字符的方式输出，这时我们需要格式化输出，即 fmt.Printf(“%c”, c1). 字符类型使用细节1) 字符常量是用单引号(‘’)括起来的单个字符。例如:var c1 byte = ‘a’ var c2 int = ‘中’ var c3 byte = ‘9’2) Go 中允许使用转义字符 ‘\’来将其后的字符转变为特殊字符型常量。例如:var c3 char = ‘\n’ // ‘\n’表示换行符3) Go 语言的字符使用 UTF-8 编码 ，如果想查询字符对应的 utf8 码值 http://www.mytju.com/classcode/tools/encode_utf8.asp 英文字母-1个字节 汉字-3个字节4) 在 Go 中，字符的本质是一个整数，直接输出时，是该字符对应的 UTF-8 编码的码值。5) 可以直接给某个变量赋一个数字，然后按格式化输出时%c，会输出该数字对应的 unicode 字符6) 字符类型是可以进行运算的，相当于一个整数，因为它都对应有 Unicode 码. 布尔类型 布尔类型也叫 bool 类型，bool 类型数据只允许取值 true 和 false bool类型占1个字节。 bool 类型适于逻辑运算，一般用于程序流程控制 string类型 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本 Go语言的字符串的字节使用UTF-8编码标识Unicode文本，这样Golang统一使用UTF-8编码,中文 乱码问题不会再困扰程序员。 字符串一旦赋值了，字符串就不能修改了:在 Go 中字符串是不可变的。 字符串的两种表示形式:(1) 双引号, 会识别转义字符(2) 反引号，以字符串的原生形式输出，包括换行和特殊字符，可以实现防止攻击、输出源代码等效果 字符串拼接方式 12str := "hello" + "world"str += "haha" 当一行字符串太长时，需要使用到多行字符串，可以如下处理 12345678910package mainimport "fmt"func main() &#123; // 结尾需要跟上 + 号,才能跟下一行拼接 var s1 string = "hello " + "world " + "I " + "am " + "chinese\n" fmt.Println(s1)&#125; 基本数据类型的默认值 数据类型 默认值 整型 0 浮点型 0 字符串 “” 布尔类型 false 基本数据类型的相互转换 Golang 和 java / c 不同，Go 在不同类型的变量之间赋值时需要显式转换。也就是说 Golang 中数 据类型不能自动转换。 表达式 T(v) 将值 v 转换为类型 T T: 就是数据类型，比如 int32，int64，float32 等等 v: 就是需要转换的变量 注意事项1) Go中，数据类型的转换可以是从表示范围小–&gt;表示范围大，也可以范围大—&gt;范围小2) 被转换的是变量存储的数据(即值)，变量本身的数据类型并没有变化!3) 在转换中，比如将 int64 转成 int8 【-128—127】 ，编译时不会报错，只是转换的结果是按 溢出处理，和我们希望的结果不一样。 因此在转换时，需要考虑范围. 基本数据类型转换为string方式一:fmt.Sprintf1234567891011121314151617181920212223package mainimport "fmt"func main()&#123; var num1 int64 = 10 var num2 float64 = 10.12 var b bool = false var char byte = 'h' var str string str = fmt.Sprintf("%d", num1) fmt.Printf("str Type %T, str=%q\n", str, str) str = fmt.Sprintf("%f", num2) fmt.Printf("str Type %T, str=%q\n", str, str) str = fmt.Sprintf("%t", b) fmt.Printf("str Type %T, str=%q\n", str, str) str = fmt.Sprintf("%c", char) fmt.Printf("str Type %T, str=%q\n", str, str)&#125; 方式二:strconv12345678910111213// 第二种方式var num3 int32 = 99var num4 float32 = 12.3456var b2 bool = truestr = strconv.FormatInt(int64(num3), 10) //必须转换为64fmt.Printf("str Type %T, str=%q\n", str, str)str = strconv.FormatFloat(float64(num4), 'f', 10, 32) //必须转换为64fmt.Printf("str Type %T, str=%q\n", str, str)str = strconv.FormatBool(b2)fmt.Printf("str Type %T, str=%q\n", str, str) string转换为基本数据类型 strconv.Parsexxx 12345678910111213141516171819202122232425262728package mainimport ( "fmt" "strconv")func main() &#123; var str string = "true" var b bool // strconv.ParseBool(str)会返回两个值(value bool, err error),我们不需要error信息 b, _ = strconv.ParseBool(str) fmt.Printf("b Type %T, b=%v\n", b, b) var str2 string = "123456" var num1 int64 //必须为64才能被 strconv.ParseInt 识别 var num2 int num1, _ = strconv.ParseInt(str2, 10, 64) num2 = int(num1) fmt.Printf("num1 type %T, num1=%v\n", num1, num1) fmt.Printf("num2 type %T, num2=%v\n", num2, num2) var str3 string = "123.456" var f1 float64 f1, _ = strconv.ParseFloat(str3, 64) fmt.Printf("f1 Type %T, f1=%v", f1, f1)&#125; 注意事项在将 String 类型转成 基本数据类型时，要确保 String 类型能够转成有效的数据，比如 我们可以 把 “123” , 转成一个整数，但是不能把 “hello” 转成一个整数，如果这样做，Golang 直接将其转成 0 ， 其它类型也是一样的道理. float =&gt; 0 bool =&gt; false 指针基本介绍 基本数据类型，变量存的就是值，也叫值类型 获取变量的地址，用&amp;，比如: var num int, 获取 num 的地址:&amp;num分析一下基本数据类型在内存的布局. 指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值 比如:var ptr *int = &amp;num 举例说明:指针在内存的布局. 123456789101112131415package mainimport "fmt"func main() &#123; var i int = 10 fmt.Println("i的地址为=", &amp;i) var ptr *int = &amp;i fmt.Printf("ptr=%v\n", ptr) fmt.Printf("ptr的地址=%v\n", &amp;ptr) fmt.Printf("ptr指向的值=%v\n", *ptr)&#125; 案例演示1) 写一个程序，获取一个 int 变量 num 的地址，并显示到终端2) 将 num 的地址赋给指针 ptr , 并通过 ptr 去修改 num 的值. 123456789101112131415package mainimport "fmt"func main() &#123; var num int = 9 fmt.Println("num=", num) // 输出值 fmt.Println("num的地址=", &amp;num) // 输出地址 // 通过指针修改num的值为10 var ptr *int ptr = &amp;num *ptr = 10 fmt.Println("num=", num)&#125; 使用细节1) 值类型，都有对应的指针类型， 形式为 *数据类型，比如 int 的对应的指针就是 *int, float32 对应的指针类型就是 *float32, 依次类推。2) 值类型包括:基本数据类型 int 系列,float 系列, bool, string 、数组和结构体 struct 值类型和引用类型1) 值类型:基本数据类型 int 系列, float 系列, bool, string 、数组和结构体 struct2) 引用类型:指针、slice 切片、map、管道 chan、interface 等都是引用类型 使用特点 值类型 变量直接存储值，内存通常在栈中分配 引用类型 变量存储的是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由 GC 来回收 内存的栈区和堆区示意图 标识符的命名规范标识符概念1) Golang 对各种变量、方法、函数等命名时使用的字符序列称为标识符2) 凡是自己可以起名字的地方都叫标识符 命名规则1) 由 26 个英文字母大小写，0-9 ，_ 组成2) 数字不可以开头。var num int //ok var 3num int //error3) Golang中严格区分大小写。 var num int var Num int 说明:在 golang 中，num 和 Num 是两个不同的变量4) 标识符不能包含空格。5) 下划线”_”本身在 Go 中是一个特殊的标识符，称为空标识符。可以代表任何其它的标识符，但是它对应的值会被忽略(比如:忽略某个返回值)。所以仅能被作为占位符使用，不能作为标识符使用6) 不能以系统保留关键字作为标识符(一共有 25 个)，比如 break，if 等等… 标识符命名注意事项 包名:保持 package 的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，不要和 标准库不要冲突 fmt 变量名、函数名、常量名:采用驼峰法 举例: var stuName string = “tom” 形式: xxxYyyyyZzzz … var goodPrice float32 = 1234.5 如果变量名、函数名、常量名首字母大写，则可以被其他的包访问;如果首字母小写，则只能在本包中使用 ( 注:可以简单的理解成，首字母大写是公开的，首字母小写是私有的) ,在 golang 没有 public , private 等关键字。 系统保留关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrogh if range type continue for import return var 系统的预定义标识符 append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 init16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintprt 运算符运算符的基本介绍 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等 1) 算术运算符2) 赋值运算符3) 比较运算符/关系运算符 4) 逻辑运算符4) 位运算符5) 其它运算符 算术运算符 算术运算符是对数值类型的变量进行运算的，比如:加减乘除。在 Go 程序中使用的非常多 算术运算符的一览表 运算符 运算 范例 结果 + 正号 +3 3 - 负号 -4 -4 + 加 5 + 5 10 - 减 6 - 4 2 * 乘 3 * 4 12 / 除 5 / 5 1 % 取模(取余) 7 % 5 2 ++ 自增 a=2 a++ a=3 – 自减 a=2 a– a=1 + 字符串相加 “He” + “llo” “Hello” 演示 / 的使用特点123456789101112131415package mainimport "fmt"func main() &#123; // 两个整数相除,那么结果会去掉小数点,保留整数 fmt.Println(10 / 4) var a float32 = 10 / 4 fmt.Println(a) // 如果想要保留小数怎么办? var b float32 = 10.0 / 4 fmt.Println(b)&#125; 演示 % 的使用特点12345//演示 %的使用// 看一个公式 a%b=a-a/b*bfmt.Println("10%3=", 10 % 3) // =1fmt.Println("-10%3=", -10 % 3) // = -10 - (-10) / 3 * 3 = -10 - (-9) = -1 fmt.Println("10%-3=", 10 % -3) // =1fmt.Println("-10%-3=", -10 % -3) // =-1 关系运算符(比较运算符)基本介绍 关系运算符的结果都是 bool 型，也就是要么是 true，要么是 false 关系表达式 经常用在 if 结构的条件中或循环结构的条件中 关系运算符一览图 运算符 运算 范例 结果 == 相等于 4==3 false != 不等于 4!=3 true &lt; 小于 4&lt;3 false &gt; 大于 4&gt;3 true &lt;= 小于等于 4&lt;=3 false &gt;== 大于等于 4&gt;=3 true 逻辑运算符基本介绍 用于连接多个条件(一般来讲就是关系表达式)，最终的结果也是一个 bool 值 逻辑运算的说明 假定A值为True 假定B值为False 运算符 描述 实例 &amp;&amp; 逻辑 与运算符,如果两边的操作数都是True,则为True,否则为False (A &amp;&amp; B)为False || 逻辑 或运算符,如果两边的操作数有一个是True,则为True,否则为False (A || B)为True ! 逻辑 否运算符,如果条件为True,则逻辑为False,否则为True !(A &amp;&amp; B)为True 细节说明 1) &amp;&amp; 也叫短路与:如果第一个条件为false，则第二个条件不会判断，最终结果为false 2) || 也叫短路或:如果第一个条件为true， 则第二个条件不会判断，最终结果为true 赋值运算符 赋值运算符就是将某个运算后的值，赋给指定的变量 赋值运算符的分类 运算符 描述 实例 = 简单地赋值运算符,将一个表达式的值赋给一个左值 C = A+B: 将A + B表达式的结果赋值给C += 相加后再赋值 C += A =&gt; 等于 C = C+A -= 相减后再赋值 C -= A =&gt; 等于 C = C-A *= 相乘后再赋值 C *= A =&gt; 等于 C = C*A /= 相除后再赋值 C /= A =&gt; 等于 C = C/A %= 相余后再赋值 C %= A =&gt; 等于C = C%A &lt;&lt;= 左移后赋值 C &lt;&lt;= 2 等于 C = C&lt;&lt;2 &gt;&gt;= 右移后赋值 C &gt;&gt;= 2 等于 C = C&gt;&gt;2 &amp;= 按位与后赋值 C &amp;= 2 等于 C = C &amp; 2 ^= 按位异或后赋值 C ^= 2 等于 C = C ^ 2 |= 按位或后赋值 C |= 2 等于 C = C | 2 赋值运算符的特点 运算顺序从右往左 赋值运算符的左边 只能是变量,右边 可以是变量、表达式、常量值 复合赋值运算符等价于下面的效果 比如:a+=3 等价于 a=a+3 位运算符 运算符 描述 &amp; 按位与运算符”&amp;”是双目运算符,其功能是参与运算的两数各对应的二进位相与运算规则是:有一个为1,结果为1,否则为0 | 按位或运算符”|”是双目运算符,其功能是参与运算的两数各对应的二进位相或运算规则是:同时为1,结果为1,否则为0 ^ 按位异或运算符”^”是双目运算符,其功能是参与运算的两数各对应的二进位相异或运算规则是:当二进位不同时,结果为1,否则为0 &lt;&lt; 左移运算符”&lt;&lt;”是双目运算符,其功能是把”&lt;&lt;”左边的运算数的各二进位全部左移若干位,高位丢弃,低位补0,左移n位就是乘以2的n次方. &gt;&gt; 右移运算符”&gt;&gt;”是双目运算符,其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位,右移n位就是除以2的n次方. 其它运算符说明 运算符 描述 实例 &amp; 返回变量存储地址 &a;将给出变量的实际地址 * 指针变量 *a;是一个指针变量 运算符的优先级运算符的优先级的一览表 从上到下,优先级依次递减 分类 描述 关联性 后缀 () [] -&gt; . ++ – 左到右 单目 + - ! ~ (type) * &amp; sizeof 右到左 乘法 * / % 左到右 加法 + - 左到右 移位 &lt;&lt; &gt;&gt; 左到右 关系 &lt; &lt;= &gt; &gt;= 左到右 相等 == != 左到右 按位AND &amp; 左到右 按位XOR ^ 左到右 按位OR | 左到右 逻辑AND &amp;&amp; 左到右 逻辑OR || 左到右 赋值运算符 = += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= |= 右到左 逗号 , 左到右 键盘输入语句介绍在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。InputDemo.go 步骤 导入fmt包 调用 fmt 包的 fmt.Scanln() 或者 fmt.Scanf() 官方文档查询使用方法: https://pkg.go.dev/fmt#Scan 演示案例 要求:可以从控制台接收用户信息，【姓名，年龄，薪水, 是否通过考试 】。 使用 fmt.Scanln() 获取 1234567891011121314151617181920212223package mainimport "fmt"func main() &#123; // 要求:可以从控制台接收用户信息，【姓名，年龄，薪水, 是否通过考试 】。 var name string var age byte var sal float32 var isPass bool fmt.Println("请输入姓名: ") fmt.Scanln(&amp;name) fmt.Println("请输入年龄: ") fmt.Scanln(&amp;age) fmt.Println("请输入薪水: ") fmt.Scanln(&amp;sal) fmt.Println("请输入是否通过考试: ") fmt.Scanln(&amp;isPass) fmt.Printf("名字是 %v\n年龄是 %v\n薪水是 %v\n是否通过考试: %v\n", name, age, sal, isPass)&#125; 使用 fmt.Scanf() 获取 12345678910111213141516package mainimport "fmt"func main() &#123; // 要求:可以从控制台接收用户信息，【姓名，年龄，薪水, 是否通过考试 】。 var name string var age byte var sal float32 var isPass bool // 方式二: fmt.scanf,可以按照指定的格式输入 fmt.Println("请分别输入你的姓名/年龄/薪水, 使用空格分隔") fmt.Scanf("%s %d %f %t", &amp;name, &amp;age, &amp;sal, &amp;isPass) fmt.Printf("名字是 %v\n年龄是 %v\n薪水是 %v\n是否通过考试: %v\n", name, age, sal, isPass)&#125; 进制对于整数，有四种表示方式: 二进制: 0,1 ，满 2 进 1。在 golang 中，不能直接使用二进制来表示一个整数，它沿用了 c 的特点。 十进制: 0-9 ，满 10 进 1。 八进制: 0-7 ，满 8 进 1. 以数字 0 开头表示。 十六进制: 0-9及A-F，满16进1. 以0x或0X开头表示。此处的 A-F 不区分大小写。 1234567891011121314151617package mainimport "fmt"func main() &#123; var i int = 5 // 二进制输出 fmt.Printf("%b \n", i) // 八进制输出, 满 8 进 1,以数字 0 开头 var j int = 011 fmt.Println("j=", j) // 十六进制输出,满 16 进 1, 以 0x 或 0X 开头 var k int = 0x11 fmt.Println("k=", k)&#125; 进制的图示 十进制 十六进制 八进制 二进制 0 0 0 0 1 1 1 1 2 2 2 10 3 3 3 11 4 4 4 100 5 5 5 101 6 6 6 110 7 7 7 111 8 8 10 1000 9 9 11 1001 10 A 12 1010 11 B 13 1011 12 C 14 1100 13 D 15 1101 14 E 16 1110 15 F 17 1111 16 10 20 10000 17 11 21 10001 进制的转换 其他进制转十进制 二进制转十进制 八进制转十进制\ 十六进制转十进制 十进制转其它进制 十进制转二进制 十进制转八进制 十进制转十六进制 二进制转其它进制 二进制转八进制 二进制转十六进制 其他进制转二进制 八进制转二进制 十六进制转二进制 其它进制转十进制二进制如何转十进制 规则: 从最低位开始(右边开始),将每个位上的数提取出来,乘以2的(位数-1)次方,然后求和 案例: 请将二进制 1011 转换成十进制 1231011 = 1*2^(1-1) + 1*2^(2-1) + 0*2^(3-1) + 1*2^(4-1) = 1 + 2 + 0 + 8 = 11 八进制如何转十进制 规则: 从最低位开始,将每个位上的数提取出来,乘以8的(位数-1)次方,然后求和 案例: 请将0123转换为十进制 1230123 = 3*8^(1-1) + 2*8^(2-1) + 1*8^(3-1) + 0*8^(4-1) = 3 + 16 + 64 + 0 = 83 十六进制转十进制 规则: 从最低位开始,将每个位上的数提取出来,乘以16的(位数-1)次方,然后求和 案例: 请将0x34A转成十进制 1230x34A = 10*16^(1-1) + 4*16^(2-1) + 3*16^(3-1) = 10 + 64 + 768 = 842 十进制转其它进制十进制转二进制 规则: 将该数不断除以2,直到商为0为止,然后将每步得到的余数倒过来,就是对应的二进制 案例: 请将56转成二进制 12345678956/2=28 - 028/2=14 - 014/2=7 - 07/2=3 - 13/2=1 - 11/2=0 - 1 // 1除以任何大于1的正整数,商都为0,余数为11 1 1 0 0 0 = 5632 16 8 4 2 1 十进制转八进制 规则: 将该数不断除以8,直到商为0为止,然后将每步得到的余数倒过来,就是对应的二进制 案例: 请将156转成八进制 12345156/8=19 - 419/8=2 - 32/8=0 - 2 // 2除以8余2；（商0）八进制: 0234=156 十进制转十六进制 规则: 将该数不断除以16,直到商为0为止,然后将每步得到的余数倒过来,就是对应的二进制 案例: 请将356转成十六进制 12345356/16=22 - 422/16=1 - 61/16=0 - 1十六进制: 0x164=356 二进制转八进制/十六进制二进制转八进制 规则: 将二进制数每三位一组(从低位开始组合),转成对应的八进制即可 案例: 请将二进制 11010101 转成八进制 111010101 =&gt; (11) (010) (101) =&gt; 0325 二进制转十六进制 规则: 将二进制数每四位一组(从低位开始组合),转成对应的十六进制即可 案例: 请将二进制 11010101转成十六进制 111010101 =&gt; (1101) (0101) =&gt; 0x135 =&gt; 0xD5 八进制/十六进制转二进制八进制转二进制 规则: 将八进制数每1位,转成对应的一个三位数即可 案例: 请将0237转成二进制 10237 =&gt; (010) (011) (111) =&gt; 10011111 十六进制转二进制 规则: 将八进制数每1位,转成对应的一个四位数即可 案例: 请将0x237转成二进制 10x237 =&gt; (0010) (0011) (0111) =&gt; 1000110111 位运算原码、反码、补码精简6句话: 二进制的最高位是符号位: 0表示正数,1表示负数 1 =&gt; [0000 0001] -1 =&gt; [1000 0001] 正数的源码/反码/补码都一样 负数的反码=原码符号位不变,其他位取反 1 =&gt; 原码[0000 0001] 1 =&gt; 反码[0000 0001] 1 =&gt; 补码[0000 0001] -1 =&gt; 原码[1000 0001] -1 =&gt; 反码[1111 1110] -1 =&gt; 补码[1111 1111] 负数的补码=反码+1 0的反码/补码都是0 计算机运算时以补码方式进行运算 位运算符和移位运算符 Golang中有3个位运算,它们的运算规则是: 按位与&amp;: 两位全为1，结果为 1，否则为 0 按位或|: 两位有一个为 1，结果为 1，否则为 0 按位异或 ^: 两位一个为 0,一个为 1，结果为 1，否则为 0 注意: 整数的反码补码都一样,所以补码=原码,负数的时候需要用补码先推回到反码,再用反码推回原码 计算值 原码 反码 补码 2 0000 0010 0000 0010 0000 0010 3 0000 0011 0000 0011 0000 0011 2&amp;3 - - 0000 0010(2) 2|3 - - 0000 0011(3) 2^3 - - 0000 0001(1) -2 1000 0010 1111 1101 1111 1110 2 0000 0010 0000 0010 0000 0010 -2^2 1000 0100(-4) 1111 1011(补码-1) 1111 1100 Golang中有2个移位运算符: ****右移运算符 &gt;&gt;: 低位溢出,符号位不变,并用符号位补溢出的高位左移运算符 &lt;&lt;: 符号位不变,低位补 0 案例演示 12a := 1 &gt;&gt; 2 // 0000 0001 =&gt; 0000 0000 = 0c := 1 &lt;&lt; 2 // 0000 0001 =&gt; 0000 0100 = 4 流程控制 这个章节不写案例,没啥好写的,不懂的最好去查一下相关案例,能更加快速的上手 顺序控制 代码中，没有判断，也没有跳转.因此程序按照默认的流程执行，即顺 序控制。 这个不必过多介绍,这个不明白啥意思别往下看了,你学不会了兄弟-_-|| 分支控制单分支 基本语法 123if 条件 &#123; PASS&#125; 双分支 注意: 下面的else不可以换行,必须为 }esle{ 基本语法 12345if 条件 &#123; PASS&#125;else&#123; PASS&#125; 多分支 基本语法 123456789if 条件 &#123; PASS&#125;else if 条件 &#123; PASS&#125;......&#125;else&#123; PASS&#125; 需要注意的是,if语句的判断条件中,不能只出现赋值语句,例如 if a=5,但是可以写成if a=5;a&gt;4 嵌套分支 在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外层分支。 1234567if 条件 &#123; if 条件 &#123; PASS &#125;else&#123; PASS &#125;&#125; switch分支 switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上到下逐一测 试，直到匹配为止。 匹配项后面也不需要再加 break 基本语法 123456789switch 表达式 &#123;case 表达式1: PASScase 表达式2: PASS ...default: PASS&#125; 总结: 1) switch的执行的流程是，先执行表达式，得到值，然后和case的表达式进行比较，如果相等， 就匹配到，然后执行对应的 case 的语句块，然后退出 switch 控制。2) 如果 switch 的表达式的值没有和任何的 case 的表达式匹配成功，则执行 default 的语句块。执行后退出 switch 的控制.3) golang的case后的表达式可以有多个，使用逗号间隔.4) golang 中的 case 语句块不需要写 break , 因为默认会有,即在默认情况下，当程序执行完 case 语 句块后，就直接退出该 switch 控制结构。 案例 1234567891011121314151617181920package mainimport "fmt"func main() &#123; var i int fmt.Println("请输入一个数字: ") fmt.Scanf("%v", &amp;i) switch i &#123; case 1: fmt.Println("数值1") case 2: fmt.Println("数值2") case 3: fmt.Println("数值3") default: fmt.Println("输入错误") &#125;&#125; 也可以写成下面这样 1234567891011121314151617181920package mainimport "fmt"func main() &#123; var i int fmt.Println("请输入一个数字: ") fmt.Scanf("%v", &amp;i) switch &#123; case i == 1: fmt.Println("数值1") case i == 2: fmt.Println("数值2") case i == 3: fmt.Println("数值3") default: fmt.Println("输入错误") &#125;&#125; switch 穿透-fallthrough: 如果在 case 语句块后增加 fallthrough ,则会继续执行下一个 case，也 叫 switch 穿透 1234567891011121314151617181920package mainimport "fmt"func main() &#123; var num int = 10 switch num &#123; case 10: fmt.Println("OK1") fallthrough case 20: fmt.Println("OK2") fallthrough case 30: fmt.Println("OK3") default: fmt.Print("没有匹配到") &#125;&#125; 循环控制for循环方式一 基本语法 123for 循环变量初始化;循环条件;循环变量迭代&#123; PASS&#125; 例子: 打印十遍Hello World 123456789package mainimport "fmt"func main() &#123; for i := 1; i &lt;= 10; i++ &#123; fmt.Println("Hello World") &#125;&#125; 方式二 将变量初始化和变量迭代写到其它位置 基本语法 123for 循环判断条件 &#123; PASS&#125; 例子: 打印十遍Hello World 1234567891011package mainimport "fmt"func main() &#123; var i int = 1 for i &lt;= 10 &#123; fmt.Println("Hello World") i++ &#125;&#125; 方式三: 无限循环 等价 for ; ; {} 是一个无限循环， 通常需要配合 break 语句使用 基本语法 123for &#123; PASS&#125; 例子:输出1-10 123456789101112131415package mainimport "fmt"func main() &#123; i := 1 for &#123; if i &lt;= 10 &#123; fmt.Println(i) i++ &#125; else &#123; break //退出循环 &#125; &#125;&#125; for-range 可以方便的遍历字符串与数组 例子(传统方式): 按照索引顺序,输出字符串的单个字符 12345678910package mainimport "fmt"func main() &#123; var str string = "Hello,World!" for i := 0; i&lt;len(str);i++&#123; fmt.Printf("%c \n", str[i]) &#125;&#125; 例子(for-range): 字符串遍历 12345678910package mainimport "fmt"func main() &#123; var str string = "Hello,World!" for index,value := range str&#123; fmt.Printf("index=%d, value=%c \n", index, value) &#125;&#125; 对于传统的字符串遍历来说,如果字符串中含有中文,会报错 原因是传统的对字符串的遍历是按照字节来遍历，而一个汉字在 utf8 编码是对应 3 个字节。 如何解决?需要要将 str 转成 []rune 切片 1234567891011package mainimport "fmt"func main() &#123; var str string = "Hello,World!你好世界!" str_rune := []rune(str) for i := 0; i&lt;len(str_rune);i++&#123; fmt.Printf("%c \n", str_rune[i]) &#125;&#125; for-range的方式处理中文不会出问题 while 和 do..whilewhile Go 语言没有 while 和 do…while 语法，这一点需要注意一下，如果我们需要使用类似其它语 言(比如 java / c 的 while 和 do…while )，可以通过 for 循环来实现其使用效果。 1234567891011121314package mainimport "fmt"func main() &#123; i := 1 for &#123; if i &gt; 10 &#123; break &#125; fmt.Println(i) i++ &#125;&#125; 就是上面for循环中说的for ; ; {} 是一个无限循环 do..while1234567891011121314package mainimport "fmt"func main() &#123; i := 1 for &#123; fmt.Println(i) i++ if i &gt; 10 &#123; break &#125; &#125;&#125; 练习: 利用*输出金字塔 123456789101112131415161718192021222324package mainimport ( "fmt")func main() &#123; var line int fmt.Println("请输入金字塔的行数: ") fmt.Scanf("%d", &amp;line) // 输出一个矩形 for i := 1; i &lt;= line; i++ &#123; // 空格 for j := 1; j &lt;= line-i; j++ &#123; fmt.Print(" ") &#125; // 星号 for k := 1; k &lt;= 2*i-1; k++ &#123; fmt.Print("*") &#125; fmt.Println() &#125;&#125; break 这个很好理解,主动退出循环嘛,这里不做过多解释,但是有一个标签的功能需要说一下 break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块 break默认跳出最近的 for 循环 1234567891011121314151617181920package mainimport ( "fmt")func main() &#123; var line int = 10 label: for i := 1; i &lt;= line; i++ &#123; fmt.Println("1") for j := 1; j &lt;= line-i; j++ &#123; if j == 5&#123; break label //直接跳出指定位置的循环 &#125; fmt.Println("2") &#125; &#125;&#125; continue continue 语句用于结束本次循环，继续执行下一次循环。 continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的 break 标签的使用的规则一样. 这里就不演示了 放个截图 goto1) Go 语言的 goto 语句可以无条件地转移到程序中指定的行。2) goto语句通常与条件语句配合使用。可用来实现条件转移，跳出循环体等功能。3) 在 Go 程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序 都产生困难 一个案例演示快速说明,麻利滴! 1234567891011121314import "fmt"func main() &#123; var num int = 10 if num &gt; 5 &#123; goto label &#125; fmt.Println("我小于5!")label: fmt.Println("我大于5!")&#125; return return 使用在方法或者函数中，表示跳出所在的方法或函数，在讲解函数的时候，会详细的介绍。 说明: 1) 如果 return 是在普通的函数，则表示跳出该函数，即不再执行函数中 return 后面代码，也可以理解成终止函数。2) 如果 return 是在 main 函数，表示终止 main 函数，也就是说终止程序。 函数 因为本人有一定基础,这里就不做太详细的解释,直接上干货,兄弟们! 基本语法 函数可以有返回值,也可以没有 1234func 函数名 [形参列表] [返回值列表]&#123; PASS return [返回值列表]&#125; 快速入门12345678910111213141516171819202122232425262728package mainimport "fmt"func calculate(n1 float64, n2 float64, operator byte) float64 &#123; var res float64 switch operator &#123; case '+': res = n1 + n2 case '-': res = n1 - n2 case '*': res = n1 * n2 case '/': res = n1 / n2 default: fmt.Println("操作符号错误") &#125; return res&#125;func main() &#123; var n1 float64 = 1.2 var n2 float64 = 2.3 var operator byte = '+' result := calculate(n1, n2, operator) fmt.Println(result)&#125; 包 在实际的开发中，我们往往需要在不同的文件中，去调用其它文件的定义的函数，比如 main.go 中，去使用 utils.go 文件中的函数，如何实现? =&gt; 包 现在有两个程序员共同开发一个 Go 项目,程序员 xiaoming 希望定义函数 Cal ,程序员 xiaoqiang 也想定义函数也叫 Cal。两个程序员为此还吵了起来,怎么办? =&gt; 包 原理 包的本质实际上就是创建不同的文件夹，来存放程序文件。 说明: go 的每一个文件都是属于一个包的，也就是说 go 是以包的形式来管理文件和项目目录结构 三大作用 区分相同名字的函数、变量等标识符 当程序文件很多时,可以很好的管理项目 控制函数、变量等访问范围，即作用域 说明打包基本语法 1package 包名 引入包的基本语法 1import "包的路径" 快速入门 注意: golang在找包的时候,默认会在/usr/local/go/src/寻找,所以文件要放在golang的src目录下,我目前main.go的绝对路径是/usr/local/go/src/golang_study/08-hanshu/main,所以下面调用utils包时,只需要从golang_study开始写就可以了 目录格式 utils.go 1234567891011121314151617181920package utilsimport "fmt"func Calculate(n1 float64, n2 float64, operator byte) float64 &#123; var res float64 switch operator &#123; case '+': res = n1 + n2 case '-': res = n1 - n2 case '*': res = n1 * n2 case '/': res = n1 / n2 default: fmt.Println("操作符号错误") &#125; return res&#125; main.go 123456789101112131415package mainimport ( "fmt" "golang_study/08-hanshu/utils")func main() &#123; var n1 float64 = 1.2 var n2 float64 = 2.3 var operator byte = '+' result := utils.Calculate(n1, n2, operator) fmt.Println(result)&#125; 注意事项和细节 在给一个文件打包时，该包对应一个文件夹，比如这里的 utils 文件夹对应的包名就是 utils, 文件的包名通常和文件所在的文件夹名一致，一般为小写字母。 当一个文件要使用其它包函数或变量时，需要先引入对应的包 引入方式 1: 1import "包名" 引入方式 2: 1234import ( "包名" "包名" ) package 指令在 文件第一行，然后是 import 指令。 在 import 包时，路径从 $GOPATH 的 src 下开始，不用带 src , 编译器会自动从 src 下开始引入 为了让其它包的文件，可以访问到本包的函数，则该函数名的首字母需要大写，类似其它语言 的 public ,这样才能跨包访问。比如 utils.go 的Calculate 在访问其它包函数，变量时，其语法是 包名.函数名， 比如这里的 main.go 文件中 如果包名较长，Go 支持给包取别名， 注意细节:取别名后，原来的包名就不能使用了 如果你要编译成一个可执行程序文件，就需要将这个包声明为 main , 即 package main .这个就是一个语法规范，如果你是写一个库 ，包名可以自定义 打包生成可执行文件命令如下: 1go build -o bin/my.exe golang_study/08-hanshu/main 函数的调用机制 为了让大家更好的理解函数调用过程, 看两个案例，并画出示意图，这个很重要 传入一个数+1 12345678910111213141516171819202122232425package mainimport ( "fmt")func test(n1 int) &#123; n1 = n1 + 1 fmt.Println("test n1=", n1)&#125;func getSum(n1 int, n2 int) int &#123; sum := n1 + n2 fmt.Println("getSum sum=", sum) return sum&#125;func main() &#123; n1 := 10 test(n1) fmt.Println("main() n1=", n1) sum := getSum(10, 20) fmt.Println("main() sum=", sum)&#125; 为什么上面代码执行结果中,n1的值没有真正的改变呢?请看下面这个解释吧 在调用一个函数时，会给该函数分配一个新的空间，编译器会通过自身的处理让这个新的空间 和其它的栈的空间区分开来 在每个函数对应的栈中，数据空间是独立的，不会混淆 当一个函数调用完毕(执行完毕)后,程序会销毁这个函数对应的栈空间 return语句基本语法与说明 Golang函数支持返回多个值,这一点是其他编程语言没有的 1234func (形参列表) (返回值类型列表)&#123; 语句... return 返回值列表&#125; 说明: 如果返回多个值时,在接收时,如果希望忽略某个值,则使用_符号表示占位忽略 如果返回值只有一个,(返回值类型列表)可以不写 案例: 计算两个数的和and差1234567891011121314151617package mainimport "fmt"// 计算两个数的 和/查 值func getSumAndSub(n1 int, n2 int) (int, int)&#123; sum := n1 + n2 sub := n1 - n2 return sum, sub&#125;func main() &#123; var n1 int = 30 var n2 int = 20 sum, sub := getSumAndSub(n1, n2) fmt.Printf("sum=%d, sub=%d \n", sum, sub)&#125; 函数的递归 一个函数在函数体内又调用了本身，我们称为递归调用 快速通过代码理解一下 12345678910111213141516package mainimport "fmt"func test(n int) &#123; if n &gt; 2 &#123; n-- test(n) &#125; fmt.Println("n=", n)&#125;func main() &#123; test(4)&#125; 执行结果 ??? 为什么是 2 2 3 ??? 递归说白了就是套娃,优先执行最里边的,然后由里到外依次执行,所以你会看到 2 2 3 这个结果 什么?还不明白? 那我给你解释一下上面的代码 test(4) – 第一步 符合if判断条件 n– 此时n由4-1变为了3 test(3) n=3 test(3) – 第二步 符合if判断条件 n– 此时n由3-1变为了2 test(2) n=2 test(2) – 第三步 不符合if判断条件 n=2 由下到上(从里到外)输出n的结果,就是 2 2 3 原来如此 将上面的案例代码改变一下 1234567891011121314151617package mainimport "fmt"func test(n int) &#123; if n &gt; 2 &#123; n-- test(n) &#125;else&#123; //增加了else判断分支 fmt.Println("n=", n) &#125;&#125;func main() &#123; test(4)&#125; 请问,输出结果是什么? 经过我掐指一算,n=2 是的,结果只是n=2 总结函数递归需要遵守的重要原则: 1) 执行一个函数时，就创建一个新的受保护的独立空间(新函数栈)2) 函数的局部变量是独立的，不会相互影响3) 递归必须向退出递归的条件逼近，否则就是无限递归，死龟了:)4) 当一个函数执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当函数执行完毕或者返回时，该函数本身也会被系统销毁 递归函数练习 给出一个整数n,求斐波那契数列中的第n位是什么 1234567891011121314151617package mainimport "fmt"// 计算斐波那契数,给出一个整数n(n为斐波那契数列中的第几位),输出第n位的数值func f(n int) int &#123; if n == 1 || n == 2 &#123; return 1 &#125; else &#123; return f(n-1) + f(n-2) &#125;&#125;func main() &#123; fmt.Println("f(3)=", f(3)) fmt.Println("f(5)=", f(5))&#125; 猴子吃桃子问题: 有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个!以后每天猴子都吃其中的一半，然后再多吃一个。当到第十天时，想再吃时(还没吃)，发现只有 1 个桃子了。问题:最初共多少个桃子? 思路分析: 第10 天只有一个桃子 第9天有几个桃子 = (第10天桃子数量 + 1) * 2 规律: 第 n 天的桃子数据 peach(n) = (peach(n+1) + 1) * 2 12345678910111213141516171819202122package mainimport "fmt"// - 有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个!以后每天猴子都吃其中的一半，然后// 再多吃一个。当到第十天时，想再吃时(还没吃)，发现只有 1 个桃子了。问题:最初共多少个桃子?// - 思路分析:// - 第10 天只有一个桃子// - 第9天有几个桃子 = (第10天桃子数量 + 1) * 2// - 规律: 第 n 天的桃子数据 peach(n) = (peach(n+1) + 1) * 2func peach(n int) int &#123; if n == 10 &#123; return 1 &#125; else &#123; return (peach(n+1) + 1) * 2 &#125;&#125;func main() &#123; fmt.Println("第一天的桃子数量为", peach(1))&#125; 函数的注意事项和细节1) 函数的形参列表可以是多个，返回值列表也可以是多个。2) 形参列表和返回值列表的数据类型可以是值类型和引用类型。3) 函数的命名遵循标识符命名规范，首字母不能是数字，首字母大写该函数可以被本包文件和其 它包文件使用，类似 public , 首字母小写，只能被本包文件使用，其它包文件不能使用，类似 privat4) 函数中的变量是局部的，函数外不生效5) 基本数据类型和数组默认都是值传递的，即进行值拷贝。在函数内修改，不会影响到原来的值。可以参考函数的调用机制6) 如果希望函数内的变量能修改函数外的变量(指的是默认以值传递的方式的数据类型)，可以传入变量的地址&amp;，函数内以指针的方式操作变量。从效果上看类似引用 。 1234567891011121314package mainimport "fmt"func test(n *int) &#123; *n = *n + 10 fmt.Println("n=", *n)&#125;func main() &#123; var n1 int = 20 test(&amp;n1) fmt.Println("n1=", n1)&#125; 结果为 12n= 30n1= 30 Go函数不支持函数重载 在 Go 中，函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用 12345678910111213141516package mainimport "fmt"func getSum(n1 int, n2 int) int &#123; return n1 + n2&#125;func main() &#123; a := getSum fmt.Printf("a的类型是%T, getSum的类型是%T \n", a, getSum) n1 := 10 n2 := 20 fmt.Println("n1+n2=", a(n1, n2))&#125; 函数既然是一种数据类型，因此在 Go 中，函数可以作为形参，并且调用 12345678910111213141516171819package mainimport "fmt"func getSum(n1 int, n2 int) int &#123; return n1 + n2&#125;// 下面的funvar表示函数的变量名,例如int的变量名是num1和num2func myFun(funvar func(int, int) int, num1 int, num2 int) int &#123; return funvar(num1, num2)&#125;func main() &#123; n1 := 10 n2 := 20 fmt.Println("n1+n2=", myFun(getSum, n1, n2))&#125; 为了简化数据类型定义，Go 支持自定义数据类型 基本语法: type 自定义数据类型名 数据类型 // 理解: 相当于一个别名 案例1: type myInt int // 这时 myInt 就等价 int 来使用了. 123456789101112131415package mainimport "fmt"func main() &#123; type myInt int var n1 myInt var n2 int n1 = 1 n2 = int(n1) //虽然能自定义,但是系统认为这是两个不同的变量类型 fmt.Println("n1=", n1, "n2=", n2)&#125; 案例2: 自定义函数类型 1234567891011121314151617181920package mainimport "fmt"func getSum(n1 int, n2 int) int &#123; return n1 + n2&#125;type myFunType func(int, int) int // 在刚才的代码上进行修改,增加此行func myFun(funvar myFunType, num1 int, num2 int) int &#123; // 直接使用myFunType类型定义funvar变量参数 return funvar(num1, num2)&#125;func main() &#123; n1 := 10 n2 := 20 fmt.Println("n1+n2=", myFun(getSum, n1, n2))&#125; 支持对函数返回值命名 1234567891011121314package mainimport "fmt"func getSumAndSub1(n1 int, n2 int) (sum int, sub int) &#123; sum = n1 + n2 sub = n1 - n2 return sum, sub&#125;func main() &#123; sum, sub := getSumAndSub1(2, 1) fmt.Printf("sum=%d, sub=%d \n", sum, sub)&#125; 使用 _ 标识符，忽略返回值 1234func main() &#123; sum, _ := getSumAndSub1(2, 1) fmt.Printf("sum=%d \n", sum)&#125; Go支持可变参数 12345678910111213141516package mainimport "fmt"func sum(n1 int, args ...int) int &#123; sum := n1 for i := 0; i &lt; len(args); i++ &#123; sum += args[i] &#125; return sum&#125;func main() &#123; result := sum(1, 2, 3, 4) fmt.Println("1+2+3+4=", result)&#125; init函数 每一个源文件都可以包含一个 init 函数，该函数会在 main 函数执行前，被 Go 运行框架调用，也 就是说 init 会在 main 函数前被调用。 1234567891011package mainimport "fmt"func init() &#123; fmt.Println("init()...")&#125;func main() &#123; fmt.Println("main()...")&#125; init函数的注意事项和细节 如果一个文件同时包含全局变量定义，init 函数和 main 函数，则执行的流程为: 全局变量定义 init函数 main 函数 12345678910111213141516171819package mainimport "fmt"// 定义全局变量var age = test()func test() int &#123; fmt.Println("test()...") return 1&#125;func init() &#123; fmt.Println("init()...")&#125;func main() &#123; fmt.Println("main... num=", age)&#125; 从上图可以看到,函数test()先被执行了,也就是说全局变量age首先被执行 init函数最主要的作用，就是完成一些初始化的工作 分析下图的执行顺序 匿名函数 Go 支持匿名函数，匿名函数就是没有名字的函数，如果我们某个函数只是希望使用一次，可以考 虑使用匿名函数，匿名函数也可以实现多次调用。 案例一 在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次。 123456789101112package mainimport "fmt"func main() &#123; // 直接调用,只能使用一次 result := func(n1 int, n2 int) int &#123; return n1 + n2 &#125;(10, 20) fmt.Println("n1+n2=", result)&#125; 案例二 将匿名函数赋给一个变量(函数变量)，再通过该变量来调用匿名函数 123456789101112131415161718192021package mainimport "fmt"func main() &#123; // 直接调用,只能使用一次 result := func(n1 int, n2 int) int &#123; return n1 + n2 &#125;(10, 20) fmt.Println("n1+n2=", result) // a的数据类型为函数类型,通过该变量来调用匿名函数 a := func(n1 int, n2 int) int &#123; return n1 + n2 &#125; res := a(20, 30) fmt.Println("res=", res)&#125; 全局匿名函数 如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序有效。 1234567891011121314151617package mainimport ( "fmt")// 声明全局变量var ( Fun = func(n1 int, n2 int) int &#123; return n1 * n2 &#125;)func main() &#123; res := Fun(3, 4) fmt.Println("n1 * n2 =", res)&#125; 闭包 闭包就是一个函数和与其相关的引用环境组合的一个整体(实体) 123456789101112131415161718package mainimport "fmt"func AddUpper() func(int) int &#123; var n int = 10 return func(x int) int &#123; n = n + x return n &#125;&#125;func main() &#123; f := AddUpper() fmt.Println(f(1)) fmt.Println(f(1)) fmt.Println(f(1))&#125; 我表示很懵逼啊,什么玩意儿??? 对上面代码的说明和总结 1) AddUpper 是一个函数，返回的数据类型是fun (int) int2) 闭包的说明: 返回的是一个匿名函数, 但是这个匿名函数引用到函数外的 n ,因此这个匿名函数就和n 形成一个整体，构成闭包3) 大家可以这样理解: 闭包是类,函数是操作，n 是字段。函数和它使用到 n 构成闭包。4) 当我们反复的调用f 函数时，因为 n 是初始化一次，因此每调用一次就进行累计。5) 我们要搞清楚闭包的关键，就是要分析出返回的函数它使用(引用)到哪些变量，因为函数和它引用到的变量共同构成闭包。 更改一下上面的代码 123456789101112131415161718192021package mainimport "fmt"func AddUpper() func(int) int &#123; var n int = 10 var str string = "hello" return func(x int) int &#123; n = n + x str += string(36) //ASCII码中,36对应的是 "$" fmt.Println("str=", str) return n &#125;&#125;func main() &#123; f := AddUpper() fmt.Println(f(1)) fmt.Println(f(1)) fmt.Println(f(1))&#125; 闭包的最佳实践 请编写一个程序,具体要求如下 编写一个函数 makeSuffix(suffix string)可以接收一个文件后缀名(比如.jpg)，并返回一个闭包 调用闭包，可以传入一个文件名，如果该文件名没有指定的后缀(比如.jpg) ,则返回文件名.jpg , 如果已经有.jpg 后缀，则返回原文件名。 要求使用闭包的方式完成 strings.HasSuffix , 该函数可以判断某个字符串是否有指定的后缀。 123456789101112131415161718192021222324252627package mainimport ( "fmt" "strings")// - 编写一个函数 makeSuffix(suffix string) 可以接收一个文件后缀名(比如.jpg)，并返回一个闭包// - 调用闭包，可以传入一个文件名，如果该文件名没有指定的后缀(比如.jpg) ,则返回 文件名.jpg , 如果已经有.jpg 后缀，则返回原文件名。// - 要求使用闭包的方式完成// - strings.HasSuffix , 该函数可以判断某个字符串是否有指定的后缀。func makeSuffix(suffix string) func(string) string &#123; return func(name string) string &#123; // 如果 name 没有指定后缀,则加上,否则就返回原来的名字 if !strings.HasSuffix(name, suffix) &#123; return name + suffix &#125; return name &#125;&#125;func main() &#123; f := makeSuffix(".jpg") fmt.Println("文件名处理后=", f("1")) fmt.Println("文件名处理后=", f("2.jpg"))&#125; defer 在函数中，程序员经常需要创建资源(比如:数据库连接、文件句柄、锁等) ，为了在函数执行完毕后，及时的释放资源，Go 的设计者提供 defer (延时机制)。 快速入门12345678910111213141516171819package mainimport "fmt"func sum(n1 int, n2 int) int &#123; // 当执行到defer时,暂时不执行,会将defer后面的语句压入到独立的栈(defer栈) // 当函数执行完毕后,再从defer栈,按照先入后出的方式出栈执行 defer fmt.Println("ok1 n1=", n1) defer fmt.Println("ok2 n2=", n2) res := n1 + n2 fmt.Println("ok3 res=", res) return res&#125;func main() &#123; res := sum(10, 20) fmt.Println("res=", res)&#125; 注意事项和细节1) 当 go 执行到一个 defer 时，不会立即执行 defer 后的语句，而是将 defer 后的语句压入到一个栈中[我为了讲课方便，暂时称该栈为 defer 栈], 然后继续执行函数下一个语句。2) 当函数执行完毕后，在从 defer 栈中，依次从栈顶取出语句执行(注:遵守栈先入后出的机制)3) 在 defer 将语句放入到栈时，也会将相关的值拷贝同时入栈。 看代码 12345678910111213141516171819202122package mainimport "fmt"func sum(n1 int, n2 int) int &#123; // 当执行到defer时,暂时不执行,会将defer后面的语句压入到独立的栈(defer栈) // 当函数执行完毕后,再从defer栈,按照先入后出的方式出栈执行 defer fmt.Println("ok1 n1=", n1) defer fmt.Println("ok2 n2=", n2) // 增加部分 n1++ // n1 = 11 n2++ // n2 = 21 res := n1 + n2 // res = 32 fmt.Println("ok3 res=", res) return res&#125;func main() &#123; res := sum(10, 20) fmt.Println("res=", res)&#125; 看执行结果 当执行两个defer语句的时候,这两行被放入了defer栈中,所以它并没有参与到下面的计算之中,等函数执行完毕后,才会根据先入后出的原则依次执行,所以我们会看到这样的结果 defer 的最佳实践 defer 最主要的价值是在，当函数执行完毕后，可以及时的释放函数创建的资源。 模拟代码: 123456func test() &#123; // 关闭文件资源 file = openfile(文件名) defer file.close() // 其他代码&#125; 使用defer的好处: 1) 在 golang 编程中的通常做法是，创建资源后，比如(打开了文件，获取了数据库的链接，或者是 锁资源)， 可以执行 defer file.Close() defer connect.Close()2) 在 defer 后，可以继续使用创建资源.3) 当函数完毕后，系统会依次从 defer 栈中，取出语句，关闭资源.4) 这种机制，非常简洁，程序员不用再为在什么时机关闭资源而烦心。 字符串常用系统函数统计字符串长度: len()12var str string = "Hello"fmt.Println("str len", len(str)) 字符串遍历123456str := "Hello北京"// 字符串遍历,同时处理有中文的问题 r := []rune(str)r := []rune(str)for i := 0; i&lt; len(r); i++ &#123; fmt.Printf("字符=%c \n", r[i])&#125; 字符串转整数123456n, err := strconv.Atoi("hello")if err != nil &#123; fmt.Println("转换错误", err)&#125;else&#123; fmt.Println("转成的结果是", n)&#125; 整数转字符串12str = strconv.Itoa(12345)fmt.Printf("str=%v, str=%T \n", str, str) 字符串转[]byte12var bytes = []byte("Hello go")fmt.Println("bytes=%v \n", bytes) []byte转字符串12str = string([]byte&#123;12,34,56&#125;)fmt.Printf("str=%v \n", str) 十进制转其它进制1234str = strconv.FormatInt(123, 2)fmt.Printf("123对应的二进制是:%v \n", str)str = strconv.FormatInt(123, 16)fmt.Printf("123对应的十六进制是:%v \n", str) 查找子串是否在指定的字符串中12b := strings.Contains("seafood", "foo")fmt.Printf("b=%v \n", b) 统计子串个数12num := strings.Count("ceheese", "e")fmt.Printf("num=%v \n", num) 不区分大小写的字符串比较123b = strings.EqualFold("abc", "Abc")fmt.Printf("b=%v \n", b) // truefmt.Println("结果", "abc" == "Abc") // false, 区分大小写 获取指定字符的索引123// 返回子串在字符串第一次出现的 index 值，如果没有返回-1index := strings.Index("NLT_abcabcabc", "abc") //4fmt.Printf("index=%v \n", index) 123// 返回子串在字符串最后一次出现的 index，如没有返回-1index := strings.LastIndex("go golang", "go") //3fmt.Printf("index=%v \n", index) 字符串的替换12345// strings.Replace("go go hello", "go", "go 语言", n) // n 可以指定你希望替换几个，如果 n=-1 表示全部替换str1 = "go go hello"str2 = strings.Replace(str1, "go", "北京", -1)fmt.Printf("str1=%v str2=%v \n", str1, str2) 分隔字符串123456// 按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组strArr := strings.Split("Hello,world,ok", ",")for i := 0; i &lt; len(strArr); i++ &#123; fmt.Printf("str[%v]=%v \n", i, strArr[i])&#125;fmt.Printf("strArr=%v \n", strArr) 大小写转换1234str = "golang Hello"str = strings.ToLower(str)str = strings.toUpper(str)fmt.Printf("str=%v \n", str) //golang hello 去除两边空格12str = strings.TrimSpace(" a b c d ")fmt.Printf("str=%v \n", str) 去除两遍指定字符1234str = strings.Trim("! a b c d! ", " !")fmt.Printf("str=%v \n", str)// 将字符串左边指定的字符去掉 : strings.TrimLeft("! hello! ", " !")// 将字符串右边指定的字符去掉 :strings.TrimRight("! hello! ", " !") 判断字符串开头/结束内容 判断字符串是否以指定的字符串开头: strings.HasPrefix(“ftp://192.168.10.1&quot;, “ftp”) //true 判断字符串是否以指定的字符串结束: strings.HasSuffix(“NLT_abc.jpg”, “abc”) //false 时间和日期相关函数 在编程中，程序员会经常使用到日期相关的函数，比如:统计某段代码执行花费的时间等等。 获取当前时间 12345678910111213package mainimport ( "fmt" "time")func main() &#123; //看看日期和时间相关函数和方法使用 //获取当前时间 now := time.Now() fmt.Printf("now=%v now-type=%T \n", now, now)&#125; 结果为 获取其他日期信息 12345678910111213141516171819202122package mainimport ( "fmt" "time")func main() &#123; //看看日期和时间相关函数和方法使用 //获取当前时间 now := time.Now() fmt.Printf("now=%v now-type=%T \n", now, now) //通过now可以获取到年月日时分秒 fmt.Printf("年=%v \n", now.Year()) fmt.Printf("月=%v \n", now.Month()) fmt.Printf("月=%v \n", int(now.Month())) fmt.Printf("日=%v \n", now.Day()) fmt.Printf("时=%v \n", now.Hour()) fmt.Printf("分=%v \n", now.Minute()) fmt.Printf("秒=%v \n", now.Second())&#125; 结果为 时间格式化输出 Printf 或者 Sprintf 123456//格式化输出//Printffmt.Printf("%d-%d-%d %d:%d:%d \n", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())//SPrintfdate := fmt.Sprintf("%d-%d-%d %d:%d:%d \n", now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second())fmt.Printf("date=%v", date) time.Format() 1234567// Format(),里面必须写成 2006-01-02 15:04:05 !fmt.Printf(now.Format("2006-01-02 15:04:05"))fmt.Println()fmt.Printf(now.Format("2006-01-02"))fmt.Println()fmt.Printf(now.Format("15:04:05"))fmt.Println() 时间的常量 12345678const ( Nanosecond Duration = 1 //纳秒 Microsecond = 1000 * Nanosecond //微秒 Millisecond = 1000 * Microsecond //毫秒 Second = 1000 * Millisecond //秒 Minute = 60 * Second //分钟 Hour = 60 * Minute //小时) 常量的作用: 在程序中可用于获取指定时间单位的时间，比如想得到 100 毫秒 1100 * time.Millisecond 也可以结合Sleep使用 1time.Sleep(time.Millisecond * 100) //等待0.1秒 时间戳 1fmt.Printf("unix时间戳=%v, unixnano时间戳=%v \n", now.Unix(), now.UnixNano()) 返回结果: unix时间戳=1659074372, unixnano时间戳=1659074372349450000 内置函数文档地址: https://studygolang.com/pkgdoc len: 用来求长度，比如string、array、slice、map、channel new: 用来分配内存，主要用来分配值类型，比如int、float32, struct…返回的是指针 new的使用12345678910111213141516package mainimport "fmt"func main() &#123; num1 := 100 fmt.Printf("num1的类型为%T, num1的值为%v, num1的地址为%v \n", num1, num1, &amp;num1) num2 := new(int) //*int //num2的类型%T =&gt; *int //num2的值 = 系统分配的地址 0xc0000140a8 //num2的地址%v = 系统分配的地址 0xc00000e030 //num2指向的值 = 100 *num2 = 100 fmt.Printf("num2的类型=%T, num2的值=%v, num2的地址=%v, num2指针指向的值=%v \n", num2, num2, &amp;num2, *num2)&#125; 结果为 num1的类型为int, num1的值为100, num1的地址为0xc0000140a0 num2的类型=*int, num2的值=0xc0000140a8, num2的地址=0xc00000e030, num2指针指向的值=100 make 用来分配内存，主要用来分配引用类型，比如channel、map、slice。 错误处理 Go 中可以抛出一个panic 的异常，然后在 defer 中通过 recover捕获这个异常，然后正常处理 defer+recover 处理错误12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "time")func test() &#123; //使用 defer + recover 来捕获和处理异常 defer func()&#123; err := recover() //recover()内置函数,可以捕获到异常 if err != nil &#123; //说明捕获到错误 fmt.Println("err=", err) //可以将错误信息通过邮箱发送给管理员 fmt.Println("发送邮件给管理员") &#125; &#125;() num1 := 10 num2 := 0 res := num1 / num2 fmt.Println("res=", res)&#125;func main() &#123; test() for &#123; fmt.Println("main()下面的代码...") time.Sleep(time.Second) &#125;&#125; 自定义错误 Go 程序中，也支持自定义错误， 使用 errors.New 和 panic 内置函数 1) errors.New(“错误说明”) , 会返回一个 error类型的值，表示一个错误2) panic 内置函数 ,接收一个 interface{} 类型的值(也就是任何值了)作为参数。可以接收 error 类型的变量，输出错误信息，并退出程序 1234567891011121314151617181920212223242526272829303132package mainimport ( "errors" "fmt")//函数去读取配置文件init.conf的信息//如果文件名传入不正确,我们就返回一个自定义的错误func readConf(name string) (err error) &#123; if name == "config.ini" &#123; //读取... return nil &#125; else &#123; //返回一个自定义错误 return errors.New("读取文件错误..") &#125;&#125;func test02() &#123; err := readConf("config2.ini") if err != nil &#123; //如果读取文件发送错误,panic就输出这个错误,并终止程序 panic(err) &#125; fmt.Println("test02继续执行...")&#125;func main() &#123; test02() fmt.Println("main下面的代码")&#125; 因为传入test02中的配置文件名为config2.ini,触发了if判断,所以panic已经输出并终止程序,所以不会看到下面的内容了 数组与切片数组 数组可以存放多个同一类型数据。数组也是一种数据类型，在 Go 中，数组是值类型。 快速入门 一个养鸡场有 6 只鸡，它们的体重分别是 3kg,5kg,1kg,3.4kg,2kg,50kg 。请问这六只鸡的总体重是多少?平均体重是多少? 请你编一个程序。使用数组解决! 12345678910111213141516171819202122232425package mainimport "fmt"func main() &#123; //1.定义一个数组 var hens [7]float64 //2.给数组的每个元素赋值,元素的下标是从0开始的 0-5 hens[0] = 3.0 hens[1] = 5.0 hens[2] = 1.0 hens[3] = 3.4 hens[4] = 2.0 hens[5] = 50.0 hens[6] = 150.0 //增加一只鸡...鸡你太美 //3.遍历数组求出总体重 totalWeight2 := 0.0 for i := 0; i &lt; len(hens); i++ &#123; totalWeight2 += hens[i] &#125; //4.求出平均体重 avgWeight2 := fmt.Sprintf("%.2f", totalWeight2/float64(len(hens))) fmt.Printf("totalWeight2=%v, avgWeight2=%v \n", totalWeight2, avgWeight2)&#125; 数组定义与内存布局 数组的定义 var 数组名 [数组大小]数据类型 example: ​ var a [5]int 数组的内存布局(重要) 1234567891011121314package mainimport "fmt"func main() &#123; var intArr [3]int //int占8个字节 //当我们定义完数组后,其实数组的各个元素有默认值 0 fmt.Println(intArr) intArr[0] = 10 intArr[1] = 20 intArr[2] = 30 fmt.Println(intArr) fmt.Printf("intArr的地址=%p, intArr[0]地址=%p, intArr[1]地址=%p, intArr[2]地址=%p \n", &amp;intArr, &amp;intArr[0], &amp;intArr[1], &amp;intArr[2])&#125; 对上图的总结:1) 数组的地址可以通过数组名来获取 &amp;intArr2) 数组的第一个元素的地址，就是数组的首地址,后面依次加n个字节3) 数组的各个元素的地址间隔是依据数组的类型决定，比如 int64 -&gt; 8, int32-&gt;4… 数组的使用 从终端循环输入5个成绩,保存到float64数组并输出 123456789101112131415161718package mainimport "fmt"func main() &#123; var score [5]float64 for i := 0; i &lt; len(score); i++ &#123; fmt.Printf("请输入第%d个元素的值 \n", i+1) fmt.Scanln(&amp;score[i]) &#125; //输出 for i := 0; i &lt; len(score); i++ &#123; fmt.Printf("score[%d]=%v \n", i, score[i]) &#125;&#125; 四种初始化数组的方式 1234567891011121314151617181920212223package mainimport "fmt"func main() &#123; //传统方式 var numArr01 [3]int = [3]int&#123;1, 2, 3&#125; fmt.Println("numArr01=", numArr01) //简化方式 var numArr02 = [3]int&#123;5, 6, 7&#125; fmt.Println("numArr02=", numArr02) //缺省方式 var numArr03 = [...]int&#123;8, 9, 10&#125; fmt.Println("numArr03=", numArr03) //缺省+索引方式 var numArr04 = [...]int&#123;1: 800, 0: 900, 2: 999&#125; fmt.Println("numArr04=", numArr04) //类型推导 strArr05 := [...]string&#123;1: "tom", 0: "jack", 2: "mary"&#125; fmt.Println("strArr05=", strArr05)&#125; 数组的遍历常规遍历见前面的数组的使用 for-range结构遍历 这是 Go 语言一种独有的结构，可以用来遍历访问数组的元素。 语法结构 for index, value := range array01 { ​ … } 案例 123456789101112131415161718package mainimport ( "fmt")func main() &#123; heroes := [...]string&#123;"宋江", "吴用", "卢俊义"&#125; for i, v := range heroes &#123; fmt.Printf("i=%v, v=%v \n", i, v) fmt.Printf("heroes[%d]=%v \n", i, heroes[i]) &#125; for _, v := range heroes &#123; fmt.Printf("元素的值=%v \n", v) &#125;&#125; 数组的注意事项和细节 数组是多个相同类型数据的组合,一个数组一旦声明/定义了,其长度是固定的, 不能动态变化 var arr []int 这时 arr 就是一个 slice 切片，切片后面专门讲解，不急哈. 数组中的元素可以是任何数据类型，包括值类型和引用类型，但是不能混用。 数组创建后，如果没有赋值，有默认值(零值) 数值类型数组:默认值为 0 字符串数组: 默认值为 “” bool 数组: 默认值为 false 使用数组的步骤 1 声明数组并开辟空间 2 给数组各个元素赋值(默认零值) 3 使用数组 数组的下标是从 0 开始的 数组下标必须在指定范围内使用，否则报 panic:数组越界，比如 var arr [5]int 则有效下标为 0-4 Go的数组属值类型，在默认情况下是值传递，因此会进行值拷贝。数组间不会相互影响(就是说如果一个函数直接更改数组中的某一个值,只要不直接修改地址的值,原值就不会改变) 123456func test(arr [3]int) &#123; arr[0] = 88&#125;arr := [3]int&#123;11, 22, 33&#125;test(arr) 如想在其它函数中，去修改原来的数组，可以使用引用传递(指针方式) 123456func test(arr *[3]int) &#123; *arr[0] = 88&#125;arr := [3]int&#123;11, 22, 33&#125;test(&amp;arr) 长度是数组类型的一部分，在传递函数参数时 需要考虑数组的长度 数组应用案例 案例一 创建一个 byte 类型的 26 个元素的数组，分别 放置’A’-‘Z‘。使用 for 循环访问所有元素并打印出来。 提示:字符数据运算 ‘A’+1 -&gt; ‘B’ 12345678910111213141516package mainimport ( "fmt")func main() &#123; var myChars [26]byte for i := 0; i &lt; 26; i++ &#123; myChars[i] = 'A' + byte(i) &#125; for i := 0; i &lt; 26; i++ &#123; fmt.Printf("%c ", myChars[i]) &#125;&#125; 案例二 请求出一个数组的最大值，并得到对应的下标 1234567891011121314151617package mainimport "fmt"func main() &#123; var intArr = [...]int&#123;1, -1, 9, 90, 11, 33&#125; maxVal := intArr[0] maxValIndex := 0 for i := 1; i &lt; len(intArr); i++ &#123; if maxVal &lt; intArr[i] &#123; maxVal = intArr[i] maxValIndex = i &#125; &#125; fmt.Printf("maxVal=%v, maxValIndex=%v \n", maxVal, maxValIndex)&#125; 案例三 请求出一个数组的和和平均值。for-range 123456789101112131415package mainimport "fmt"func main() &#123; var intArr = [...]int&#123;1, -1, 9, 90, 11, 33&#125; //求数组的平均值 sum := 0 for _, value := range intArr &#123; sum += value &#125; fmt.Printf("sum=%v, 平均值为=%v \n", sum, float64(sum)/float64(len(intArr)))&#125; 案例四 要求:随机生成五个数，并将其反转打印 12345678910111213141516171819202122232425262728293031package mainimport ( "fmt" "math/rand" "time")//随机生成5个数,rand.Intn()函数//当我们得到随机数后,就放到一个int数组中//反转打印,交换的次数是 len / 2, 倒数第一个和第一个元素交换,倒数第二个和第二个元素交换func main() &#123; var intArr [5]int len := len(intArr) rand.Seed(time.Now().UnixNano()) for i := 0; i &lt; len; i++ &#123; intArr[i] = rand.Intn(100) // 0 &lt;= n &lt; 100 &#125; fmt.Println("交换前~=", intArr) //反转打印,交换的次数是 len / 2 temp := 0 for i := 0; i &lt; len/2; i++ &#123; temp = intArr[len-1-i] intArr[len-1-i] = intArr[i] intArr[i] = temp &#125; fmt.Println("交换后~=", intArr)&#125; 切片 先看一个需求:我们需要一个数组用于保存学生的成绩，但是学生的个数是不确定的，请问怎么办?解决方案 =&gt; 使用切片。 基本介绍1) 切片的英文是 slice2) 切片是数组的一个引用，因此切片是引用类型，在进行传递时，遵守引用传递的机制。3) 切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度 len(slice)都一样。4) 切片的长度是可以变化的，因此切片是一个可以动态变化数组。5) 切片定义的基本语法:var 切片名 []类型 快速入门1234567891011121314151617package mainimport "fmt"func main() &#123; var intArr [5]int = [...]int&#123;1, 22, 33, 66, 99&#125; //声明一个切片 //slice := intArr[1:3] //1.slice就是切片名 //2.intArr[1:3] 表示 slice 引用到intArr这个数组 //3.引用intArr数组的起始下标为1,最后的下标为3 slice := intArr[1:3] fmt.Println("intArr", intArr) fmt.Println("slice 的元素是:", slice) fmt.Println("slice的元素个数=", len(slice)) fmt.Println("slice 的容量=", cap(slice)) //切片的容量可以动态变化,根据目前切片的大小自动分配调整&#125; 切片在内存中形式(重要) 为了让大家更加深入的理解切片，我们画图分析一下切片在内存中是如何布局的，这个是一个非常重要的知识点:(以前面的案例来分析) 画出前面的切片内存布局 总结: slice 是一个引用类型,改变切片中的内容,对应的数组内容也会发生改变,因为指向的是同一个地址 slice 从底层来说，其实就是一个数据结构(struct 结构体) 12345type slice struct &#123; ptr *[2]int len int cap int&#125; 如果更改切片的内容,对应的数组内容也会发生改变,因为指向的是同一个地址 123456789101112131415161718package mainimport "fmt"func main() &#123; var intArr [5]int = [...]int&#123;1, 22, 33, 66, 99&#125; //更改前 slice := intArr[1:3] fmt.Println("更改前的intArr=", intArr) fmt.Println("更改后的slice=", slice) //更改后 slice[1] = 100 //将切片的第一个元素的值改为 100 fmt.Println("更改后的intArr=", intArr) fmt.Println("更改后的slice=", slice)&#125; 切片的使用方式一 第一种方式:定义一个切片，然后让切片去引用一个已经创建好的数组，比如前面的案例就是这样的。 12var intArr [5]int = [...]int&#123;1, 22, 33, 66, 99&#125; //创建数组slice := intArr[1:3] //切片引用 方式二 通过 make 来创建切片. 基本语法: var 切片名 []type = make([]type, len, [cap]) 参数说明: type: 就是==数据类型== len : 大小 *cap : *指定切片容量(可选， 如果你分配了 cap,则要求 cap&gt;=len) 12345678910111213package mainimport "fmt"func main() &#123; var slice []float64 = make([]float64, 5, 10) slice[1] = 10 slice[2] = 20 fmt.Println(slice) fmt.Println("slice的size=", len(slice)) fmt.Println("slice的cap=", cap(slice))&#125; 小结: 1) 通过 make 方式创建切片可以指定切片的大小和容量2) 如果没有给切片的各个元素赋值，那么就会使用默认值[int , float=&gt; 0, string =&gt;””, bool =&gt;false]3) 通过 make 方式创建的切片对应的数组是由 make 底层维护，对外不可见，即只能通过 slice 去访问各个元素. 方式三 定义一个切片，直接就指定具体数组，使用原理类似 make 的方式 1234567891011package mainimport "fmt"func main() &#123; var strSlice []string = []string&#123;"tom", "jack", "mary"&#125; fmt.Println("strSlice=", strSlice) fmt.Println("strSlice size=", len(strSlice)) fmt.Println("strSlice cap=", cap(strSlice))&#125; 方式一与方式二的区别 切片的遍历切片的遍历和数组一样，也有两种方式: for 循环常规方式遍历 for-range 结构遍历切片 1234567891011121314151617181920package mainimport ( "fmt")func main() &#123; var arr [5]int = [...]int&#123;10, 20, 30, 40, 50&#125; slice := arr[1:4] //常规遍历 for i := 0; i &lt; len(slice); i++ &#123; fmt.Printf("slice[%v]=%v \n", i, slice[i]) &#125; //for-range遍历 for i, v := range slice &#123; fmt.Printf("i=%v, v=%v \n", i, v) &#125;&#125; 切片的注意事项和细节1) 切片初始化时 var slice = arr[startIndex:endIndex] 说明:从 arr 数组下标为 startIndex，取到 下标为 endIndex 的元素(不含 arr[endIndex])。2) 切片初始化时，仍然不能越界。范围在 [0-len(arr)] 之间，但是可以动态增长. var slice = arr[0:end] 可以简写 var slice = arr[:end] var slice = arr[start:len(arr)] 可以简写: var slice = arr[start:] var slice = arr[0:len(arr)] 可以简写: var slice = arr[:] cap是一个内置函数，用于统计切片的容量，即最大可以存放多少个元素。 切片定义完后，还不能使用，因为本身是一个空的，需要让其引用到一个数组，或者 make 一个空间供切片来使用 切片可以继续切片 用 append 内置函数，可以对切片进行动态追加 12345678910111213141516package mainimport ( "fmt")func main() &#123; var slice []int = []int&#123;100, 200, 300&#125; //通过append直接给slice追加具体的元素 slice = append(slice, 400, 500, 600) fmt.Println("slice=", slice) //通过append将切片slice追加给slice,没错,我追加我自己 slice = append(slice, slice...) fmt.Println("slice=", slice)&#125; 切片的拷贝操作 切片使用 copy 内置函数完成 拷贝，举例说明 12345678910111213package mainimport ( "fmt")func main() &#123; var slice []int = []int&#123;100, 200, 300&#125; var sliceCopy = make([]int, 10) copy(sliceCopy, slice) fmt.Println("sliceCopy=", sliceCopy) fmt.Println("slice=", slice)&#125; 切片是引用类型，所以在传递时，遵守引用传递机制。看两段代码，并分析底层原理 string 和 slice string底层是一个byte数组，因此string也可以进行切片处理案例演示: 1234567891011package mainimport "fmt"func main() &#123; //string底层是一个byte数组,因此string也可以进行切片处理 str := "hello@atguigu" //使用切片获取到 atguigu slice := str[6:] fmt.Println("slice=", slice)&#125; string 和切片在内存的形式，以 “abcd” 画出内存示意图 string 是不可变的，也就说不能通过 str[0] = &#39;z&#39; 方式来修改字符串 如果需要修改字符串，可以先将 string -&gt; []byte / 或者 []rune -&gt; 修改 -&gt; 重写转成 string 123456789101112131415161718192021package mainimport "fmt"func main() &#123; //string底层是一个byte数组,因此string也可以进行切片处理 str := "hello@atguigu" //字符串不能直接修改 arr1 := []byte(str) arr1[0] = 'z' str = string(arr1) fmt.Println("str=", str) //上面的写法不能赋值中文 //下面的可以 arr2 := []rune(str) arr2[0] = '北' str = string(arr2) fmt.Println("str=", str)&#125; 排序和查找冒泡排序 1234567891011121314151617181920212223242526272829package mainimport "fmt"func BubbleSort(arr *[5]int) &#123; fmt.Println("排序前arr=", (*arr)) temp := 0 //冒泡排序 for i := 0; i &lt; len(*arr)-1; i++ &#123; for j := 0; j &lt; len(*arr)-1-i; j++ &#123; if (*arr)[j] &gt; (*arr)[j+1] &#123; temp = (*arr)[j] (*arr)[j] = (*arr)[j+1] (*arr)[j+1] = temp &#125; &#125; &#125; fmt.Println("排序后arr=", *arr)&#125;func main() &#123; //定义数组 arr := [5]int&#123;24, 69, 80, 57, 13&#125; //将数组传递给一个函数,完成排序 BubbleSort(&amp;arr) fmt.Println("main arr=", arr)&#125; 查找顺序查找 案例 有一个数列:白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王 猜数游戏:从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】 123456789101112131415161718192021222324252627282930313233343536373839package mainimport "fmt"func main() &#123; // 有一个数列:白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王 // 猜数游戏:从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】 names := [4]string&#123;"白眉鹰王", "金毛狮王", "紫衫龙王", "青翼蝠王"&#125; var heroName = "" fmt.Println("请输入要查找的人名: ") fmt.Scanln(&amp;heroName) //顺序查找: 方式一 // for i := 0; i &lt; len(names); i++ &#123; // if heroName == names[i] &#123; // fmt.Printf("找到%v, 下标为%v \n", heroName, i) // break // &#125; else if i == (len(names) - 1) &#123; // fmt.Printf("没有找到%v \n", heroName) // &#125; // &#125; //顺序查找: 方式二(推荐) index := -1 for i := 0; i &lt; len(names); i++ &#123; if heroName == names[i] &#123; index = i //将找到的值对应的下标赋给 index break &#125; &#125; if index != -1 &#123; fmt.Printf("找到%v, 下标%v \n", heroName, index) &#125; else &#123; fmt.Println("没有找到", heroName) &#125;&#125; 二分查找 二分查找就是查找每次将值与中位数进行对比,不断进行判断缩小范围 思路分析 代码实现 12345678910111213141516171819202122232425262728293031package mainimport "fmt"func BinaryFind(arr *[7]int, leftIndex int, rightIndex int, findVal int) &#123; // 判断 leftIndex 是否大于 rightIndex if leftIndex &gt; rightIndex &#123; fmt.Println("找不到") return &#125; // 先找到中间的下标 middle := (leftIndex + rightIndex) / 2 if (*arr)[middle] &gt; findVal &#123; // 说明我们要查找的数,应该在 leftIndex - middle-1 BinaryFind(arr, leftIndex, middle-1, findVal) &#125; else if (*arr)[middle] &lt; findVal &#123; // 说明我们要查找的数,应该在 middle+1 - rightIndex BinaryFind(arr, middle+1, rightIndex, findVal) &#125; else &#123; // 找到了 fmt.Printf("找到了,下标为%v\n", middle) &#125;&#125;func main() &#123; arr := [7]int&#123;1, 8, 15, 39, 128, 333, 1111&#125; //BinaryFind(&amp;arr, 0, len(arr)-1, 39) BinaryFind(&amp;arr, 0, len(arr)-1, 1112)&#125; 二维数组快速入门 案例 12345678910111213141516171819package mainimport "fmt"func main() &#123; // 声明二维数组 var arr [4][6]int //赋初值 arr[1][2] = 1 arr[2][1] = 2 arr[2][3] = 3 for i := 0; i &lt; 4; i++ &#123; for j := 0; j &lt; 6; j++ &#123; fmt.Print(arr[i][j], " ") &#125; fmt.Println() &#125;&#125; 使用方式 方式一: 先声明再赋值 语法: var 数组名 [大小][大小]类型 比如: var arr [2][3]int ， 再赋值。 使用演示 二维数组在内存的存在形式(重点) 12345678910111213141516171819202122232425262728293031323334//详细的解释一下上面的图片//比如arr2[2]//因为是arr2[2],所以就会在一个区域内划分出两个指针//这两个指针分别对应第一行和第二行//也就是说,arr2[0]的起始地址 = arr2[0][0]//arr2[1]的起始地址 = arr2[1][0]package mainimport "fmt"func main() &#123; // 声明二维数组 var arr [4][6]int //赋初值 arr[1][2] = 1 arr[2][1] = 2 arr[2][3] = 3 for i := 0; i &lt; 4; i++ &#123; for j := 0; j &lt; 6; j++ &#123; fmt.Print(arr[i][j], " ") &#125; fmt.Println() &#125; var arr2 [2][3]int fmt.Println(arr2) fmt.Printf("arr2[0]的地址%p\n", &amp;arr2[0]) fmt.Printf("arr[1]的地址%p\n", &amp;arr2[1]) fmt.Printf("arr2[0][0]的地址%p\n", &amp;arr2[0][0]) fmt.Printf("arr2[1][0]的地址%p\n", &amp;arr2[1][0])&#125; 从上图可以看出,arr2[0]与arr2[1]两个地址相差了24个字节(底层都是使用16进制,满16进一位,150+24=168) 而且arr2[0]与arr2[0][0]的地址是相同的 方式二: 直接初始化 声明: 1var 数组名 [大小][大小]类型 = [大小][大小]类型&#123;&#123;初值..&#125;,&#123;初值..&#125;&#125; 赋值(有默认值，比如 int 类型的就是 0) 12var arr3 [2][3]int = [2][3]int&#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;fmt.Println("arr3=", arr3) 说明: 二维数组在声明时也对应有四种写法[和一维数组类似] 1234var 数组名 大小类型 = 大小类型&#123;&#123;初值..&#125;,&#123;初值..&#125;&#125; var 数组名 大小类型 = ...类型&#123;&#123;初值..&#125;,&#123;初值..&#125;&#125; var 数组名 = 大小类型&#123;&#123;初值..&#125;,&#123;初值..&#125;&#125;var 数组名 = ...类型&#123;&#123;初值..&#125;,&#123;初值..&#125;&#125; 二维数组的遍历1234567891011121314151617181920212223package mainimport "fmt"func main() &#123; var arr = [2][3]int&#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125; //普通遍历 for i := 0; i &lt; len(arr); i++ &#123; for j := 0; j &lt; len(arr[i]); j++ &#123; fmt.Printf("%v\t", arr[i][j]) &#125; fmt.Println() &#125; //for-range遍历二维数组 for i, v := range arr &#123; for j, v2 := range v &#123; fmt.Printf("arr[%v][%v]=%v \t", i, j, v2) &#125; fmt.Println() &#125;&#125; map map 是 key-value 数据结构，又称为字段或者关联数组。类似其它编程语言的集合，在编程中是经常使用到。 map的声明基本语法1var map 变量名 map[keytype]valuetype key 可以是什么类型 golang 中的 map，的 key 可以是很多种类型，比如 bool, 数字，string, 指针, channel , 还可以是只 包含前面几个类型的接口, 结构体, 数组 通常 ==key== 为 int 、string 注意: slice, map 还有 function 不可以，因为这几个没法用 == 来判断 valuetype 可以是什么类型 valuetype 的类型和 key 基本一样，这里我就不再赘述了 ==通常为:== 数字(整数,浮点数), string, map, struct map 声明的举例1234var a map[string]stringvar a map[string]intvar a map[int]stringvar a map[string]map[string]string 注意: 声明是不会分配内存的，初始化需要 make ，分配内存后才能赋值和使用。 案例演示1234567891011121314package mainimport "fmt"func main() &#123; var a map[string]string //在使用map前,需要先make,make的作用就是给map分配数据空间 a = make(map[string]string, 10) a["no1"] = "宋江" a["no2"] = "吴用" a["no1"] = "武松" a["no3"] = "吴用" fmt.Println(a)&#125; 对上面代码的说明: 1) map在使用前一定要make2) map的key是不能重复，如果重复了，则以最后这个key-value为准3) map的value是可以相同的.4) map 的 key-value 是无序5) make内置函数数目 map的使用 方式一 1234567891011//第一种方式var a map[string]stringa = make(map[string]string, 10)a["no1"] = "宋江"a["no2"] = "吴用"a["no1"] = "武松"a["no3"] = "吴用"fmt.Println(a)//返回结果map[no1:武松 no2:吴用 no3:吴用] 方式二 123456789//第二种方式cities := make(map[string]string)cities["no1"] = "北京"cities["no2"] = "天津"cities["no3"] = "上海"fmt.Println(cities)//返回结果map[no1:北京 no2:天津 no3:上海] 方式三 1234567891011//第三种方式heroes := map[string]string&#123; "hero1": "宋江", "hero2": "卢俊义", "hero3": "吴用",&#125;heroes["heros"] = "林冲"fmt.Println("heroes=", heroes)//返回结果heroes= map[hero1:宋江 hero2:卢俊义 hero3:吴用 heros:林冲] 案例 演示一个 key-value 的 value 是 map 的案例 比如:我们要存放 3 个学生信息, 每个学生有 name 和 sex 信息 思路: map[string]map[string]string 123456789101112131415161718192021package mainimport "fmt"func main() &#123; studentMap := make(map[string]map[string]string) studentMap["stu01"] = make(map[string]string, 3) studentMap["stu01"]["name"] = "tom" studentMap["stu01"]["sex"] = "男" studentMap["stu01"]["address"] = "北京长安街~" studentMap["stu02"] = make(map[string]string, 3) studentMap["stu02"]["name"] = "mary" studentMap["stu02"]["sex"] = "女" studentMap["stu02"]["address"] = "上海黄浦江~" fmt.Println(studentMap) fmt.Println(studentMap["stu02"]) fmt.Println(studentMap["stu02"]["address"])&#125; map的增删改查map的增加和更新 map增加和更新: map[“key”] = value //如果 key 还没有，就是增加，如果 key 存在就是修改。 123456789101112131415package mainimport "fmt"func main() &#123; cities := make(map[string]string) cities["no1"] = "北京" cities["no2"] = "天津" cities["no3"] = "上海" fmt.Println(cities) //因为 no3 这个key已经存在,因此下面的这句话就是修改 cities["no3"] = "上海~" fmt.Println(cities)&#125; map的删除 说明: delete(map，”key”) ，delete 是一个内置函数，如果 key 存在，就删除该 key-value,如果 key 不存在， 不操作，但是也不会报错 12345678910111213141516171819202122package mainimport "fmt"func main() &#123; cities := make(map[string]string) cities["no1"] = "北京" cities["no2"] = "天津" cities["no3"] = "上海" fmt.Println(cities) //因为 no3 这个key已经存在,因此下面的这句话就是修改 cities["no3"] = "上海~" fmt.Println(cities) //演示删除 delete(cities, "no1") fmt.Println(cities) //当delete指定的key不存在时,删除不会操作,也不会报错 delete(cities, "no4") fmt.Println(cities)&#125; 细节说明 如果我们要删除 map 的所有 key ,没有一个专门的方法一次删除，可以遍历一下 key, 逐个删除 或者 map = make(...)，make 一个新的，让原来的成为==垃圾==，被 gc 回收 方式一: 遍历删除 123for k, _ := range caties &#123; delete(cities, k) &#125; 方式二: 重新make暴力删除 12cities = make(map[string]string)fmt.Println(cities) map的查找123456789101112131415161718192021222324252627282930313233package mainimport "fmt"func main() &#123; cities := make(map[string]string) cities["no1"] = "北京" cities["no2"] = "天津" cities["no3"] = "上海" fmt.Println(cities) //因为 no3 这个key已经存在,因此下面的这句话就是修改 cities["no3"] = "上海~" fmt.Println(cities) //演示删除 delete(cities, "no1") fmt.Println(cities) //当delete指定的key不存在时,删除不会操作,也不会报错 delete(cities, "no4") fmt.Println(cities) //演示map的查找 val, ok := cities["no1"] if ok &#123; fmt.Printf("有no1 key 值为%v\n", val) &#125; else &#123; fmt.Printf("没有no1 key\n") &#125; cities = make(map[string]string) fmt.Println(cities)&#125; map的遍历 案例演示相对复杂的 map 遍历:该 map 的 value 又是一个 map 说明:map 的遍历使用 for-range 的结构遍历 123456789101112131415package mainimport "fmt"func main() &#123; cities := make(map[string]string) cities["no1"] = "北京" cities["no2"] = "天津" cities["no3"] = "上海" fmt.Println(cities) for k, v := range cities &#123; fmt.Printf("k=%v v=%v\n", k, v) &#125;&#125; 遍历一个复杂的结构 123456789101112131415161718192021222324252627282930package mainimport "fmt"func main() &#123; studentMap := make(map[string]map[string]string) studentMap["stu01"] = make(map[string]string, 3) studentMap["stu01"]["name"] = "tom" studentMap["stu01"]["sex"] = "男" studentMap["stu01"]["address"] = "北京长安街~" studentMap["stu02"] = make(map[string]string, 3) studentMap["stu02"]["name"] = "mary" studentMap["stu02"]["sex"] = "女" studentMap["stu02"]["address"] = "上海黄浦江~" //for-range遍历一个结构复杂的map for k1, v1 := range studentMap &#123; fmt.Println("k1=", k1) for k2, v2 := range v1 &#123; fmt.Printf("\t k2=%v v2=%v \n", k2, v2) &#125; fmt.Println() &#125; // fmt.Println(studentMap) // fmt.Println(studentMap["stu02"]) // fmt.Println(studentMap["stu02"]["address"])&#125; map切片 切片的数据类型如果是 map，则我们称为 slice of map，map 切片，这样使用则 map 个数就可以动态变化了。 案例 要求:使用一个 map 来记录 monster 的信息 name 和 age, 也就是说一个 monster 对应一个 map,并且妖怪的个数可以动态的增加=&gt;map 切片 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport "fmt"func main() &#123; //演示map切片的使用 //1.声明一个map切片 var monsters []map[string]string monsters = make([]map[string]string, 2) //2.增加一个妖怪的信息 if monsters[0] == nil &#123; monsters[0] = make(map[string]string) monsters[0]["name"] = "牛魔王" monsters[0]["age"] = "500" &#125; if monsters[1] == nil &#123; monsters[1] = make(map[string]string, 2) monsters[1]["name"] = "玉兔精" monsters[1]["age"] = "400" &#125; //下面这个写法越界 // if monsters[1] == nil &#123; // monsters[1] = make(map[string]string, 2) // monsters[1]["name"] = "狐狸精" // monsters[1]["age"] = "400" // &#125; //这里我们需要使用到切片的append函数,可以动态的增加monster //1.先定义一个monster信息 newMonster := map[string]string&#123; "name" : "新妖怪-火云邪神", "age" : "200", &#125; monsters = append(monsters, newMonster) fmt.Println(monsters)&#125; map的排序 golang中没有一个专门的方法针对map的key进行排序 golang中的map默认是无序的，注意也不是按照添加的顺序存放的，你每次遍历，得到的输出可能不一样. golang中map的排序，是先将key进行排序，然后根据key值遍历输出即可 1234567891011121314151617181920212223242526272829303132333435package mainimport ( "fmt" "sort")func main() &#123; //map的排序 map1 := make(map[int]int, 10) map1[10] = 100 map1[1] = 13 map1[4] = 56 map1[8] = 90 fmt.Println(map1) //如果按照map的key的顺序进行排序输出 //1.先将map的key放入到切片中 //2.对切片排序 //3.遍历切片,然后按照key来输出map的值 var keys []int for k, _ := range map1 &#123; keys = append(keys, k) &#125; //排序 sort.Ints(keys) fmt.Println(keys) for _, k := range keys &#123; fmt.Printf("map1[%v]=%v \n", k, map1[k]) &#125;&#125; map的使用细节 map是引用类型，遵守引用类型传递的机制，在一个函数接收map，修改后，会直接修改原来的 map map 的容量达到后，再想 map 增加元素，会自动扩容，并不会发生 panic，也就是说 map 能动态的增长键值对(key-value) map 的 value 也经常使用 struct 类型，更适合管理复杂的数据(比前面 value 是一个 map 更好),比如 value 为 Student 结构体 练习123456789101112131415161718192021222324252627282930package mainimport "fmt"func modifyUser(users map[string]map[string]string, name string) &#123; //判断 users 中是否有 name //v , ok := users[name] if users[name] != nil &#123; //有这个用户 users[name]["pwd"] = "888888" &#125; else &#123; //没有这个用户 users[name] = make(map[string]string, 2) users[name]["pwd"] = "888888" users[name]["nickname"] = "昵称~" + name //示意 &#125;&#125;func main() &#123; users := make(map[string]map[string]string, 10) users["smith"] = make(map[string]string, 2) users["smith"]["pwd"] = "999999" users["smith"]["nickname"] = "小花猫" modifyUser(users, "tom") modifyUser(users, "mary") modifyUser(users, "smith") fmt.Println(users)&#125; 面向对象编程 激动人心的面向对象编程他来喽~ 说明 Golang也支持面向对象编程(OOP)，但是和传统的面向对象编程有区别，并不是纯粹的面向对象语言。所以我们说 Golang 支持面向对象编程特性是比较准确的。 Golang没有类(class)，Go语言的结构体(struct)和其它编程语言的类(class)有同等的地位，你可以理解 Golang 是基于 struct 来实现 OOP 特性的。 Golang面向对象编程非常简洁，去掉了传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的 this 指针等等 Golang仍然有面向对象编程的继承，封装和多态的特性，只是实现的方式和其它OOP语言不一样，比如继承 :Golang 没有 extends 关键字，继承是通过匿名字段来实现。 Golang面向对象(OOP)很优雅，OOP本身就是语言类型系统(typesystem)的一部分，通过接口(interface)关联，耦合性低，也非常灵活。后面会充分体会到这个特点。也就是说在 Golang 中面向接口编程是非常重要的特性。 结构体快速入门123456789101112131415161718192021222324252627package mainimport "fmt"func main() &#123; //定义一个Cat结构体,将Cat的各个字段/属性信息,放入到Cat结构体进行管理 type Cat struct &#123; Name string Age int Color string Hobby string &#125; //创建一个Cat的变量 var cat1 Cat cat1.Name = "cat1" cat1.Age = 3 cat1.Color = "white" cat1.Hobby = "eat" fmt.Println("cat1=", cat1) fmt.Println("cat1的详细信息如下:") fmt.Println("name=", cat1.Name) fmt.Println("Age=", cat1.Age) fmt.Println("Color=", cat1.Color) fmt.Println("hobby=", cat1.Hobby)&#125; 结构体的声明 结构体是一个值类型,并不是引用类型(引用类型指的是通过地址找到值),这一点需要注意 1234type 结构体名称 struct &#123; field1 type field2 type &#125; 字段/属性 基本介绍 1) 从概念或叫法上看: 结构体字段 = 属性 = field (即授课中，统一叫字段)2) 字段是结构体的一个组成部分，一般是基本数据类型、数组,也可是引用类型。比如我们前面定义猫结构体的Name string 就是属性 注意事项和细节说明 字段声明语法同变量，示例:字段名 字段类型 字段的类型可以为: 基本类型、数组或引用类型 在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值(默认值)，规则同前面讲的一样: 布尔类型是 false ，数值是 0 ，字符串是 &quot;&quot;。 数组类型的默认值和它的元素类型相关，比如 score [3]int 则为[0, 0, 0] 指针，slice，和 map 的零值都是 nil ，即还没有分配空间。 演示案例 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport "fmt"type Person struct &#123; Name string Age int scores [5]float64 ptr *int //指针 slice []int //切片 map1 map[string]string //map&#125;func main() &#123; //定义结构体变量 var p1 Person fmt.Println(p1) if p1.ptr == nil &#123; fmt.Println("ptr is nil") &#125; if p1.map1 == nil &#123; fmt.Println("map1 is nil") &#125; if p1.slice == nil &#123; fmt.Println("slice is nil") &#125; //使用slice,再次说明,一定要make p1.slice = make([]int, 10) p1.slice[0] = 100 //使用map,一定要先make p1.map1 = make(map[string]string) p1.map1["key1"] = "tom~" fmt.Println(p1)&#125; 不同结构体变量的字段是独立，互不影响，一个结构体变量字段的更改，不影响另外一个, 结构体是值类型。 创建结构体变量和访问结构体字段 方式一: 直接声明 12var person Person//上面已经演示过 方式二: { } 123p2 := Person&#123;"poker", "26"&#125;//p2.Name = "tom"//p2.Age = 26 方式三: &amp; 123456789101112131415//var person *Person = new (Person)var p3 *Person = new (Person)/*因为p3是一个指针,因此标准的给字段赋值方式(*p3).Name = "smith" 也可以这样写=&gt; p3.Name = "smith"原因: go的设计者,为了程序员使用方便,底层会对 p3.Name = "smith" 进行处理会给 p3 加上取值运算 (*p3).Name = "smith"*/(*p3).Name= "smith"p3.Name = "john"(*p3).Age = 30p3.Age = 100fmt.Println(*p3) 方式四: &amp;{ } 123456789//var person *Person = &amp;Person&#123;&#125;var p4 *Person = &amp;Person&#123;&#125;(*p4).Name = "scott"p4.Name = "scott~"(*p4).Age = 88p4.Age = 10fmt.Println(*p4) 说明 第3 种和第 4 种方式返回的是结构体指针。 结构体指针访问字段的标准方式应该是: (*结构体指针).字段名 ，比如 (*person).Name = “tom” 但 go 做了一个简化，也支持结构体指针.字段名, 比如 person.Name = “tom”。更加符合程序员使用的习惯，go 编译器底层对 person.Name 做了转化 (*person).Name。 struct 类型的内存分配机制 前面提到过,struct结构体的类型为值类型,当我们拷贝struct的一个实例时,会划分出一个新的地址空间存放值,所以两者不会影响 1234567891011121314151617181920212223242526package mainimport "fmt"type Person struct &#123; Name string Age int scores [5]float64 ptr *int //指针 slice []int //切片 map1 map[string]string //map&#125;func main() &#123; var p1 Person p1.Name = "tom" p1.Age = 10 //复制实例p1 var p2 Person = p1 fmt.Println("p2.Age=", p2.Age) fmt.Println("p2.Name=", p2.Name) //修改p2的值,观察p1的值是否会被修改 p2.Name = "jack" fmt.Printf("p2.Name=%v, p1.Name=%v\n", p2.Name, p1.Name)&#125; 从上面的结果来看,p1与p2根本毫无关联,谁修改谁都不会变化 那么如何做才能产生关联呢?请看下面的代码! 1234567891011121314151617181920212223242526package mainimport "fmt"type Person struct &#123; Name string Age int scores [5]float64 ptr *int //指针 slice []int //切片 map1 map[string]string //map&#125;func main() &#123; var p1 Person p1.Name = "tom" p1.Age = 10 var p2 *Person = &amp;p1 fmt.Println("p2.Age=", (*p2).Age) fmt.Println("p2.Name=", p2.Name) p2.Name = "jack" fmt.Printf("p2.Name=%v, p1.Name=%v\n", p2.Name, p1.Name) fmt.Printf("p1的地址为%p\n", &amp;p1) fmt.Printf("p2的地址为%p, p2的值为%p\n", &amp;p2, p2)&#125; 可以看到,p1.Name与p2.Name同时发生了变化,因为两者指向了同一个内存地址 结构体的注意事项与细节说明 结构体的所有字段在内存中是连续的 123456789101112131415161718192021222324252627282930313233package mainimport "fmt"type Point struct &#123; x int y int&#125;//矩形的左上角和右下角,两个点的坐标type Rect struct &#123; leftUp, rightDown Point&#125;type Rect2 struct &#123; leftUp, rightDown *Point&#125;func main() &#123; r1 := Rect&#123;Point&#123;1, 2&#125;, Point&#123;3, 4&#125;&#125; //r1有四个int, 在内存中是连续分布 //打印地址 fmt.Printf("r1.ledtUp.x 地址=%p, r1.leftUp.y 地址=%p, r1.rightDown.x 地址=%p, r1.rr1.rightDown.yr1 地址=%p \n", &amp;r1.leftUp.x, &amp;r1.leftUp.y, &amp;r1.rightDown.x, &amp;r1.rightDown.y) //r2有两个 *Point 类型, 这两个*Point类型的本身地址也是连续的 //但是他们指向的地址不一定是连续 r2 := Rect2&#123;&amp;Point&#123;10, 20&#125;, &amp;Point&#123;30, 40&#125;&#125; fmt.Printf("r2.leftUp 本身地址=%p, r2.rightDown 本身地址=%p \n", &amp;r2.leftUp, &amp;r2.rightDown) //他们指向的地址不一定是连续,这个要看系统在运行时是如何分配的 fmt.Printf("r2.leftUp 指向地址=%p, r2.rightDown 指向地址=%p \n", r2.leftUp, r2.rightDown)&#125; 可以看到,上面结果中第一行和第二行的地址是连续的,但是第三行并不一定是连续的,a0和b0在十六进制上差了16个字节 结构体是用户单独定义的类型，和其它类型进行转换时需要有完全相同的字段(名字、个数和类型) 123456789101112131415161718package mainimport "fmt"type A struct &#123; Num int&#125;type B struct &#123; Num int&#125;func main() &#123; var a A var b B a = A(b) //强制转换类型,但是结构体的字段必须要保证一样(名字 个数 类型) fmt.Println(a, b)&#125; 结构体进行 type 重新定义(相当于取别名)，Golang 认为是新的数据类型，但是相互间可以强转 123456789101112131415161718package mainimport "fmt"type Student struct &#123; Name string Age int&#125;type Stu Studentfunc main() &#123; var s1 Student var s2 Stu //s1 = s2, 这是不对的 s2 = Stu(s1) //这样是正确的 fmt.Println(s1, s2)&#125; struct 的每个字段上，可以写上一个 tag, 该 tag 可以通过反射机制获取，常见的使用场景就是序列化和反序列化。 123456789101112131415161718192021222324package mainimport ( "encoding/json" "fmt")type Monster struct &#123; Name string `json:"name"` //打标签,注意冒号后面不要加空格 Age int `json:"age"` Skill string `json:"skill"`&#125;func main() &#123; monster := Monster&#123;"牛魔王", 500, "芭蕉扇"&#125; //将monster变量序列化为 json 格式字符串 //json.Marshal 函数中使用反射,这个讲解反射时,再详细介绍 jsonStr, err := json.Marshal(monster) if err != nil &#123; fmt.Println("json 处理错误", err) &#125; fmt.Println("jsonStr", jsonStr) //输出byte fmt.Println("jsonStr", string(jsonStr)) //byte转字符串&#125; 方法 在某些情况下，我们要需要声明(定义)方法。比如 Person 结构体:除了有一些字段外( 年龄，姓名..),Person 结构体还有一些行为比如:可以说话、跑步…, 通过学习，还可以做算术题。这时就要用方法才能完成。 Golang 中的方法是作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此自定义类型，都可以有方法，而不仅仅是 struct。 小试牛刀12345678type A struct &#123; Num int&#125;func (a A) test()&#123; fmt.Println(a.Num)&#125; 说明 func (a A) test() {} 表示 A 结构体有一方法，方法名为 test (a A) 体现 test 方法是和 A 类型绑定的 案例123456789101112131415161718package mainimport "fmt"type Person struct &#123; Name string&#125;//给Person类型绑定一个方法func (p Person) test() &#123; fmt.Println("test() name=", p.Name)&#125;func main() &#123; var p Person p.Name = "tom" p.test() //调用方法&#125; 说明 1) test方法和Person类型绑定2) test 方法只能通过 Person 类型的变量来调用，而不能直接调用，也不能使用其它类型变量来调用3) func (p Person) test() {}… p 表示哪个 Person 变量调用，这个 p 就是它的副本, 这点和函数传参非 常相似。4) p 这个名字，有程序员指定，不是固定, 比如修改成 person 也是可以 方法快速入门 给 Person 结构体添加 speak 方法,输出 xxx 是一个好人 123func (p Person) speak() &#123; fmt.Println(p.Name, "是一个好人")&#125; 给 Person 结构体添加 jisuan 方法,可以计算从 1+..+1000 的结果, 说明方法体内可以函数一样， 进行各种运算 1234567func (p Person) jisuan() &#123; res := 0 for i := 1; i &lt;= 1000; i++ &#123; res += i &#125; fmt.Println(p.Name, "计算的结果是=", res)&#125; 给 Person 结构体 jisuan2 方法,该方法可以接收一个数 n，计算从 1+…+n 的结果 1234567func (p Person) jisuan2(n int) &#123; res := 0 for i := 1; i &lt;= n; i++ &#123; res += i &#125; fmt.Println(p.Name, "计算的结果是=", res)&#125; 给 Person 结构体添加 getSum 方法,可以计算两个数的和，并返回结果 123func (p Person) getSum(n1 int, n2 int) int &#123; return n1 + n2&#125; main主体调用方法 123456789func main() &#123; var p Person p.Name = "tom" p.test() //调用方法 p.jisuan() p.jisuan2(50) res := p.getSum(10, 20) fmt.Println("res=", res)&#125; 方法的调用和传参机制原理 方法的调用和传参机制和函数基本一样，不一样的地方是方法调用时，会将调用方法的变量，当做实参也传递给方法。下面我们举例说明。 案例一==画出前面 getSum 方法的执行过程+说明== 说明:1) 在通过一个变量去调用方法时，其调用机制和函数一样2) 不一样的地方时，变量调用方法时，该变量本身也会作为一个参数传递到方法(如果变量是值类型，则进行值拷贝，如果变量是引用类型，则进行地址拷贝) 案例二请编写一个程序，要求如下:1) 声明一个结构体 Circle, 字段为 radius2) 声明一个方法 area 和 Circle 绑定，可以返回面积。3) 提示: 画出 area 执行过程+说明 123456789101112131415161718package mainimport "fmt"type Circle struct &#123; radius float64&#125;func (c Circle) area() float64 &#123; return 3.14 * c.radius * c.radius&#125;func main() &#123; var c Circle c.radius = 4.0 res := c.area() fmt.Println("面积是=", res)&#125; 方法的声明(定义)1234func (recevier type) methodName(参数列表) (返回值列表) &#123; 方法体 return 返回值&#125; 参数说明: 1) 参数列表:表示方法输入2) recevier type : 表示这个方法和 type 这个类型进行绑定，或者说该方法作用于 type 类型3) receiver type : type 可以是结构体，也可以其它的自定义类型4) receiver : 就是 type 类型的一个变量(实例)，比如 :Person 结构体 的一个变量(实例)5) 返回值列表:表示返回的值，可以多个6) 方法主体:表示为了实现某一功能代码块7) return 语句不是必须的。 方法的注意事项和细节 结构体类型是值类型，在方法调用中，遵守值类型的传递机制，是值拷贝传递方式 如程序员希望在方法中，修改结构体变量的值，可以通过结构体指针的方式来处理(这里可能不是太好理解) 12345678910111213141516171819202122232425262728293031package mainimport "fmt"type Circle struct &#123; radius float64&#125;//为了提高效率,通常我们方法和结构体的指针类型绑定func (c *Circle) area2() float64 &#123; //因为c是指针,因此我们标准的访问其字段的方式是(*c) //return 3.14 * (*c).radius * (*c).radius // (*c).radius 等价 c.radius c.radius = 10 //这里为指针,直接指向main中的c的地址,相当于直接将main中c.radius的地址对应的值给修改掉了 //下面使用 fmt 打印指针c的地址, 验证func方法中指针c是否指向main中c的地址 fmt.Printf("func方法中的c.radius =%v, c的地址为%p \n", c.radius, c) //这里取c的地址时,不需要加 &amp; 符号,因为c本身就是一个指针 return 3.14 * c.radius * c.radius&#125;func main() &#123; var c Circle c.radius = 7.0 //此时会在内存中生成一个地址 //res2 := (&amp;c).area2() //编译器底层做了优化 (&amp;c).area2() 等价 c.area() //因为编译器会自动的给加上 &amp;c fmt.Printf("调用方法前, main中c.radius =%v, c的地址为%p \n", c.radius, &amp;c) res2 := c.area2() //调用方法 //当执行上面方法的时候,指针是指向方法中的c的地址,而不是main中的 c.radius = 7.0 fmt.Printf("调用方法后, main中c.radius =%v, c的地址为%p \n", c.radius, &amp;c) fmt.Println("面积是=", res2)&#125; Golang中的方法作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此自定义类型， 都可以有方法, 而不仅仅是 struct， 比如 int , float32 等都可以有方法 123456789101112131415161718192021package mainimport "fmt"type integer intfunc (i integer) print() &#123; fmt.Println("i=", i)&#125;//编写一个方法,可以改变i的值func (i *integer) change() &#123; *i = *i + 1&#125;func main() &#123; var i integer = 10 i.print() i.change() fmt.Println("i=", i)&#125; 方法的访问范围控制的规则，和函数一样。方法名首字母小写，只能在本包访问; 方法首字母大写，可以在本包和其它包访问。 如果一个类型实现了 String()这个方法，那么 fmt.Println 默认会调用这个变量的 String()进行输出 12345678910111213141516171819202122232425package mainimport "fmt"type Student struct &#123; Name string Age int&#125;//给 *String 实现方法String()func (stu *Student) String() string &#123; str := fmt.Sprintf("Name=[%v], Age=[%v]", stu.Name, stu.Age) return str&#125;func main() &#123; //定义一个Student变量 stu := Student&#123; Name: "tom", Age: 20, &#125; //如果实现了 *Student 类型的 String 方法,就会自动调用 fmt.Println(&amp;stu)&#125; 方法练习 编写结构体(MethodUtils)，编程一个方法，方法不需要参数，在方法中打印一个 10*8 的矩形，在 main 方法中调用该方法。 123456789101112131415161718192021package mainimport "fmt"type MethodUtils struct &#123; //字段&#125;func (mu MethodUtils) Print() &#123; for i := 1; i &lt;= 10; i++ &#123; for j := 1; j &lt;= 8; j++ &#123; fmt.Print("*") &#125; fmt.Println() &#125;&#125;func main() &#123; var mu MethodUtils mu.Print()&#125; 编写一个方法，提供 m 和 n 两个参数，方法中打印一个 m*n 的矩形 123456789101112131415161718192021package mainimport "fmt"type MethodUtils struct &#123; //字段&#125;func (mu MethodUtils) Print(m int, n int) &#123; for i := 1; i &lt;= m; i++ &#123; for j := 1; j &lt;= n; j++ &#123; fmt.Print("*") &#125; fmt.Println() &#125;&#125;func main() &#123; var mu MethodUtils mu.Print(4, 10)&#125; 定义小小计算器结构体(Calcuator)，实现加减乘除四个功能 实现形式 实现形式1: 分四个方法完成: 实现形式2: 用一个方法搞定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( "fmt")type Calcuator struct &#123; Num1 float64 Num2 float64&#125;//实现形式1func (calcuator *Calcuator) getSum() float64 &#123; return calcuator.Num1 + calcuator.Num2&#125;func (calcuator *Calcuator) getSub() float64 &#123; return calcuator.Num1 - calcuator.Num2&#125;//实现形式2func (calcuator *Calcuator) getRes(operator byte) float64 &#123; res := 0.0 switch operator &#123; case '+': res = calcuator.Num1 + calcuator.Num2 case '-': res = calcuator.Num1 - calcuator.Num2 case '*': res = calcuator.Num1 * calcuator.Num2 case '/': res = calcuator.Num1 / calcuator.Num2 default: fmt.Println("运算符输入有误!") &#125; return res&#125;func main() &#123; c := Calcuator &#123; Num1 : 10, Num2 : 20, &#125; //使用方式二计算乘法 res := c.getRes('*') fmt.Println("res=", res)&#125; 方法和函数区别 调用方式不一样 函数的调用方式: 函数名(实参列表) 方法的调用方式: 变量.方法名(实参列表) 对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然 1234567891011121314151617181920212223package mainimport ( "fmt")type Person struct &#123; Name string&#125;func test01(p Person) &#123; fmt.Println(p.Name)&#125;func test02(p *Person) &#123; fmt.Println(p.Name)&#125;func main() &#123; p := Person&#123;"tom"&#125; test01(p) test02(&amp;p)&#125; 对于方法(如 struct 的方法)，接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以 12345678910111213141516171819202122232425262728293031323334package mainimport ( "fmt")type Person struct &#123; Name string&#125;func (p Person) test03() &#123; p.Name = "jack" fmt.Println("test03()=", p.Name)&#125;func (p *Person) test04() &#123; p.Name = "mary" fmt.Println("test04()=", p.Name)&#125;func main() &#123; p := Person&#123;"tom"&#125; test01(p) test02(&amp;p) p.test03() fmt.Println("main() p.Name=", p.Name) (&amp;p).test03() //形式上是传入地址,但是本质仍然是值拷贝 fmt.Println("main() p.name=", p.Name) (&amp;p).test04() fmt.Println("main() p.Name=", p.Name) p.test04() //等价 (&amp;p).test04, 从形式上是传入值类型,但是本质上仍然是地址拷贝&#125; 总结: 1) 不管调用形式如何，真正决定是值拷贝还是地址拷贝，看这个方法是和哪个类型绑定.2) 如果是和值类型，比如 (p Person) , 则是值拷贝， 如果和指针类型，比如是 (p *Person) 则 是地址拷贝。 面向对象编程应用实例步骤1) 声明(定义)结构体，确定结构体名2) 编写结构体的字段3) 编写结构体的方法 学生案例1) 编写一个 Student 结构体，包含 name、gender、age、id、score 字段，分别为 string、string、int、 int、float64 类型。2) 结构体中声明一个 say 方法，返回 string 类型，方法返回信息中包含所有字段值。3) 在 main 方法中，创建 Student 结构体实例(变量)，并访问 say 方法，并将调用结果打印输出 1234567891011121314151617181920212223242526272829303132333435package mainimport "fmt"/*1) 编写一个 Student 结构体，包含 name、gender、age、id、score 字段，分别为 string、string、int、 int、float64 类型。2) 结构体中声明一个 say 方法，返回 string 类型，方法返回信息中包含所有字段值。3) 在 main 方法中，创建 Student 结构体实例(变量)，并访问 say 方法，并将调用结果打印输出*/type Student struct &#123; Name string Gender string Age int Id int Score float64&#125;func (stu *Student) say() string &#123; res := fmt.Sprintf("Name=%v\nGender=%v\nAge=%v\nId=%v\nScore=%v", stu.Name, stu.Gender, stu.Age, stu.Id, stu.Score) return res&#125;func main() &#123; var stu = Student&#123; "poker", "man", 26, 01, 99.99, &#125; res := stu.say() fmt.Println(res)&#125; 创建结构体变量时指定字段值方式一1234567891011121314151617181920212223242526272829package mainimport "fmt"type Stu struct &#123; Name string Age int&#125;func main() &#123; //方式一 //在创建结构体变量时,就直接指定字段的值 var stu1 = Stu&#123;"小明", 19&#125; //stu1, 结构体数据空间 stu2 := Stu&#123;"小明", 20&#125; //在创建结构体变量时, 把字段名和字段值写在一起, 就不会依赖字段的定义顺序 var stu3 = Stu&#123; Name: "jack", Age: 20, &#125; stu4 := Stu&#123; Age: 30, Name: "mary", &#125; fmt.Println(stu1, stu2, stu3, stu4)&#125; 方式二12345678910111213//方式二, 返回结构体的指针类型var stu5 *Stu = &amp;Stu&#123;"小王", 29&#125;stu6 := &amp;Stu&#123;"小王", 39&#125;var stu7 = &amp;Stu &#123; Name : "小李", Age : 49,&#125;stu8 := &amp;Stu &#123; Age : 59, Name : "小李~",&#125;fmt.Println(*stu5, *stu6, *stu7, *stu8) 工厂模式 Golang 的结构体没有构造函数，通常可以使用工厂模式来解决这个问题。 为什么会有工厂模式例如现在有一个结构体 123456package modeltype Student struct &#123; Name string Age int&#125; 因为这个结构体的名称的首字母为大写,所以我们可以在外部进行调用 123456789101112131415package mainimport ( "fmt" "golang_study/object_oriented_programming/factory/model")func main() &#123; var stu model.Student stu.Name = "tom" stu.Age = 26 fmt.Println(stu)&#125; 那么如果这个结构体的名称首字母为小写时,其他文件就没有办法进行引用 123456package modeltype student struct &#123; //s为小写,外部无法调用 Name string Age int&#125; 所以就出现了”工厂模式” 工厂模式的使用方法 案例 model外部模块 12345678910111213141516package modeltype student struct &#123; Name string Score float64&#125;//因为student结构体首字母是小写,因此只能在model使用//我们通过工厂模式来解决func NewStudent(n string, s float64) *student &#123; return &amp;student&#123; Name: n, Score: s, &#125;&#125; main主函数进行调用 12345678910111213package mainimport ( "fmt" "golang_study/object_oriented_programming/factory/model")func main() &#123; var stu = model.NewStudent("tom", 99.8) fmt.Println(*stu) //stu接受的是NewStudent返回的一个指针 fmt.Println("name", stu.Name, " score=", stu.Score)&#125; type student struct { Name string Score float64 } 如果这一段代码中的Score改为score的话,外部同样无法进行调用,这里我们应该如何处理呢? model外部模块 1234567891011121314151617181920package modeltype student struct &#123; Name string score float64&#125;//因为student结构体首字母是小写,因此只能在model使用//我们通过工厂模式来解决func NewStudent(n string, s float64) *student &#123; return &amp;student&#123; Name: n, score: s, &#125;&#125;func (s *student) GetScore() float64 &#123; return s.score&#125; main主函数 12345678910111213package mainimport ( "fmt" "golang_study/object_oriented_programming/factory/model")func main() &#123; var stu = model.NewStudent("tom", 99.8) fmt.Println(*stu) //stu接受的是NewStudent返回的一个指针 fmt.Println("name", stu.Name, " score=", stu.GetScore())&#125; 面向对象编程思想-抽象 我们在前面去定义一个结构体时候，实际上就是把一类事物的共有的属性(字段)和行为(方法)提取出来，形成一个物理模型(结构体)。这种研究问题的方法称为抽象。 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package mainimport "fmt"type Account struct &#123; AccountNo string Pwd string Balance float64&#125;//方法//存款func (account *Account) SaveMoney(money float64, pwd string) &#123; //检查输入的密码是否正确 if pwd != account.Pwd &#123; fmt.Println("你输入的密码不正确") return &#125; //价差输入的存款金额是否正确 if money &lt;= 0 &#123; fmt.Println("输入的金额不正确!") return &#125; account.Balance += money fmt.Println("存款成功")&#125;//取款func (account *Account) WithDraw(money float64, pwd string) &#123; //检查输入的密码是否正确 if pwd != account.Pwd &#123; fmt.Println("你输入的密码不正确") return &#125; //价差输入的取款金额是否正确 if money &lt;= 0 || money &gt; account.Balance &#123; fmt.Println("输入的金额不正确!") return &#125; account.Balance -= money fmt.Println("取款成功")&#125;//查询func (account *Account) QueryMoney(pwd string) &#123; if pwd != account.Pwd &#123; fmt.Println("你输入的密码不正确") return &#125; fmt.Printf("你的账号为%v 余额为%v \n", account.AccountNo, account.Balance)&#125;func main() &#123; var account = Account&#123; AccountNo: "gs123456", Pwd: "123456", Balance: 100.0, &#125; accountNo := "" passwd := "" fmt.Println("请输入账户: ") fmt.Scanf("%v", &amp;accountNo) fmt.Println("请输入密码: ") fmt.Scanf("%v", &amp;passwd) //创建变量 i ,当 i == 1 时,程序退出 i := 0 //相当于 while 循环 for &#123; //判断用户名与密码是否正确 if accountNo == account.AccountNo &amp;&amp; passwd == account.Pwd &#123; operate := "" fmt.Println("===============================") fmt.Println("请选择您要进行的操作:[1|2|3|q] ") fmt.Println("1. 查询余额\n2. 存款操作\n3. 取款操作\nq. 退出") fmt.Println("===============================") fmt.Scanf("%v", &amp;operate) switch operate &#123; case "1": account.QueryMoney(account.Pwd) case "2": money := 0.00 fmt.Println("请输入存款金额: ") fmt.Scanf("%v", &amp;money) account.SaveMoney(money, account.Pwd) case "3": money := 0.00 fmt.Println("请输入取款金额: ") fmt.Scanf("%v", &amp;money) account.WithDraw(money, account.Pwd) case "q": fmt.Println("欢迎您下次光临~") i = 1 //退出循环 default: fmt.Println("请输入正确的选项!") &#125; &#125; else &#123; fmt.Println("您输入的账户或密码错误!") break &#125; if i == 1 &#123; break &#125; &#125;&#125; 测试 面向对象编程三大特性-封装 Golang 仍然有面向对象编程的继承，封装和多态的特性，只是实现的方式和其它 OOP 语言不一样，下面我们一一进行详细的讲解 Golang 的三大特性是如何实现的。 封装(encapsulation)就是把抽象出的字段和对字段的操作封装在一起,数据被保护在内部,程序的其它包只有通过被授权的操作(方法),才能对字段进行操作 封装的好处1) 隐藏实现细节2) 提可以对数据进行验证，保证安全合理(Age) 如何实现封装1) 对结构体中的属性进行封装2) 通过方法，包实现封装 封装的步骤1) 将结构体、字段(属性)的首字母小写(不能导出了，其它包不能使用，类似 private)2) 给结构体所在包提供一个工厂模式的函数，首字母大写。类似一个构造函数。3) 提供一个首字母大写的 Set 方法(类似其它语言的 public)，用于对属性判断并赋值 1234func (var 结构体类型名) SetXxx(参数列表) (返回值列表) &#123; //加入数据验证的业务逻辑 var.字段 = 参数 &#125; 提供一个首字母大写的 Get 方法(类似其它语言的 public)，用于获取属性的值 123func (var 结构体类型名) GetXxx() &#123; return var.age;&#125; 快速入门案例 请大家看一个程序(person.go),不能随便查看人的年龄,工资等隐私，并对输入的年龄进行合理的验证。设计: model 包(person.go) main 包(main.go 调用 Person 结构体) model外部模块 12345678910111213141516171819202122232425262728293031323334353637package modelimport "fmt"type person struct &#123; Name string age int salary float64&#125;//写一个工厂模式的函数,相当于构造函数func NewPerson(name string) *person &#123; return &amp;person&#123; Name: name, &#125;&#125;//为了访问age和sal 我们编写一对 Setxxx 的方法和Getxxx的方法func (p *person) SetAge(age int) &#123; if age &gt; 0 &amp;&amp; age &lt; 150 &#123; p.age = age &#125; else &#123; fmt.Println("年龄范围不正确!") &#125;&#125;func (p *person) GetAge() int &#123; return p.age&#125;func (p *person) SetSalary(salary float64) &#123; p.salary = salary&#125;func (p *person) GetSalary() float64 &#123; return p.salary&#125; main 1234567891011121314package mainimport ( "fmt" "golang_study/object_oriented_programming/FengZhuang/01/model")func main() &#123; p := model.NewPerson("poker") p.SetAge(26) p.SetSalary(10000.0) fmt.Println(p) fmt.Println("Name=", p.Name, "age=", p.GetAge(), "salary=", p.GetSalary())&#125; 练习案例 1) 创建程序,在 model 包中定义 Account 结构体:在 main 函数中体会 Golang 的封装性。 2) Account结构体要求具有字段:账号(长度在6-10之间)、余额(必须&gt;20)、密码(必须是六 3) 通过 SetXxx 的方法给 Account 的字段赋值。(同学们自己完成 4) 在 main 函数中测试 model外部模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package modelimport "fmt"type account struct &#123; accountNo string pwd string balance float64&#125;func NewAccount(accountNo string, pwd string, balance float64) *account &#123; //对输入的内容进行判断 if len(accountNo) &lt; 6 || len(accountNo) &gt; 10 &#123; fmt.Println("账号的长度不正确!") return nil &#125; if len(pwd) != 6 &#123; fmt.Println("账号的密码长度不正确!") return nil &#125; if balance &lt; 20 &#123; fmt.Println("余额的数目不正确!") &#125; return &amp;account&#123; accountNo: accountNo, pwd: pwd, balance: balance, &#125;&#125;//方法//存款func (account *account) SaveMoney(money float64, pwd string) &#123; //检查输入的密码是否正确 if pwd != account.pwd &#123; fmt.Println("你输入的密码不正确") return &#125; //价差输入的存款金额是否正确 if money &lt;= 0 &#123; fmt.Println("输入的金额不正确!") return &#125; account.balance += money fmt.Println("存款成功")&#125;//取款func (account *account) WithDraw(money float64, pwd string) &#123; //检查输入的密码是否正确 if pwd != account.pwd &#123; fmt.Println("你输入的密码不正确") return &#125; //价差输入的取款金额是否正确 if money &lt;= 0 || money &gt; account.balance &#123; fmt.Println("输入的金额不正确!") return &#125; account.balance -= money fmt.Println("取款成功")&#125;//查询func (account *account) QueryMoney(pwd string) &#123; if pwd != account.pwd &#123; fmt.Println("你输入的密码不正确") return &#125; fmt.Printf("你的账号为%v 余额为%v \n", account.accountNo, account.balance)&#125; main 12345678910111213141516package mainimport ( "fmt" "golang_study/object_oriented_programming/FengZhuang/02/model")func main() &#123; //创建一个 account 变量 account := model.NewAccount("jzh11111", "000000", 40) if account != nil &#123; fmt.Println("创建成功=", account) &#125; else &#123; fmt.Println("创建失败") &#125;&#125; 面向对象编程三大特性-继承为什么使用继承 通过一个案例来说明 model外部模块 12345678910111213141516171819202122232425package mainimport ( "golang_study/object_oriented_programming/JICheng/01/model")func main() &#123; var pupil = &amp;model.Pupil&#123; Name: "tom", Age: 10, &#125; pupil.Testing() pupil.SetScore(90) pupil.ShowInfo() var graduate = &amp;model.Graduate&#123; Name: "tom", Age: 10, &#125; graduate.Testing() graduate.SetScore(90) graduate.ShowInfo()&#125; main 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package modelimport "fmt"//编写一个学生考试系统//小学生type Pupil struct &#123; Name string Age int Score int&#125;//显示他的成绩func (p *Pupil) ShowInfo() &#123; fmt.Printf("学生名=%v 年龄=%v 成绩=%v \n", p.Name, p.Age, p.Score)&#125;func (p *Pupil) SetScore(score int) &#123; //业务判断 p.Score = score&#125;func (p *Pupil) Testing() &#123; fmt.Println("小学生正在考试中...")&#125;//大学生type Graduate struct &#123; Name string Age int Score int&#125;//显示他的成绩func (p *Graduate) ShowInfo() &#123; fmt.Printf("学生名=%v 年龄=%v 成绩=%v \n", p.Name, p.Age, p.Score)&#125;func (p *Graduate) SetScore(score int) &#123; //业务判断 p.Score = score&#125;func (p *Graduate) Testing() &#123; fmt.Println("大学生正在考试中...")&#125; 对上面代码的总结 1) Pupil 和 Graduate 两个结构体的字段和方法几乎，但是我们却写了两份相同的代码，代码复用性不 强2) 出现代码冗余，而且代码不利于维护，同时也不利于功能的扩展。3) 解决方法: 通过继承方式来解决 继承的介绍 继承可以解决代码复用,让我们的编程更加靠近人类思维。 当多个结构体存在相同的属性(字段)和方法时,可以从这些结构体中抽象出结构体(比如刚才的Student),在该结构体中定义这些相同的属性和方法。 其它的结构体不需要重新定义这些属性(字段)和方法，只需嵌套一个 Student 匿名结构体即可 也就是说: 在 Golang 中，如果一个 struct 嵌套了另一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，从而实现了继承特性。 嵌套匿名结构体的基本语法12345678type Goods struct &#123; Name string Price int&#125;type Book struct &#123; Goods //这里就是嵌套匿名结构体 Goods Writer string&#125; 快速入门案例model外部函数 123456789101112131415161718192021222324252627282930313233343536373839package modelimport "fmt"//编写一个学生考试系统//实现继承type Student struct &#123; Name string Age int Score int&#125;//显示他的成绩func (p *Student) ShowInfo() &#123; fmt.Printf("学生名=%v 年龄=%v 成绩=%v \n", p.Name, p.Age, p.Score)&#125;func (p *Student) SetScore(score int) &#123; //业务判断 p.Score = score&#125;//小学生type Pupil struct &#123; Student&#125;func (p *Pupil) Testing() &#123; fmt.Println("小学生正在考试中...")&#125;//大学生type Graduate struct &#123; Student&#125;func (p *Graduate) Testing() &#123; fmt.Println("大学生正在考试中...")&#125; main 12345678910111213141516171819202122package mainimport ( "golang_study/object_oriented_programming/JICheng/01/model")func main() &#123; var pupil = &amp;model.Pupil&#123;&#125; pupil.Student.Name = "tom" pupil.Student.Age = 10 pupil.Testing() pupil.Student.SetScore(90) pupil.Student.ShowInfo() var graduate = &amp;model.Graduate&#123;&#125; graduate.Student.Name = "jack" graduate.Student.Age = 11 graduate.Testing() graduate.Student.SetScore(90) graduate.Student.ShowInfo()&#125; 继承的深入讨论 结构体可以使用嵌套匿名结构体所有的字段和方法，即:首字母大写或者小写的字段、方法，都可以使用 12345678910111213141516171819202122232425262728package mainimport "fmt"type A struct &#123; Name string age int&#125;func (a *A) SayOk() &#123; fmt.Println("A SayOk", a.Name)&#125;func (a *A) Hello() &#123; fmt.Println("A Hello", a.Name)&#125;type B struct &#123; A&#125;func main() &#123; var b B b.A.Name = "tom" b.A.age = 19 b.A.SayOk() b.A.Hello()&#125; 匿名结构体字段访问可以简化 12345678910111213func main() &#123; var b B b.A.Name = "tom" b.A.age = 19 b.A.SayOk() b.A.Hello() //上面的写法可以进行简化 b.Name = "jack" b.age = 20 b.SayOk() b.Hello()&#125; 对上面代码的总结: (1) 当我们直接通过 b 访问字段或方法时，其执行流程如下比如 b.Name(2) 编译器会先看 b 对应的类型有没有 Name, 如果有，则直接调用 B 类型的 Name 字段(3) 如果没有就去看 B 中嵌入的匿名结构体 A 有没有声明 Name 字段，如果有就调用,如果没有继续查找..如果都找不到就报错 当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport "fmt"type A struct &#123; Name string age int&#125;func (a *A) SayOk() &#123; fmt.Println("A SayOk", a.Name)&#125;func (a *A) Hello() &#123; fmt.Println("A Hello", a.Name)&#125;type B struct &#123; A&#125;func (a *B) SayOk() &#123; fmt.Println("B SayOk", a.Name)&#125;func (a *B) Hello() &#123; fmt.Println("B Hello", a.Name)&#125;func main() &#123; var b B b.A.Name = "tom" b.A.age = 19 b.A.SayOk() b.A.Hello() //测试就近原则 b.Name = "poker" b.age = 26 b.SayOk() b.Hello()&#125; 结构体嵌入两个(或多个)匿名结构体，如两个匿名结构体有相同的字段和方法(同时结构体本身没有同名的字段和方法)，在访问时，就必须明确指定匿名结构体名字，否则编译报错。 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport "fmt"type A struct &#123; Name string age int&#125;func (a *A) SayOk() &#123; fmt.Println("A SayOk", a.Name)&#125;func (a *A) Hello() &#123; fmt.Println("A Hello", a.Name)&#125;type B struct &#123; Name string score float64&#125;func (a *B) SayOk() &#123; fmt.Println("B SayOk", a.Name)&#125;func (a *B) Hello() &#123; fmt.Println("B Hello", a.Name)&#125;//加入一个新的结构体type C struct &#123; A B&#125;func main() &#123; var c C c.A.Name = "jenny" c.B.Name = "john" //c.Name = "test" //错误写法 fmt.Println(c)&#125; 如果一个struct 嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体的字段或方法时，必须带上结构体的名字 123456789101112131415161718192021222324252627282930313233343536373839package mainimport "fmt"type A struct &#123; Name string age int&#125;func (a *A) SayOk() &#123; fmt.Println("A SayOk", a.Name)&#125;func (a *A) Hello() &#123; fmt.Println("A Hello", a.Name)&#125;type B struct &#123; Name string score float64&#125;func (a *B) SayOk() &#123; fmt.Println("B SayOk", a.Name)&#125;func (a *B) Hello() &#123; fmt.Println("B Hello", a.Name)&#125;type D struct &#123; a A&#125;//注意下面的写法func main() &#123; var d D d.a.Name = "tom"&#125; 嵌套匿名结构体后，也可以在创建结构体变量(实例)时，直接指定各个匿名结构体字段的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport "fmt"type A struct &#123; Name string age int&#125;func (a *A) SayOk() &#123; fmt.Println("A SayOk", a.Name)&#125;func (a *A) Hello() &#123; fmt.Println("A Hello", a.Name)&#125;type B struct &#123; Name string score float64&#125;func (a *B) SayOk() &#123; fmt.Println("B SayOk", a.Name)&#125;func (a *B) Hello() &#123; fmt.Println("B Hello", a.Name)&#125;type C struct &#123; A B&#125;func main() &#123; //方式一 c1 := C&#123;A&#123;"tom", 10&#125;, B&#123;"jack", 100.0&#125;&#125; //方式二: 不需要担心顺序问题 c2 := C&#123; A&#123; Name: "tom1", age: 20, &#125;, B&#123; Name: "jack1", score: 99.0, &#125;, &#125; fmt.Println("c1=", c1) fmt.Println("c2=", c2)&#125; 下面这段代码,会输出什么结果 12345678910111213141516171819type Monster struct &#123; Name string Age int&#125;type E struct &#123; Monster int n int&#125;func main() &#123; var e E e.Name = "kkk" e.Age = 300 e.int = 20 e.n = 40 fmt.Println("e=", e)&#125; 说明: 1) 如果一个结构体有 int 类型的匿名字段，就不能有第二个。2) 如果需要有多个 int 的字段，则必须给 int 字段指定名字 面向对象编程三大特性-多重继承 多重继承其实在前面的案例中已经体现过了 如一个 struct 嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现了多重继承。 案例说明 12345678910111213141516171819202122232425262728293031type A struct &#123; Name string age int&#125;func (a *A) SayOk() &#123; fmt.Println("A SayOk", a.Name)&#125;func (a *A) Hello() &#123; fmt.Println("A Hello", a.Name)&#125;type B struct &#123; Name string score float64&#125;func (a *B) SayOk() &#123; fmt.Println("B SayOk", a.Name)&#125;func (a *B) Hello() &#123; fmt.Println("B Hello", a.Name)&#125;//下面这就是多重继承type C struct &#123; A B&#125; 接口 按顺序,我们应该讲解多态,但是在讲解多态前,我们需要讲解接口(interface)，因为在 Golang 中多态特性主要是通过接口来体现的。 接口快速入门12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport "fmt"//定义一个接口type Usb interface &#123; //声明两个没有实现的方法 Start() Stop()&#125;type Phone struct&#123;&#125;//让 Phone实现 Usb接口的方法func (p Phone) Start() &#123; fmt.Println("手机开始工作...")&#125;func (p Phone) Stop() &#123; fmt.Println("手机停止工作...")&#125;type Camera struct&#123;&#125;//让 Camera 实现 Usb接口的方法func (c Camera) Start() &#123; fmt.Println("相机开始工作...")&#125;func (c Camera) Stop() &#123; fmt.Println("相机停止工作...")&#125;type Computer struct&#123;&#125;func (c Computer) Working(usb Usb) &#123; usb.Start() usb.Stop()&#125;func main() &#123; computer := Computer&#123;&#125; phone := Phone&#123;&#125; camera := Camera&#123;&#125; computer.Working(phone) computer.Working(camera)&#125; 理解接口是什么东西了吗? 我的理解就是,如果一个结构体想要用其它结构体的函数,就需要声明一个接口,接口中写入跟被使用结构体同名的函数名称,然后在目前结构体的方法中声明接口的一个实例,然后使用该实例来调用被使用结构体的方法,可能理解起来比较抽象 interface 类型可以定义一组方法，但是这些不需要实现。并且 interface 不能包含任何变量。到某个自定义类型(比如结构体 Phone)要使用的时候,在根据具体情况把这些方法写出来(实现) 基本语法 小结说明1) 接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法。接口体现了程序设计的多态和高内聚低偶合的思想。2) Golang中的接口，不需要显式的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。因此，Golang 中没有 implement 这样的关键字 注意事项和细节 接口本身不能创建实例,但是可以指向一个实现了该接口的自定义类型的变量(实例) 123456789101112131415161718192021package mainimport "fmt"type Interface interface &#123; SayOk()&#125;type Stu struct &#123; Name string&#125;func (s Stu) SayOk() &#123; fmt.Println("Stu SayOk()")&#125;func main() &#123; var stu Stu var a Interface = stu //相当与stu实例将它的 SayOk 方法的具体实现,传递给了接口类型变量 a a.SayOk() //然后 a 就可以自由使用 SayOk 方法了&#125; 接口中所有的方法都没有方法体,即都是没有实现的方法。 在 Golang 中，一个自定义类型需要将某个接口的所有方法都实现，我们说这个自定义类型实现了该接口。 一个自定义类型只有实现了某个接口，才能将该自定义类型的实例(变量)赋给接口类型 只要是自定义数据类型，就可以实现接口，不仅仅是结构体类型。 123456789101112131415161718192021package mainimport ( "fmt")type Interface interface &#123; SayOk()&#125;type integer intfunc (i integer) SayOk() &#123; fmt.Println("integer SayOk i =", i)&#125;func main() &#123; var i integer = 10 var b Interface = i b.SayOk()&#125; 一个自定义类型可以实现多个接口 123456789101112131415161718192021222324252627282930313233package mainimport ( "fmt")type InterfaceA interface &#123; SayOk()&#125;type InterfaceB interface &#123; SayHello()&#125;type Stu struct &#123; Name string&#125;func (s Stu) SayOk() &#123; fmt.Println("Stu SayOk()")&#125;func (s Stu) SayHello() &#123; fmt.Println("Stu SayHello()")&#125;func main() &#123; var stu Stu var a InterfaceA = stu var b InterfaceB = stu a.SayOk() b.SayHello()&#125; Golang接口中不能有任何变量 一个接口(比如 A 接口)可以继承多个别的接口(比如 B,C 接口)，这时如果要实现 A 接口，也必须将 B,C 接口的方法也全部实现。 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( "fmt")type InterfaceA interface &#123; SayA()&#125;type InterfaceB interface &#123; SayB()&#125;type InterfaceC interface &#123; InterfaceA InterfaceB SayC()&#125;//如果需要实现InterfaceA, 就需要将 InterfaceB 与 InterfaceC 的方法都实现type Stu struct &#123; Name string&#125;func (s Stu) SayA() &#123; fmt.Println("Stu SayA()")&#125;func (s Stu) SayB() &#123; fmt.Println("Stu SayB()")&#125;func (s Stu) SayC() &#123; fmt.Println("Stu SayC()")&#125;func main() &#123; var stu Stu var a InterfaceA = stu a.SayA()&#125; interface类型默认是一个指针(引用类型)，如果没有对interface初始化就使用，那么会输出nil 空接口 interface{} 没有任何方法，所以所有类型都实现了空接口, 即我们可以把任何一个变量赋给空接口。 接口编程的最佳实践 实现对 Hero 结构体切片的排序: sort.Sort(data Interface) 根据官网提供的sort方法我们可以知道: 1.接口类型已经在Sort包中定义好了 2.调用接口中抽象方法的函数已经在Sort自己的包中定义好了(sort.Sort(接口实例)这个就是) 3.需要我们自己实现 Len() Less() Swap() 三个方法来实现Sort接口中的抽象类 4.我们只需要直接使用 sort.Sort() 传入自己结构体的实例即可 官网链接: https://pkg.go.dev/sort#Interface https://cs.opensource.google/go/go/+/refs/tags/go1.19:src/sort/sort.go;l=14 下面是官网 sort.Sort() 中的一个例子,我们可以进行套用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( "fmt" "math/rand" "sort")type Hero struct &#123; Name string Age int&#125;//声明一个数组结构体type HeroSlice []Herofunc (x HeroSlice) Len() int &#123; return len(x)&#125;func (x HeroSlice) Less(i, j int) bool &#123; //按照Age进行升序排序 return x[i].Age &lt; x[j].Age //这里小于号当做是升序排列,大于号当做是降序排列 //按照Name进行升序排序 //return x[i].Name &lt; x[j].Name&#125;func (x HeroSlice) Swap(i, j int) &#123; x[i], x[j] = x[j], x[i]&#125;func main() &#123; var heroes HeroSlice //HeroSlice 是一个数组结构体 //循环进行初始化赋值操作 for i := 0; i &lt; 10; i++ &#123; hero := Hero&#123; Name: fmt.Sprintf("英雄|%d", rand.Intn(100)), Age: rand.Intn(100), &#125; //将初始化好的新一条数据加入到heroes数组中 heroes = append(heroes, hero) &#125; fmt.Println("对Age字段排序前") for _, v := range heroes &#123; fmt.Println("Name=", v.Name, "Age=", v.Age) &#125; //对数组 heroes 进行排序 sort.Sort(heroes) fmt.Println("对Age字段排序后") for _, v := range heroes &#123; fmt.Println("Name=", v.Name, "Age=", v.Age) &#125;&#125; 实现接口 vs 继承 现在有一只猴子,它只会爬树,但是他想学会飞翔和游泳 请使用接口实现这个案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport "fmt"type Skill interface &#123; Flying() Swimming()&#125;//基础结构体type Monkey struct &#123; Name string&#125;func (m *Monkey) climbing() &#123; fmt.Println(m.Name, "猴子生来会爬树...")&#125;//实现抽象方法type SuperMonkey struct &#123; Monkey //继承&#125;func (s *SuperMonkey) Flying() &#123; fmt.Println("你现在可以飞了!")&#125;func (s *SuperMonkey) Swimming() &#123; fmt.Println("你现在可以游泳了!")&#125;//继承Monkeytype LittleMonkey struct &#123; Monkey //继承&#125;//调用接口的方法func (l *LittleMonkey) getSkill(skill Skill) &#123; skill.Flying() skill.Swimming()&#125;func main() &#123; monkey := LittleMonkey&#123;Monkey&#123;"悟空"&#125;&#125; superMonkey := SuperMonkey&#123;Monkey&#123;"卡卡罗特"&#125;&#125; monkey.climbing() monkey.getSkill(&amp;superMonkey)&#125; 说明: 继承的价值主要在于:解决代码的复用性和可维护性。 接口的价值主要在于:设计，设计好各种规范(方法)，让其它自定义类型去实现这些方法。 面向对象编程-多态 变量(实例)具有多种形态。面向对象的第三大特征，在 Go 语言，多态特征是通过接口实现的。可以按照统一的接口来调用不同的实现。这时接口变量就呈现不同的形态。 快速入门 在前面的 Usb 接口案例，Usb usb ，既可以接收手机变量，又可以接收相机变量，就体现了 Usb 接口多态特性 详情参考本文:接口快速入门 接口体现多态的两种形式 多态参数 在前面的 Usb 接口案例，Usb usb ，即可以接收手机变量，又可以接收相机变量，就体现了 Usb 接口多态。 多态数组 演示一个案例:给 Usb 数组中，存放 Phone 结构体 和 Camera 结构体变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport "fmt"//定义一个接口type Usb interface &#123; //声明两个没有实现的方法 Start() Stop()&#125;type Phone struct &#123; name string&#125;//让 Phone实现 Usb接口的方法func (p Phone) Start() &#123; fmt.Println("手机开始工作...")&#125;func (p Phone) Stop() &#123; fmt.Println("手机停止工作...")&#125;type Camera struct &#123; name string&#125;//让 Camera 实现 Usb接口的方法func (c Camera) Start() &#123; fmt.Println("相机开始工作...")&#125;func (c Camera) Stop() &#123; fmt.Println("相机停止工作...")&#125;type Computer struct&#123;&#125;func (c Computer) Working(usb Usb) &#123; usb.Start() usb.Stop()&#125;func main() &#123; //定义一个Usb接口数组,可以存放 Phone 和 Camera 的结构体变量 //这里就体现出多态数组 var arrUsb [3]Usb arrUsb[0] = Phone&#123;"iphone"&#125; arrUsb[1] = Phone&#123;"vivo"&#125; arrUsb[2] = Camera&#123;"尼康"&#125; fmt.Println(arrUsb)&#125; 类型断言 基本介绍 类型断言，由于接口是一般类型，不知道具体类型，如果要转成具体类型，就需要使用类型断言 1234567891011package mainimport "fmt"func main() &#123; var x interface&#123;&#125; var b2 float32 = 1.1 x = b2 //空接口,可以接收任何类型 y := x.(float32) fmt.Printf("y的类型是 %T, 值是 %v\n", y, y)&#125; 说明: 在进行类型断言时，如果类型不匹配，就会报 panic, 因此进行类型断言时，要确保原来的空接口指向的就是断言的类型 如何在进行断言时，带上检测机制，如果成功就 ok,否则也不要报 panic 123456789101112131415161718package mainimport "fmt"func main() &#123; var x interface&#123;&#125; var b2 float32 = 6.5 x = b2 //空接口,可以接收任何类型 //类型断言(带检测) if y, ok := x.(float32); ok &#123; fmt.Println("convert success") fmt.Printf("y的类型是 %T , 值是=%v\n", y, y) &#125; else &#123; fmt.Println("convert fail") &#125; fmt.Println("继续执行...")&#125; 最佳实践一 在前面的 Usb 接口案例做改进: 给 Phone 结构体增加一个特有的方法 call(), 当 Usb 接口接收的是 Phone 变量时，还需要调用 call 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport "fmt"//定义一个接口type Usb interface &#123; //声明两个没有实现的方法 Start() Stop()&#125;type Phone struct &#123; name string&#125;//让 Phone实现 Usb接口的方法func (p Phone) Start() &#123; fmt.Println("手机开始工作...")&#125;func (p Phone) Stop() &#123; fmt.Println("手机停止工作...")&#125;//只有Phone拥有此方法func (p Phone) Call() &#123; fmt.Println("手机正在打电话")&#125;type Camera struct &#123; name string&#125;//让 Camera 实现 Usb接口的方法func (c Camera) Start() &#123; fmt.Println("相机开始工作...")&#125;func (c Camera) Stop() &#123; fmt.Println("相机停止工作...")&#125;type Computer struct&#123;&#125;func (c Computer) Working(usb Usb) &#123; usb.Start() //如果 usb 是指向 Phone 结构体变量, 则还需要调用Call方法 if phone, ok := usb.(Phone); ok &#123; phone.Call() &#125; usb.Stop()&#125;func main() &#123; //定义一个Usb接口数组,可以存放 Phone 和 Camera 的结构体变量 //这里就体现出多态数组 var arrUsb [3]Usb arrUsb[0] = Phone&#123;"iphone"&#125; arrUsb[1] = Phone&#123;"vivo"&#125; arrUsb[2] = Camera&#123;"尼康"&#125; //遍历 arrUsb 数组 var computer Computer for _, v := range arrUsb &#123; computer.Working(v) fmt.Println() &#125;&#125; 最佳实践二 写一函数，循环判断传入参数的类型: 12345678910111213141516171819202122232425262728293031323334package mainimport "fmt"func TypeJudge(items ...interface&#123;&#125;) &#123; for index, x := range items &#123; switch x.(type) &#123; case bool: fmt.Printf("第%v个参数是 bool 类型, 值是%v\n", index, x) case float32: fmt.Printf("第%v个参数是 float32 类型, 值是%v\n", index, x) case float64: fmt.Printf("第%v个参数是 float64 类型, 值是%v\n", index, x) case int, int32, int64: fmt.Printf("第%v个参数是 整数类型, 值是%v\n", index, x) case string: fmt.Printf("第%v个参数是 string 类型, 值是%v\n", index, x) default: fmt.Printf("第%v个参数是 不确定的类型, 值是%v\n", index, x) &#125; &#125;&#125;func main() &#123; var v1 float32 = 1.1 var v2 float64 = 1.2 var v3 int32 = 30 var name string = "tom" address := "北京" v4 := 300 TypeJudge(v1, v2, v3, name, address, v4)&#125; 项目家庭收支记账软件项目项目开发流程说明 项目需求说明1) 模拟实现基于文本界面的《家庭记账软件》2) 该软件能够记录家庭的收入、支出，并能够打印收支明细表 项目代码实现-面向过程 目前只实现其过程,等完成这个项目需求之后,我们再将其改为面向对象方式实现 目前只在一个main.go中实现功能 功能一:实现主菜单12345678910111213141516171819202122232425262728293031323334353637383940package mainimport "fmt"func main() &#123; //key接收用户输入的操作 key := "" //loop控制是否退出 loop := true //显示主菜单 for &#123; fmt.Println("----------------家庭收支记账软件----------------") fmt.Println("1. 收支明细") fmt.Println("2. 登记收入") fmt.Println("3. 登记支出") fmt.Println("q. 退出软件") fmt.Println("请选择1|2|3|q: ") fmt.Scanln(&amp;key) switch key &#123; case "1": fmt.Println("----------------当前收支明细记录----------------") case "2": fmt.Println("登记收入") case "3": fmt.Println("登记支出") case "q": loop = false default: fmt.Println("请输入正确的选项!") &#125; if !loop &#123; break &#125; &#125; fmt.Println("您已退出[家庭记账软件]")&#125; 功能二:显示明细和登记收入 定义变量来记录余额(balance)、每次收支的金额(money), 每次收支的说明(note) 12345678910111213141516//key接收用户输入的操作key := ""//loop控制是否退出loop := true//定义账户的余额balance := 10000.0//每次每次收支的金额money := 0.0//每次收支的说明note := ""//收支的详情使用字符串来记录//当有收支时,只需要对details进行拼接处理即可title := "收支\t账户金额\t收支金额\t说 明" //收支明细的标题details := "" 收入明细实现 123456789101112switch key &#123; case "1": fmt.Println("----------------当前收支明细记录----------------") fmt.Println(details) case "2": fmt.Println("请输入收入金额:") fmt.Scanln(&amp;money) balance += money fmt.Println("本次收入说明:") fmt.Scanln(&amp;note) //将这个收入情况拼接到details变量 details += fmt.Sprintf("\n收入\t%v\t\t%v\t\t%v", balance, money, note) 功能三:登记支出的功能123456789101112case "3": fmt.Println("请输入支出金额:") fmt.Scanln(&amp;money) if money &gt; balance &#123; fmt.Println("余额不足") break &#125; balance -= money fmt.Println("本次支出说明:") fmt.Scanln(&amp;note) //将这个收入情况拼接到details变量 details += fmt.Sprintf("\n支出\t%v\t\t%v\t\t%v", balance, money, note) 代码改进 用户输入 q退出时，给出提示确定要退出吗?(y/n)，必须输入正确的 y/n ，否则循环输入指令，直到输入 y 或者 n 1234567891011121314case "q": exit_key := "" fmt.Println("确定要退出吗?(y/n)") fmt.Scanln(&amp;exit_key) for &#123; if exit_key == "y" &#123; loop = false break &#125; else if exit_key == "n" &#123; break &#125; else &#123; fmt.Println("你的输入有误,请重新输入!(y/n)") &#125; &#125; 当没有任何收支明细时，提示 当前没有收支明细... 来一笔吧! 下面是完整的一段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package mainimport "fmt"func main() &#123; //key接收用户输入的操作 key := "" //loop控制是否退出 loop := true //定义账户的余额 balance := 10000.0 //每次每次收支的金额 money := 0.0 //每次收支的说明 note := "" //收支的详情使用字符串来记录 //当有收支时,只需要对details进行拼接处理即可 title := "收支\t账户金额\t收支金额\t说 明" //收支明细的标题 details := "" //显示主菜单 for &#123; fmt.Println("----------------家庭收支记账软件----------------") fmt.Println("1. 收支明细") fmt.Println("2. 登记收入") fmt.Println("3. 登记支出") fmt.Println("q. 退出软件") fmt.Println("请选择1|2|3|q: ") fmt.Scanln(&amp;key) switch key &#123; case "1": fmt.Println("----------------当前收支明细记录----------------") if details == "" &#123; fmt.Println("当前没有收支明细... 来一笔吧!") &#125; else &#123; fmt.Println(title) fmt.Println(details) &#125; case "2": fmt.Println("请输入收入金额:") fmt.Scanln(&amp;money) balance += money fmt.Println("本次收入说明:") fmt.Scanln(&amp;note) //将这个收入情况拼接到details变量 details += fmt.Sprintf("收入\t%v\t\t%v\t\t%v", balance, money, note) case "3": fmt.Println("请输入支出金额:") fmt.Scanln(&amp;money) if money &gt; balance &#123; fmt.Println("余额不足") break &#125; balance -= money fmt.Println("本次支出说明:") fmt.Scanln(&amp;note) //将这个收入情况拼接到details变量 details += fmt.Sprintf("支出\t%v\t\t%v\t\t%v", balance, money, note) case "q": exit_key := "" fmt.Println("确定要退出吗?(y/n)") fmt.Scanln(&amp;exit_key) for &#123; if exit_key == "y" &#123; loop = false break &#125; else if exit_key == "n" &#123; break &#125; else &#123; fmt.Println("你的输入有误,请重新输入!(y/n)") &#125; &#125; default: fmt.Println("请输入正确的选项!") &#125; if !loop &#123; break &#125; &#125; fmt.Println("您已退出[家庭记账软件]")&#125; 项目代码实现-面向对象 实现思路: 更改上面面向过程的代码来实现 创建新的结构体,将各个功能分割为该结构体的方法 将各个方法存放到各自单独的文件中,由main主函数进行调用 总体代码 自行将不同的部分放入不同的文件中即可(需要自己引入包),也可以都放入main.go中执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package mainimport "fmt"//model模块type FamilyAccount struct &#123; key string //key接收用户输入的操作 loop bool //loop控制是否退出 balance float64 //定义账户的余额 money float64 //每次每次收支的金额 note string //每次收支的说明 //收支的详情使用字符串来记录 title string //收支明细的标题 details string //当有收支时,只需要对details进行拼接处理即可&#125;func NewFmailyAccount() *FamilyAccount &#123; return &amp;FamilyAccount&#123; key: "", loop: true, balance: 10000.0, money: 0.0, note: "", title: "收支\t账户金额\t收支金额\t说 明", details: "", &#125;&#125;func (f *FamilyAccount) showDetails() &#123; fmt.Println("----------------当前收支明细记录----------------") if f.details == "" &#123; fmt.Println("当前没有收支明细... 来一笔吧!") &#125; else &#123; fmt.Print(f.title) fmt.Println(f.details) &#125;&#125;func (f *FamilyAccount) income() &#123; fmt.Println("请输入收入金额:") fmt.Scanln(&amp;f.money) f.balance += f.money fmt.Println("本次收入说明:") fmt.Scanln(&amp;f.note) //将这个收入情况拼接到details变量 f.details += fmt.Sprintf("\n收入\t%v\t\t%v\t\t%v", f.balance, f.money, f.note)&#125;func (f *FamilyAccount) pay() &#123; flag := true //判断余额是否足够 fmt.Println("请输入支出金额:") fmt.Scanln(&amp;f.money) if f.money &gt; f.balance &#123; fmt.Println("余额不足") flag = false &#125; //如果余额不足,则跳过下面的步骤 if flag == true &#123; f.balance -= f.money fmt.Println("本次支出说明:") fmt.Scanln(&amp;f.note) //将这个收入情况拼接到details变量 f.details += fmt.Sprintf("\n支出\t%v\t\t%v\t\t%v", f.balance, f.money, f.note) &#125;&#125;func (f *FamilyAccount) exit() &#123; exit_key := "" fmt.Println("确定要退出吗?(y/n)") fmt.Scanln(&amp;exit_key) for &#123; if exit_key == "y" &#123; f.loop = false break &#125; else if exit_key == "n" &#123; break &#125; else &#123; fmt.Println("你的输入有误,请重新输入!(y/n)") &#125; &#125;&#125;func (f *FamilyAccount) MainMenu() &#123; for &#123; fmt.Println("----------------家庭收支记账软件----------------") fmt.Println("1. 收支明细") fmt.Println("2. 登记收入") fmt.Println("3. 登记支出") fmt.Println("q. 退出软件") fmt.Println("请选择1|2|3|q: ") fmt.Scanln(&amp;f.key) switch f.key &#123; case "1": f.showDetails() case "2": f.income() case "3": f.pay() case "q": f.exit() default: fmt.Println("请输入正确的选项!") &#125; if !f.loop &#123; break &#125; &#125;&#125;//主函数func main() &#123; var p1 = NewFmailyAccount() p1.MainMenu()&#125; 客户信息关系系统项目项目需求分析1) 模拟实现基于文本界面的《客户信息管理软件》。2) 该软件能够实现对客户对象的插入、修改和删除(用切片实现)，并能够打印客户明细表 项目界面设计 主菜单界面 添加客户界面 修改客户界面 删除客户界面 客户列表界面 客户关系管理系统的程序框架图 功能实现显示主菜单和退出软件功能 model/customer.go 1234567891011121314151617181920212223package model//声明一个customer结构体,表示一个客户信息type Customer struct &#123; Id int Name string Gender string Age int Phone string Email string&#125;//使用工程模式,返回一个Customer的实例func NewCustomer(id int, name string, gender string, age int, phone string, email string) Customer &#123; return Customer&#123; Id: id, Name: name, Gender: gender, Age: age, Phone: phone, Email: email, &#125;&#125; service/customerService.go 123456789101112131415package serviceimport ( "golang_study/object_oriented_programming/KeHuGuanXiGuanLiXiTong/model")//该 customerService,完成对 customer 的操作,包括//增删改查type customerService struct &#123; customers []model.Customer //声明一个字段,表示当前切片含有多少个客户 //该字段后面,还可以作为新客户的 id+1 customerNum int&#125; view/customerView.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport "fmt"type CustomerView struct &#123; //定义必要字段 key string //接收用户信息 loop bool //表示是否循环显示主菜单&#125;//显示主菜单func (c *customerView) mainMenu() &#123; for &#123; fmt.Println("-----------------客户信息管理软件-----------------") fmt.Println(" 1 添 加 客 户") fmt.Println(" 2 修 改 客 户") fmt.Println(" 3 删 除 客 户") fmt.Println(" 4 客 户 列 表") fmt.Println(" 5 退 出") fmt.Println("-----------------------------------------------") fmt.Print("请选择(1-5):") fmt.Scanln(&amp;c.key) switch c.key &#123; case "1": fmt.Println("添 加 客 户") case "2": fmt.Println("修 改 客 户") case "3": fmt.Println("删 除 客 户") case "4": fmt.Println("客 户 列 表") case "5": c.loop = false default: fmt.Println("你的输入有误，请重新输入...") &#125; if !c.loop &#123; break &#125; &#125; fmt.Println("你退出了客户关系管理系统...")&#125;func main() &#123; //在main中,创建一个customerView,并运行显示主菜单 customerView := customerView &#123; key: "", loop: true, &#125; //显示主菜单 customerView.mainMenu()&#125; 显示客户列表的功能 model/customer.go 12345//返回用户的信息,格式化的字符串func (c *Customer) GetInfo() string &#123; info := fmt.Sprintf("%v\t%v\t%v\t%v\t%v\t%v", c.id, c.name, c.age, c.gender, c.phone, c.email) return info&#125; service/customerService.go 12345678910111213//编写一个函数,可以返回 *CustomerServicefunc NewCustomerService() *CustomerService &#123; //为了能够看到有客户在切片中,我们初始化一个客户 CustomerService := &amp;CustomerService&#123;&#125; CustomerService.customerNum = 1 customer := model.NewCustomer(1, "张三", "男", 20, "112", "syz15822409222@126.com") CustomerService.customers = append(CustomerService.customers, customer) return CustomerService&#125;func (c *CustomerService) List() []model.Customer &#123; return c.customers&#125; view/customerView.go 1234567891011//显示所有客户的信息func (c *customerView) list() &#123; //首先获取到当前所有的客户信息(在切片中) customers := c.customerService.List() fmt.Println("---------------------客户列表--------------------") fmt.Println("编号\t姓名\t性别\t年龄\t电话\t邮箱") for i := 0; i &lt; len(customers); i++ &#123; fmt.Println(customers[i].GetInfo()) &#125; fmt.Println("-------------------客户列表完成-------------------")&#125; 添加客户的功能 实现思路 model/customer.go 增加下面的内容(不手动指定id号,让其自动累加) 12345678910//第二种创建Customer实例方法,不带idfunc NewCustomer2(name string, gender string, age int, phone string, email string) Customer &#123; return Customer&#123; Name: name, Gender: gender, Age: age, Phone: phone, Email: email, &#125;&#125; service/customerService.go 12345678//添加客户端到customer切片func (c *CustomerService) Add(customer model.Customer) bool &#123; //我们确定一个分配id的规则,就是添加的顺序 c.customerNum++ //这样我们就不用写id了 customer.Id = c.customerNum c.customers = append(c.customers, customer) return true&#125; view/customerView.go 1234567891011121314151617181920212223242526272829//得到用户的输入,信息构建新的客户func (c *customerView) add() &#123; fmt.Println("---------------------添加客户--------------------") fmt.Println("姓名:") name := "" fmt.Scanln(&amp;name) fmt.Println("性别") gender := "" fmt.Scanln(&amp;gender) fmt.Println("年龄") age := 0 fmt.Scanln(&amp;age) fmt.Println("电话") phone := "" fmt.Scanln(&amp;phone) fmt.Println("邮件") email := "" fmt.Scanln(&amp;email) //构建一个新的Customer实例 //注意id号,没有让用户输入,id是唯一的,需要系统分配 customer := model.NewCustomer2(name, gender, age, phone, email) //调用 if c.customerService.Add(customer) &#123; fmt.Println("---------------------添加完成--------------------") &#125; else &#123; fmt.Println("---------------------添加失败--------------------") &#125;&#125; 删除客户的功能 实现思路 model/customer.go(没有变化) service/customerService.go 123456789101112131415161718192021222324//根据客户的id删除客户的信息//首先实现查找客户的id是否存在func (c *CustomerService) FindById(id int) int &#123; index := -1 //遍历 c.customers 切片 for i := 0; i &lt; len(c.customers); i++ &#123; if c.customers[i].Id == id &#123; index = i //找到 &#125; &#125; return index&#125;//如果id存在,那么删除该用户func (c *CustomerService) Delete(id int) bool &#123; index := c.FindById(id) //如果 index = -1, 说明没有这个客户 if index == -1 &#123; return false &#125; //从切片中删除一个元素 c.customers = append(c.customers[:index], c.customers[index+1:]...) //注意这里的写法 return true&#125; view/customerView.go 12345678910111213141516171819202122232425262728293031323334//得到用户的id后,删除该id对应的客户func (c *customerView) delete() &#123; fmt.Println("---------------------删除客户--------------------") fmt.Println("请输入待删除客户的id编号(-1退出):") id := -1 fmt.Scanln(&amp;id) if id == -1 &#123; return //放弃删除操作 &#125; fmt.Println("确认是否删除(Y/N):") for &#123; //定义一个变量,接收下面的for循环是否退出 flag := false choice := "" fmt.Scanln(&amp;choice) switch choice &#123; case "y", "Y": if c.customerService.Delete(id) &#123; fmt.Println("---------------------删除完成--------------------") &#125; else &#123; fmt.Println("---------------------删除失败--------------------") &#125; flag = true case "n", "N": flag = true default: fmt.Println("您的输入有误,请输入正确的选项!(Y/N)") &#125; //如果 flag == true, 则退出for循环 if flag &#123; break &#125; &#125;&#125; 完善退出确认功能 view/customerView.go 123456789101112131415161718192021222324252627//退出软件func (c *customerView) exit() int &#123; n := 0 //给主函数返回一个变量用于判断是否退出 for &#123; //定义一个变量,接收下面的for循环是否退出 flag := true //true代表退出循环 fmt.Println("确认是否退出(Y/N):") choice := "" fmt.Scanln(&amp;choice) switch choice &#123; case "y", "Y": fmt.Println("感谢您的使用,下次再见~") n = 1 case "n", "N": fmt.Println("感谢您的喜欢与支持~") default: fmt.Println("您的输入有误,请输入正确的选项!(Y/N)") flag = false &#125; //如果 flag == true, 则退出for循环 if flag &#123; break &#125; &#125; return n&#125; 修改客户信息 修改客户信息,需要在customerService与customerView中进行编写 service/customerService.go 1234567891011121314151617181920212223242526//根据客户提供的id,对客户的相关个人信息进行修改func (c *CustomerService) Alter(id int, name string, gender string, age int, phone string, email string) bool &#123; index := c.FindById(id) //如果 index = -1, 说明没有这个客户 if index == -1 &#123; return false &#125; //修改客户信息,按下回车表示不修改 if c.customers[index].Name != "\n" &#123; c.customers[index].Name = name &#125; if c.customers[index].Gender != "\n" &#123; c.customers[index].Gender = gender &#125; if c.customers[index].Age != 0 &#123; //0表示没有修改 c.customers[index].Age = age &#125; if c.customers[index].Phone != "\n" &#123; c.customers[index].Phone = phone &#125; if c.customers[index].Email != "\n" &#123; c.customers[index].Email = email &#125; return true&#125; view/customerView.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//修改客户信息func (c *customerView) alter() &#123; fmt.Println("---------------------修改客户--------------------") fmt.Println("请输入待删除客户的id编号(-1退出):") id := -1 fmt.Scanln(&amp;id) if id == -1 &#123; return //放弃修改操作 &#125; index := c.customerService.FindById(id) //获取对应id的数组的索引 if index == -1 &#123; //如果index == -1,说明没有这个用户 fmt.Println("-----------该id不存在,请检查后重新尝试-----------") return &#125; customers := c.customerService.List() //获取数组的所有信息 fmt.Printf("姓名(%v):", customers[index].Name) name := customers[index].Name fmt.Scanln(&amp;name) fmt.Printf("性别(%v):", customers[index].Gender) gender := customers[index].Gender fmt.Scanln(&amp;gender) fmt.Printf("年龄(%v):", customers[index].Age) age := customers[index].Age fmt.Scanln(&amp;age) fmt.Printf("电话(%v):", customers[index].Phone) phone := customers[index].Phone fmt.Scanln(&amp;phone) fmt.Printf("邮箱(%v):", customers[index].Email) email := customers[index].Email fmt.Scanln(&amp;email) fmt.Println("确认是否修改(Y/N):") for &#123; //定义一个变量,接收下面的for循环是否退出 flag := false choice := "" fmt.Scanln(&amp;choice) switch choice &#123; case "y", "Y": if c.customerService.Alter(id, name, gender, age, phone, email) &#123; fmt.Println("---------------------修改完成--------------------") &#125; else &#123; fmt.Println("---------------------修改失败--------------------") &#125; flag = true case "n", "N": flag = true default: fmt.Println("您的输入有误,请输入正确的选项!(Y/N)") &#125; //如果 flag == true, 则退出for循环 if flag &#123; break &#125; &#125;&#125; 至此,客户信息关系系统完成~ 文件操作打开/关闭文件用到的方法func Open1func Open(name string) (*File, error) 打开指定文件进行读取。如果成功，则可以使用返回文件上的方法进行读取;关联的文件描述符具有O_RDONLY模式。如果有错误，它的类型将是* pathror。 func (*File) Close1func (f *File) Close() error 关闭关闭文件，使其无法用于I/O。在支持SetDeadline的文件中，任何等待的I/O操作将被取消，并立即返回ErrClosed错误。如果Close已经被调用，将返回一个错误。 演示案例123456789101112131415161718192021222324252627package mainimport ( "fmt" "os")func main() &#123; //打开文件 /* 概念说明: file的叫法 1. file 叫 file 对象 2. file 叫 file 指针 3. file 叫 file 文件句柄 */ file, err := os.Open("/usr/local/go/src/golang_study/14-File/filedemo/demo.txt") if err != nil &#123; fmt.Println("Open file err=", err) &#125; //通过输出结果可以得知,file就是一个指针 fmt.Printf("file=%v\n", file) //关闭文件 err = file.Close() if err != nil &#123; fmt.Println("Close file err=", err) &#125;&#125; 执行结果 1file=&amp;&#123;0xc0000ae120&#125; 读文件操作应用实例 读取文件的内容并显示在终端(带缓冲区的方式) 使用 os.Open, file.Close, bufio.NewReader(), reader.ReadString 函数和方法. 1234567891011121314151617181920212223242526272829303132333435package mainimport ( "bufio" "fmt" "io" "os")func main() &#123; //打开文件 file, err := os.Open("/usr/local/go/src/golang_study/14-File/filedemo/demo.txt") if err != nil &#123; fmt.Println("Open file err=", err) &#125; //当函数退出时, 要及时关闭file defer file.Close() //要及时关闭file句柄, 否则会有内存泄漏 //创建一个 *Reader, 是带缓冲的 /* const ( defaultBufSize = 4096 //默认的缓冲区为 4096 ) */ reader := bufio.NewReader(file) //循环的读取文件的内容 for &#123; str, err := reader.ReadString('\n') //读到一个换行就结束 if err == io.EOF &#123; //io.EOF 表示文件的末尾 break &#125; fmt.Print(str) &#125; fmt.Println("文件读取结束...")&#125; 执行结果 1234123123456456789789文件读取结束... 读取文件的内容并显示在终端(使用 ioutil 一次将整个文件读入到内存中)，这种方式适用于文件不大的情况。 相关方法和函数: ioutil.ReadFile 123456789101112131415161718192021package mainimport ( "fmt" "io/ioutil")func main() &#123; //使用ioutil.ReadFile一次性将文件读取到位 file := "/usr/local/go/src/golang_study/14-File/filedemo/demo.txt" content, err := ioutil.ReadFile(file) if err != nil &#123; fmt.Printf("read file err=%v", err) &#125; //将读取到的内容显示到终端 //fmt.Println("%v", content) //[]byte fmt.Printf("%v", string(content)) //byte //我们没有显示的Open文件,因此也不需要显示的Close文件 //因为, 文件的Open和Close被封装到 ReadFile 函数内部&#125; 执行结果 123123123456456789789 写文件操作应用实例func OpenFile1func OpenFile(name string, flag int, perm FileMode) (*File, error) OpenFile是广义的open调用;大多数用户会使用Open或Create。它打开指定标志(O_RDONLY等)的命名文件。如果文件不存在，并且传递了O_CREATE标志，则使用perm模式(在umask之前)创建它。如果成功，就可以使用返回File上的方法进行I/O操作。如果有错误，它的类型将是* pathror。 第一个参数: 表示文件的路径 第二个参数: 选项如下(可组合使用) 123456789101112const ( // O_RDONLY、O_WRONLY或O_RDWR必须指定一个。 O_RDONLY int = sycall.O_RDONLY //只读模式打开文件。 O_WRONLY int = sycall.O_WRONLY //只写模式打开文件 O_RDWR int = sycall.O_RDWR //读写模式打开文件 //剩下的值可以输入或输入以控制行为。 O_APPEND int = sycall.O_APPEND //写入文件时追加数据。 O_CREATE int = sycall.O_CREAT //如果文件不存在，则创建一个新文件。 O_EXCL int = syscall.O_EXCL //与 O_CREATE 一起使用，文件必须不存在。 O_SYNC int = sycall.O_SYNC //打开用于同步I/O。 O_TRUNC int = sycall.O_TRUNC //如果可能,打开时清空文件） 第三个参数: 权限控制(同Linux) 123r =&gt; 4w =&gt; 2x =&gt; 1 方式一 创建一个新文件，写入内容 5 句 “hello, Gardon” 123456789101112131415161718192021222324252627282930313233package mainimport ( "bufio" "fmt" "os")func main() &#123; //创建一个新文件,写入内容 5句 "hello, Gardon" //1. 打开文件 /usr/local/go/src/golang_study/14-File/filedemo3/demo.txt filePath := "/usr/local/go/src/golang_study/14-File/filedemo3/demo.txt" file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666) if err != nil &#123; fmt.Printf("open file err=%v\n", err) return &#125; //及时关闭file句柄 defer file.Close() //准备写入5句 "hello, Gardon" str := "hello, Gardon\n" //写入时, 使用带缓存的 *Writer writer := bufio.NewWriter(file) for i := 0; i &lt; 5; i++ &#123; writer.WriteString(str) &#125; /* 因为weiter是带缓存, 因此在调用WriterString方法时, 其实内容是先写入到缓存的,所以需要调用Flush方法, 将缓冲的数据真正写入到文件中, 否则文件中会没有数据 */ writer.Flush()&#125; 打开一个存在的文件，将原来的内容覆盖成新的内容 10 句 “你好，世界!” 12345678910111213141516171819202122232425262728package mainimport ( "bufio" "fmt" "os")func main() &#123; //打开已经存在的文件 filePath := "/usr/local/go/src/golang_study/14-File/filedemo3/demo.txt" //O_TRUNC //如果可能,打开时清空文件 file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_TRUNC, 0666) if err != nil &#123; fmt.Printf("open file err=%v\n", err) return &#125; //及时关闭file句柄 defer file.Close() //准备写入10句 "你好,世界" str := "你好,世界\r\n" // \r\n 表示换行 //写入时, 使用带缓存的 *Writer writer := bufio.NewWriter(file) for i := 0; i &lt; 10; i++ &#123; writer.WriteString(str) &#125; writer.Flush()&#125; 打开一个存在的文件，在原来的内容追加内容 ‘ABC! ENGLISH!’ 12345678910111213141516171819202122232425262728package mainimport ( "bufio" "fmt" "os")func main() &#123; //打开已经存在的文件 filePath := "/usr/local/go/src/golang_study/14-File/filedemo3/demo.txt" //O_APPEND //写入文件时追加数据 file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, 0666) if err != nil &#123; fmt.Printf("open file err=%v\n", err) return &#125; //及时关闭file句柄 defer file.Close() //准备写入10句 "你好,世界" str := "ABC! ENGLISH!\r\n" // \r\n 表示换行 //写入时, 使用带缓存的 *Writer writer := bufio.NewWriter(file) for i := 0; i &lt; 10; i++ &#123; writer.WriteString(str) &#125; writer.Flush()&#125; 打开一个存在的文件，将原来的内容读出显示在终端，并且追加 5 句”hello,北京!” 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( "bufio" "fmt" "io" "os")func main() &#123; //打开文件 filePath := "/usr/local/go/src/golang_study/14-File/filedemo3/demo.txt" file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, 0666) if err != nil &#123; fmt.Printf("open file err=%v\n", err) return &#125; //及时关闭file句柄 defer file.Close() //读 //先读取原来的文件内容,并显示在终端 reader := bufio.NewReader(file) for &#123; str, err := reader.ReadString('\n') // \n在这里表示 reader 读到哪里结束 if err == io.EOF &#123; break &#125; //显示到终端 fmt.Print(str) &#125; //写 //准备写入10句 "hello,北京!" str := "hello,北京!\r\n" // \r\n 表示换行 //写入时, 使用带缓存的 *Writer writer := bufio.NewWriter(file) for i := 0; i &lt; 10; i++ &#123; writer.WriteString(str) &#125; writer.Flush()&#125; 方式二 编程一个程序，将一个文件的内容，写入到另外一个文件。 注:这两个文件已经存在了 说明: 使用 ioutil.ReadFile / ioutil.WriteFile 完成写文件的任务. 12345678910111213141516171819202122232425package mainimport ( "fmt" "io/ioutil")func main() &#123; //将a.txt文件内容导入到b.txt //1. 首先将 a.txt 内容读取到内存 //2. 将读取到的内容写入 b.txt(如果b.txt文件存在, 则直接覆盖) file1Path := "/usr/local/go/src/golang_study/14-File/filedemo5/main/a.txt" file2Path := "/usr/local/go/src/golang_study/14-File/filedemo5/main/b.txt" data, err := ioutil.ReadFile(file1Path) if err != nil &#123; //说明读取文件有错误 fmt.Printf("read file err=%v\n", err) return &#125; err = ioutil.WriteFile(file2Path, data, 0666) if err != nil &#123; fmt.Printf("write file error=%v\n", err) &#125;&#125; 判断文件是否存在golang判断文件或文件夹是否存在的方法为 os.Stat() 函数返回的错误值进行判断: 如果返回的错误为nil, 说明文件或文件夹存在 如果返回的错误类型使用 os.IsNotExist() 判断为true, 说明文件或文件夹不存在 如果返回的错误为其他类型,则不确定是否存在 12345678910func PathExists(path string) (bool, error) &#123; _, err := os.Stat(path) if err == nil &#123; //文件或者目录存在 return true, nil &#125; if os.IsNotExist(err) &#123; return false, nil &#125; return false, err&#125; 文件编程应用实例拷贝文件说明: 将一个文件拷贝到另外一个文件 所需函数: func Copy(dst Writer, src Reader) (written int64, err error) 注意: Copy 函数是 io 包提供的 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( "bufio" "fmt" "io" "os")//自己编写一个函数, 接收两个文件的路径 (srcFileName, dstFileName)func CopyFile(dstFileName string, srcFileName string) (written int64, err error) &#123; srcFile, err := os.Open(srcFileName) if err != nil &#123; fmt.Printf("open file err=%v\n", err) &#125; defer srcFile.Close() //通过srcfile, 获取到 Reader reader := bufio.NewReader(srcFile) //先创建目标文件, 打开 dstFileName dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, 0666) if err != nil &#123; fmt.Printf("open file err=%v\n", err) return &#125; //通过dstFile, 获取到 Writer,将原文件的内容写入到目标文件中 writer := bufio.NewWriter(dstFile) defer dstFile.Close() return io.Copy(writer, reader)&#125;func main() &#123; //将 a.txt 文件拷贝到 b.txt //调用CopyFile 完成文件拷贝 srcFile := "/usr/local/go/src/golang_study/14-File/filedemo6/main/a.txt" dstFile := "/usr/local/go/src/golang_study/14-File/filedemo6/main/b.txt" _, err := CopyFile(dstFile, srcFile) if err == nil &#123; fmt.Printf("拷贝完成\n") &#125; else &#123; fmt.Printf("拷贝错误 err=%v\n", err) &#125;&#125; 统计英文、数字、空格和其他字符数量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( "bufio" "fmt" "io" "os")//定义一个结构体, 用于保存统计结果type CharCount struct &#123; ChCount int //记录英文个数 NumCount int //记录数字的个数 SpaceCount int //记录空格的个数 OtherCount int //记录其他字符的个数&#125;func main() &#123; //思路: 打开一个文件,创建一个 Reader //每读取一行, 就去统计该行有多少个 英文 数字 空格 和 其他字符 //然后将结果保存到一个结构体 fileName := "/usr/local/go/src/golang_study/14-File/filedemo7/main/char.txt" file, err := os.Open(fileName) if err != nil &#123; fmt.Printf("open file err=%v\n", err) return &#125; defer file.Close() //定义个 CharCount 实例 var count CharCount //创建一个 Reader reader := bufio.NewReader(file) //开始循环的读取 fileName 的内容 for &#123; str, err := reader.ReadString('\n') if err == io.EOF &#123; break &#125; //为了兼容中文字符, 可以将 str 转成 []rune str1 := []rune(str) //遍历 str, 进行统计 for _, v := range str1 &#123; switch &#123; case v &gt;= 'a' &amp;&amp; v &lt;= 'z': fallthrough //穿透 case v &gt;= 'A' &amp;&amp; v &lt;= 'Z': count.ChCount++ case v == ' ' || v == '\t': count.SpaceCount++ case v &gt;= '0' &amp;&amp; v &lt;= '9': count.NumCount++ default: count.OtherCount++ &#125; &#125; &#125; //输出统计的结果 fmt.Printf("字符的个数=%v, 数字的个数=%v, 空格的个数=%v, 其他字符个数=%v\n", count.ChCount, count.NumCount, count.SpaceCount, count.OtherCount)&#125; 命令行参数 os.Args 是一个 string 的切片，用来存储所有的命令行参数 1234567891011121314package mainimport ( "fmt" "os")func main() &#123; fmt.Println("命令行的参数有", len(os.Args)) //遍历os.Args切片,就可以得到所有的命令行输入参数值 for i, v := range os.Args &#123; fmt.Printf("args[%v]=%v\n", i, v) &#125;&#125; 执行结果 flag 包用来解析命令行参数 说明: 前面的方式是比较原生的方式，对解析参数不是特别的方便，特别是带有指定参数形式的命令行。 比如: cmd&gt;main.exe -f a.txt -p 200 -u root 这样的形式命令行，go 设计者给我们提供了 flag 包，可以方便的解析命令行参数，而且参数顺序可以随意 123456789101112131415161718192021222324252627package mainimport ( "flag" "fmt")func main() &#123; //定义几个变量,用于接收命令行的参数值 var user string var pwd string var host string var port int //&amp;user 就是接收用户命令中输入的 -u 后面的参数值 //"u" 就是 -u 指定参数 //"" 默认值 //"用户名,默认为空" 说明 flag.StringVar(&amp;user, "u", "", "用户名,默认为空") flag.StringVar(&amp;pwd, "pwd", "", "密码,默认为空") flag.StringVar(&amp;host, "h", "localhost", "主机名, 默认为localhost") flag.IntVar(&amp;port, "port", 3306, "端口号,默认为3306") //这里有一个非常重要的操作, 转换, 必须调用该方法 flag.Parse() //输出结果 fmt.Printf("user=%v pwd=%v host=%v port=%v\n", user, pwd, host, port)&#125; json基本介绍 JSON易于机器解析和生成,并有效的提升网络传输效率,通常程序在网络传输时,会先将数据(结构体/map等)序列化成json字符串,到接收方得到json字符串时,在反序列化恢复成原来的数据类型(结构体/map等) json数据格式说明 在json语言中,一切都是对象.因此,任何的数据类型都可以通过json来表示,例如字符串,数字,对象,数组,map,结构体等 1[&#123;"key1":val1, "key2":val2&#125;,&#123;"key1":val1, "key2":val2, "key3":[val3, val4]&#125;] json的序列化 json 序列化是指，将有 key-value 结构的数据类型(比如结构体、map、切片)序列化成 json 字符串的操作。 应用案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package mainimport ( "encoding/json" "fmt")//定义一个结构体type Monster struct &#123; Name string Age int Birthday string Sal float64 Skill string&#125;func testStruct() &#123; //演示 monster := Monster&#123; Name: "牛魔王", Age: 500, Birthday: "2022-08-23", Sal: 8000.0, Skill: "牛魔拳", &#125; //将 monster 序列化 data, err := json.Marshal(&amp;monster) if err != nil &#123; fmt.Printf("序列号错误 err=%v\n", err) &#125; //输出序列化后的结果 fmt.Printf("monster 序列化后=%v\n", string(data))&#125;//将 map 进行序列化func testMap() &#123; //定义一个map var a map[string]interface&#123;&#125; //使用 map,需要 make a = make(map[string]interface&#123;&#125;) a["name"] = "红孩儿" a["age"] = 30 a["address"] = "洪崖洞" //将 a 这个map进行序列化 //将 monster 序列化 data, err := json.Marshal(a) if err != nil &#123; fmt.Printf("序列化错误 err=%v\n", err) &#125; //输出序列化后的结果 fmt.Printf("a map 序列化后=%v\n", string(data))&#125;//演示对切片进行序列化,我们这个切片 []map[string]interface&#123;&#125;func testSlice() &#123; var slice []map[string]interface&#123;&#125; var m1 map[string]interface&#123;&#125; //使用 map 前, 需要先 make m1 = make(map[string]interface&#123;&#125;) m1["name"] = "jack" m1["age"] = "7" m1["address"] = "北京" slice = append(slice, m1) var m2 map[string]interface&#123;&#125; //使用 map 前, 需要先 make m2 = make(map[string]interface&#123;&#125;) m2["name"] = "tom" m2["age"] = "20" m2["address"] = [2]string&#123;"墨西哥", "夏威夷"&#125; slice = append(slice, m2) //将切片进行序列化操作 data, err := json.Marshal(slice) if err != nil &#123; fmt.Printf("序列化错误 err=%v\n", err) &#125; //输出序列化后的结果 fmt.Printf("slice 序列化后=%v\n", string(data))&#125;//对基本数据类型序列化, 对基本数据类型进行序列化意义不大func testFloat64() &#123; var num1 float64 = 2345.67 //对 num1 进行序列化 data, err := json.Marshal(num1) if err != nil &#123; fmt.Printf("序列化错误 err=%v\n", err) &#125; //输出序列化后的结果 fmt.Printf("num1 序列化后=%v\n", string(data))&#125;func main() &#123; //演示将结构体,map,切片进行序列号 testStruct() testMap() testSlice() //演示对切片的序列化 testFloat64() //演示对基本数据类型的序列化&#125; 注意事项 对于结构体的序列化，如果我们希望序列化后的 key 的名字，又我们自己重新制定，那么可以给 struct 指定一个 tag 标签. 12345678//定义一个结构体type Monster struct &#123; Name string `json:"monster_name"` Age int `json:"monster_age"` Birthday string Sal float64 Skill string&#125; json的反序列化 json 反序列化是指，将 json 字符串反序列化成对应的数据类型(比如结构体、map、切片)的操作 应用案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( "encoding/json" "fmt")//定义一个结构体type Monster struct &#123; Name string Age int Birthday string Sal float64 Skill string&#125;//演示将json字符串,反序列化为 structfunc unmarshalStruct() &#123; //说明: str 在项目开发中,是通过网络传输获取到..或者是读取到文件获取到 str := "&#123;\"Name\":\"牛魔王\", \"Age\":500, \"Birthday\":\"2022-08-23\", \"Sal\":8000, \"Skill\":\"牛魔拳\"&#125;" //定义一个Monster实例 var monster Monster err := json.Unmarshal([]byte(str), &amp;monster) if err != nil &#123; fmt.Printf("unmarshal err=%v\n", err) &#125; fmt.Printf("反序列化后 monster=%v monster.Name=%v\n", monster, monster.Name)&#125;//演示将json字符串,反序列化成 mapfunc unmarshalMap() &#123; str := "&#123;\"address\":\"洪崖洞\", \"age\":30, \"name\":\"红孩儿\"&#125;" //定义一个 map var a map[string]interface&#123;&#125; //反序列化 //注意: 反序列化 map, 不需要make, 因为 make 操作被封装到 Unmarshal 函数 err := json.Unmarshal([]byte(str), &amp;a) if err != nil &#123; fmt.Printf("unmarshal err=%v\n", err) &#125; fmt.Printf("反序列化后 a=%v\n", a)&#125;//演示将 json 字符串, 反序列化成切片func unmarshalSlice() &#123; str := "[&#123;\"address\":\"北京\", \"age\":\"7\", \"name\":\"jack\"&#125;," + " &#123;\"address\":[\"墨西哥\", \"夏威夷\"], \"age\":\"20\", \"name\":\"tom\"&#125;]" //定义一个slice var slice []map[string]interface&#123;&#125; //反序列化, 不需要 make, 因为 make 操作被封装到 Unmarshal 函数 err := json.Unmarshal([]byte(str), &amp;slice) if err != nil &#123; fmt.Printf("unmarshal err=%v\n", err) &#125; fmt.Printf("反序列化后 slice=%v\n", slice)&#125;func main() &#123; unmarshalStruct() unmarshalMap() unmarshalSlice()&#125; 对上面代码的说明1) 在反序列化一个json字符串时，要确保反序列化后的数据类型和原来序列化前的数据类型一致。1) 如果 json 字符串是通过程序获取到的，则不需要再对 &quot; 转义处理。 单元测试 在工作中,我们经常会确认一个函数或模块的执行结果是否正确 12345678910111213141516package mainimport "fmt"func addUpper(n int) int &#123; res := 0 for i := 1; i &lt;= n; i++ &#123; res += i &#125; return res&#125;func main() &#123; res := addUpper(10) fmt.Println("res=", res)&#125; 传统方式 在 main 函数中，调用 addUpper 函数，看看实际输出的结果是否和预期的结果一致，如果一致，则说明函数正确，否则函数有错误，然后修改错误 123456789101112131415161718192021package mainimport "fmt"func addUpper(n int) int &#123; res := 0 for i := 1; i &lt;= n; i++ &#123; res += i &#125; return res&#125;func main() &#123; res := addUpper(10) if res != 55 &#123; fmt.Printf("addUpper错误 返回值=%v 期望值=%v\n", res, 55) &#125; else &#123; fmt.Printf("addUpper正确 返回值=%v 期望值=%v\n", res, 55) &#125; fmt.Println("res=", res)&#125; 传统方式的缺点 不方便, 我们需要在 main 函数中去调用，这样就需要去修改 main 函数，如果现在项目正在运行，就可能去停止项目 不利于管理，因为当我们测试多个函数或者多个模块时，都需要写在 main 函数，不利于我们管理和清晰我们思路 引出单元测试。=&gt; testing 测试框架可以很好解决问题。 单元测试基本介绍 Go 语言中自带有一个轻量级的测试框架 testing 和自带的 go test 命令来实现单元测试和性能测试，testing 框架和其他语言中的测试框架类似，可以基于这个框架写针对相应函数的测试用例，也可以基于该框架写相应的压力测试用例。通过单元测试，可以解决如下问题: 确保每个函数是可运行，并且运行结果是正确的 确保写出来的代码性能是好的 单元测试能及时的发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让程序能够在高并发的情况下还能保持稳定 快速入门 文件目录结构 utils/cal.go 123456789package mainfunc AddUpper(n int) int &#123; res := 0 for i := 1; i &lt;= n; i++ &#123; res += i &#125; return res&#125; utils/cal_test.go 12345678910111213141516package mainimport ( "testing")func TestAddUpper(t *testing.T) &#123; res := AddUpper(10) if res != 55 &#123; // fmt.Printf("AddUpper(10) 执行错误, 期望值=%v 实际值=%v\n", 55, res) t.Fatalf("AddUpper(10) 执行错误, 期望值=%v 实际值=%v\n", 55, res) &#125; //如果正确,记录日志 t.Logf("AddUpper(10) 执行正确")&#125; 运行原理 总结1) 测试用例文件名必须以 _test.go 结尾。 比如 cal_test.go , cal 不是固定的。2) 测试用例函数必须以 Test 开头，一般来说就是 Test+被测试的函数名，比如 TestAddUpper3) TestAddUpper(t tesing.T) 的形参类型必须是 `testing.T`,可以参考: 手册(需要科学上网)4) 一个测试用例文件中，可以有多个测试用例函数，比如 TestAddUpper、TestSub5) 运行测试用例指令 cmd&gt; go test [如果运行正确，无日志，错误时，会输出日志] cmd&gt; go test -v [运行正确或是错误，都输出日志] 当出现错误时，可以使用 t.Fatalf 来格式化输出错误信息，并退出程序 t.Logf 方法可以输出相应的日志 测试用例函数，并没有放在 main 函数中，也执行了，这就是测试用例的方便之处[原理图参考上面的图片] PASS 表示测试用例运行成功，FAIL 表示测试用例运行失败 测试单个文件，一定要带上被测试的原文件 1go test -v cal_test.go cal.go 11) 测试单个方法 1go test -v -test.run TestAddUpper 综合案例 monster/monster.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package monsterimport ( "encoding/json" "fmt" "io/ioutil")type Monster struct &#123; Name string Age int Skill string&#125;//给 Monster 绑定方法 Store, 可以将一个 Monster 变量(对象), 序列化后保存到文件中func (m *Monster) Store() bool &#123; //先序列化 data, err := json.Marshal(m) if err != nil &#123; fmt.Println("marshal err=", err) return false &#125; //保存到文件 filePath := "/usr/local/go/src/golang_study/15-test/testdemo2/monster.ser" err = ioutil.WriteFile(filePath, data, 0666) if err != nil &#123; fmt.Println("write file err=", err) return false &#125; return true&#125;//给 Monster 绑定方法 ReStore, 可以将一个序列化的 Monster, 从文件中读取//并反序列化为 Monster 对象, 检查反序列化, 名字正确func (m *Monster) ReStore() bool &#123; //1.先从文件中,读取序列化的字符串 filePath := "/usr/local/go/src/golang_study/15-test/testdemo2/monster.ser" data, err := ioutil.ReadFile(filePath) if err != nil &#123; fmt.Println("ReadFile err=", err) return false &#125; //2.使用读取到 data []byte, 对反序列化 err = json.Unmarshal(data, m) if err != nil &#123; fmt.Println("Unmarshal err=", err) return false &#125; return true&#125; monster/monster_test.go 1234567891011121314151617181920212223242526272829303132333435package monsterimport ( "testing")//测试用例, 测试 Store 方法func TestStore(t *testing.T) &#123; //先创建一个 Monster 实例 monster := &amp;Monster&#123; Name: "红孩儿", Age: 10, Skill: "吐火~", &#125; res := monster.Store() if !res &#123; t.Fatalf("monster.Store() 错误, 希望为=%v 实际为=%v", true, res) &#125; t.Logf("monster.Store() 测试成功!")&#125;func TestReStore(t *testing.T) &#123; //先创建一个 Monster 实例, 不需要指定字段的值 var monster = &amp;Monster&#123;&#125; res := monster.ReStore() if !res &#123; t.Fatalf("monster.ReStore() 错误, 希望为=%v 实际为%v", true, res) &#125; //进一步判断 if monster.Name != "红孩儿" &#123; t.Fatalf("monster.ReStore() 错误, 希望为=%v 实际为=%v", "红孩儿", monster.Name) &#125; t.Logf("monster.ReStore() 测试成功!")&#125; 执行后会在指定位置生成monster.ser文件 文件内容如下 goroutine 和 channelgoroutine(协程)进程与线程 进程就是程序在操作系统中的一次执行过程, 是系统进行资源分配和调度的基本单位 线程是进程的一个执行实例, 是程序执行的基本单位 一个进程可以任意创建和销毁多个线程,同一个进程中的多个线程可以并发执行 一个程序至少有一个进程,一个进程至少有一个线程 程序、进程和线程的关系123程序 =&gt; 进程1 =&gt; &#123;线程1, 线程2...&#125; 进程2 =&gt; &#123;线程1, 线程2...&#125; ... 并发与并行 多线程程序在单核上运行,就是并发 多线程程序在多核上运行,就是并行 Go协程与Go主线程 Go 主线程(有程序员直接称为线程/也可以理解成进程): 一个 Go 线程上，可以起多个协程，你可以这样理解，协程是轻量级的线程[编译器做优化]。 Go协程的特点 1) 有独立的栈空间2) 共享程序堆空间3) 调度由用户控制4) 协程是轻量级的线程 goroutine快速入门 请编写一个程序，完成如下功能: 1) 在主线程(可以理解成进程)中，开启一个 goroutine, 该协程每隔 1 秒输出 “hello,world” 2) 在主线程中也每隔一秒输出”hello,golang”, 输出 10 次后，退出程序 3) 要求主线程和 goroutine 同时执行. 4) 画出主线程和协程执行流程图 12345678910111213141516171819202122package mainimport ( "fmt" "strconv" "time")func test() &#123; for i := 0; i &lt;= 10; i++ &#123; fmt.Println("test() hello world " + strconv.Itoa(i)) time.Sleep(time.Second) &#125;&#125;func main() &#123; go test() //开启一个协程 for i := 1; i &lt;= 10; i++ &#123; fmt.Println("main() hello golang" + strconv.Itoa(i)) time.Sleep(time.Second) &#125;&#125; main 主线程和 test 协程同时执行 执行流程图 小结 1) 主线程是一个物理线程，直接作用在 cpu 上的。是重量级的，非常耗费 cpu 资源。2) 协程从主线程开启的，是轻量级的线程，是逻辑态。对资源消耗相对小。3) Golang的协程机制是重要的特点，可以轻松的开启上万个协程。其它编程语言的并发机制是一般基于线程的，开启过多的线程，资源耗费大，这里就突显 Golang 在并发上的优势了 goroutine的调度模型MPG 模式-状态一 当前程序有三个M,如果三个M都在一个CPU运行,就是并发,如果在不同的CPU运行就是并行 M1,M2,M3正在执行一个G,M1的协程队列有三个,M2的协程队列有三个,M3协程队列有两个 从上图可以看到: Go的协程是轻量级的线程,是逻辑态的,Go可以容易的起上万个协程 其他程序c/java的多线程,往往是内核态的,比较重量级,千个线程可能耗光CPU MPG模式-状态二 分成两个部分来看 原来的情况是 M0 主线程正在执行G0协程,另外有三个协程在队列等待 如果G0协程阻塞,比如读取文件或者数据库等 这时就会创建M1主线程(也可能是从已有的线程池中取出M1),并且将等待的3个协程挂到M1下开始执行,M0的主线程下的G0仍然执行文件io的读写 这样的MPG调度模式,可以既让G0执行,同时也不会让队列的其他协程一直阻塞,仍然可以并发/并行执行 等到G0不阻塞了,M0会被放到空闲的主线程继续执行(从已有的线程池中取),同时G0又会被唤醒 设置golang运行的CPU数量 为了充分了利用多 cpu 的优势，在 Golang 程序中，设置运行的 cpu 数目 1234567891011121314package mainimport ( "fmt" "runtime")func main() &#123; //获取当前系统CPU的数量 num := runtime.NumCPU() //设置num-1的cpu运行go程序 runtime.GOMAXPROCS(num) fmt.Println("num=", num)&#125; go1.8后: 默认让程序运行在多个核上,可以不用设置了 go1.8前: 还是要设置一下,可以更高效的利用CPU channel(管道) 先看一个需求 需求: 现在要计算 1-200 的各个数的阶乘,并且把各个数的阶乘放入到 map 中, 最后显示出来, 要求使用 toroutine 完成 *思路:* *1.编写一个函数, 来计算各个数的阶乘,放入到 map 中* *2.我们启动的协程多个,统计的将结果放入到 map 中* *3.map 应该做出一个全局的* 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( "fmt" "time")//需求: 现在要计算 1-200 的各个数的阶乘,并且把各个数的阶乘放入到 map 中//最后显示出来, 要求使用 toroutine 完成/* 思路: 1.编写一个函数, 来计算各个数的阶乘,放入到 map 中 2.我们启动的协程多个,统计的将结果放入到 map 中 3.map 应该做出一个全局的*/var ( myMap = make(map[int]int, 10))// test 函数就是计算n!, 让将这个结果放入到 myMapfunc test(n int) &#123; res := 1 for i := 1; i &lt;= n; i++ &#123; res *= i &#125; // 这里将 res 放入到 myMap myMap[n] = res&#125;func main() &#123; // 开启多个协程完成这个任务 for i := 1; i &lt;= 200; i++ &#123; go test(i) &#125; // 休眠5秒钟(第二个问题) time.Sleep(time.Second * 5) //输出结果 for i, v := range myMap &#123; fmt.Printf("map[%d]=%d\n", i, v) &#125;&#125; 此时运行会报错 报错的原因是资源竞争,因为我的笔记本电脑只有8个CPU,当200个协程同时进行写操作时,就会出现这个问题 不同 goroutine 之间如何通讯 全局变量的互斥锁 使用管道 channel 来解决 全局变量加锁同步 因为没有对全局变量 m 加锁，因此会出现资源争夺问题，代码会出现错误，提示 concurrent map writes 解决方案: 加入互斥锁 我们的数的阶乘很大，结果会越界,可以将求阶乘改成 sum += uint64(i) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( "fmt" "sync" "time")//需求: 现在要计算 1-200 的各个数的阶乘,并且把各个数的阶乘放入到 map 中//最后显示出来, 要求使用 toroutine 完成/* 思路: 1.编写一个函数, 来计算各个数的阶乘,放入到 map 中 2.我们启动的协程多个,统计的将结果放入到 map 中 3.map 应该做出一个全局的*/var ( myMap = make(map[int]int, 10) /* 声明一个全局的互斥锁 lock 是一个全局的互斥锁 sync 是包: synchornized 同步 Mutex: 是互斥 */ lock sync.Mutex)// test 函数就是计算n!, 让将这个结果放入到 myMapfunc test(n int) &#123; res := 1 for i := 1; i &lt;= n; i++ &#123; res *= i &#125; // 这里将 res 放入到 myMap //加锁 lock.Lock() myMap[n] = res //解锁 lock.Unlock()&#125;func main() &#123; // 开启多个协程完成这个任务 for i := 1; i &lt;= 200; i++ &#123; go test(i) &#125; // 休眠5秒钟(第二个问题) time.Sleep(time.Second * 5) //输出结果 lock.Lock() for i, v := range myMap &#123; fmt.Printf("map[%d]=%d\n", i, v) &#125; lock.Unlock()&#125; 再次运行 此时会发现,阶乘的结果会有0和负数 因为我们给定的200太大了,会越界,改小一些即可 channel的意义 前面使用全局变量加锁同步来解决 goroutine 的通讯，但不完美 主线程在等待所有 goroutine 全部完成的时间很难确定，我们这里设置 10 秒，仅仅是估算。 如果主线程休眠时间长了，会加长等待时间，如果等待时间短了，可能还有 goroutine 处于工作状态，这时也会随主线程的退出而销毁 通过全局变量加锁同步来实现通讯，也并不利用多个协程对全局变量的读写操作。 上面种种分析都在呼唤一个新的通讯机制: channel channel的基本介绍 channle 本质就是一个数据结构-队列 数据是先进先出【FIFO : first in first out】 线程安全，多 goroutine 访问时，不需要加锁，就是说 channel 本身就是线程安全的 channel 有类型的，一个 string 的 channel 只能存放 string 类型数据。 channel的声明1234var intChan chan int (intChan 用于存放 int 数据)var mapChan chan map[int]string (mapChan 用于存放 map[int]string 类型) var perChan chan Personvar perChan2 chan *Person channel 是引用类型 channel 必须初始化才能写入数据, 即 make 后才能使用 管道是有类型的，intChan 只能写入 整数 int channel应用案例123456789101112131415161718192021222324252627282930313233343536package mainimport "fmt"func main() &#123; //演示一下管道的使用 //1. 创建一个可以存放 3 个 int 类型的管道 var intChan chan int intChan = make(chan int, 3) //2. 看看 intChan 是什么 fmt.Printf("intChan 的值=%v intChan 本身的地址=%p\n", intChan, &amp;intChan) //3. 向管道写入数据 intChan &lt;- 10 num := 211 intChan &lt;- num intChan &lt;- 50 //intChan &lt;- 98 //注意点, 当我们给管道写入数据时,不能超过其容量 //4. 看看管道的长度和cap(容量) fmt.Printf("channel len=%v cap=%v \n", len(intChan), cap(intChan)) //5. 从管道中读取数据 var num2 int num2 = &lt;-intChan fmt.Println("num2=", num2) //先进先出,所以是10 fmt.Printf("channel len=%v cap=%v \n", len(intChan), cap(intChan)) //2, 3 //6. 在没有使用协程的情况下, 如果我们的管道数据已经全部取出,再取就会报告 deadlock num3 := &lt;-intChan num4 := &lt;-intChan num5 := &lt;-intChan fmt.Println("num3=", num3, "num4=", num4, "num5=", num5)&#125; 当我们从intChan取出第一个数据时, intChan的长度就 -1 正如我们所料, 当程序执行到num3时,就报错了 channel的注意事项 channel中只能存放指定的数据类型 channle的数据放满后，就不能再放入了 如果从 channel 取出数据后，可以继续放入 在没有使用协程的情况下，如果 channel 数据取完了，再取，就会报 dead lock 读写channel案例演示 创建一个intChan, 最多可以存放3个int, 演示存3个数据到intChan, 然后再取出这三个int 1234567891011121314151617181920package mainimport "fmt"func main() &#123; var intChan chan int intChan = make(chan int, 3) intChan &lt;- 10 intChan &lt;- 20 intChan &lt;- 10 //因为 intChan 的容量为3, 再存放会报告 dead lock //intChan &lt;- 50 num1 := &lt;-intChan num2 := &lt;-intChan num3 := &lt;-intChan //因为 intChan 这时已经没有数据了, 再取就会报告 deadlock //num4 := &lt;- intChan fmt.Printf("num1=%v num2=%v num3=%v\n", num1, num2, num3)&#125; 创建一个mapChan,最多可以存放10个map[string]string, 的 key-value,演示写入和读取 12345678910111213141516171819202122232425262728293031package mainimport "fmt"func main() &#123; var mapChan chan map[string]string mapChan = make(chan map[string]string, 10) m1 := make(map[string]string, 20) m1["city1"] = "北京" m1["city2"] = "天津" m2 := make(map[string]string, 20) m2["hero1"] = "宋江" m2["hero2"] = "武松" //写入channel mapChan &lt;- m1 mapChan &lt;- m2 //定义一个数组接收channel数值 var arr []map[string]string = []map[string]string&#123;&#125; arr = make([]map[string]string, 10) l := len(mapChan) //提前记录好channel的长度,因为每一次循环,channel的长度都会发生变化 //循环输出 for i := 0; i &lt; l; i++ &#123; arr[i] = &lt;-mapChan fmt.Printf("第 %v 个值为 %v \n", i+1, arr[i]) &#125;&#125; 创建一个catChan,最多可以存放10个Cat结构体变量,演示写入和读取的方法 12345678910111213141516171819202122package mainimport "fmt"type Cat struct &#123; Name string&#125;func main() &#123; var catChan chan Cat catChan = make(chan Cat, 10) cat1 := Cat&#123;Name: "tom"&#125; cat2 := Cat&#123;Name: "jerry"&#125; catChan &lt;- cat1 catChan &lt;- cat2 cat11 := &lt;-catChan cat22 := &lt;-catChan fmt.Println(cat11, cat22)&#125; 创建一个catChan,最多可以存放10个 *Cat 结构体变量,演示写入和读取的方法 12345678910111213141516171819202122package mainimport "fmt"type Cat struct &#123; Name string&#125;func main() &#123; var catChan chan *Cat catChan = make(chan *Cat, 10) cat1 := Cat&#123;Name: "tom"&#125; cat2 := Cat&#123;Name: "jerry"&#125; catChan &lt;- &amp;cat1 catChan &lt;- &amp;cat2 cat11 := &lt;-catChan cat22 := &lt;-catChan fmt.Println(cat11, cat22)&#125; 创建一个allChan,最多可以存放10个任意数据类型变量,演示写入和读取的方法 1234567891011121314151617181920212223242526package mainimport "fmt"type Cat struct &#123; Name string&#125;func main() &#123; var allChan chan interface&#123;&#125; allChan = make(chan interface&#123;&#125;, 10) cat1 := Cat&#123;Name: "tom"&#125; cat2 := Cat&#123;Name: "jerry"&#125; allChan &lt;- cat1 allChan &lt;- cat2 allChan &lt;- 10 allChan &lt;- "fuck" cat11 := &lt;-allChan cat22 := &lt;-allChan v1 := &lt;-allChan v2 := &lt;-allChan fmt.Println(cat11, cat22, v1, v2)&#125; 观察以下代码,会出现什么问题? 1234567891011121314151617181920212223package mainimport "fmt"type Cat struct &#123; Name string&#125;func main() &#123; var allChan chan interface&#123;&#125; allChan = make(chan interface&#123;&#125;, 10) cat1 := Cat&#123;Name: "tom"&#125; cat2 := Cat&#123;Name: "jerry"&#125; allChan &lt;- cat1 allChan &lt;- cat2 allChan &lt;- 10 allChan &lt;- "fuck" cat11 := &lt;-allChan fmt.Println(cat11.Name) //直接调用会出现问题&#125; 代码改进 123456789101112131415161718192021222324package mainimport "fmt"type Cat struct &#123; Name string&#125;func main() &#123; var allChan chan interface&#123;&#125; allChan = make(chan interface&#123;&#125;, 10) cat1 := Cat&#123;Name: "tom"&#125; cat2 := Cat&#123;Name: "jerry"&#125; allChan &lt;- cat1 allChan &lt;- cat2 allChan &lt;- 10 allChan &lt;- "fuck" cat11 := &lt;-allChan name := cat11.(Cat) fmt.Println(name)&#125; channel的遍历和关闭channel的关闭 使用内置函数 close 可以关闭 channel, 当 channel 关闭后，就不能再向 channel 写数据了，但是仍然可以从该 channel 读取数据 12345678910111213141516package mainimport "fmt"func main() &#123; intChan := make(chan int, 3) intChan &lt;- 100 intChan &lt;- 200 close(intChan) //这时不能够再写入数到 channel //intChan &lt;- 300 fmt.Println("ok~") //当管道关闭后,可以读取数据 n1 := &lt;-intChan fmt.Println("n1=", n1)&#125; channel的遍历channel 支持 for–range 的方式进行遍历，请注意两个细节: 在遍历时，如果 channel 没有关闭，则回出现 deadlock 的错误 在遍历时，如果 channel 已经关闭，则会正常遍历数据，遍历完后，就会退出遍历。 演示案例 123456789101112131415161718package mainimport "fmt"func main() &#123; intChan := make(chan int, 100) //for i := 0; i &lt; len(intChan); i++ &#123;&#125; //遍历管道不能使用普通的 for 循环 for i := 0; i &lt; 100; i++ &#123; intChan &lt;- i * 2 //放入100个数据到管道 &#125; //在遍历时,如果channel没有关闭, 则会出现deadlock的错误 //在遍历时,如果channel已经关闭, 则会正常遍历数据, 遍历完后, 就会退出遍历 close(intChan) for v := range intChan &#123; fmt.Println("v=", v) &#125;&#125; 应用实例1 请完成goroutine和channel协同工作的案例,具体要求: 1) 开启一个writeData协程,向管道intChan中读取writeData写入的数据 2) 开启一个readData协程,从管道intChan中读取writeData写入的数据 3) 注意: writeData和readData操作的是同一个管道 4) 主线程需要等待writeData和readData协程都完成工作才能退出管道 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport "fmt"//写数据func writeData(intChan chan int) &#123; for i := 1; i &lt;= 50; i++ &#123; //放入数据 intChan &lt;- i fmt.Println("writeData ", i) &#125; close(intChan) //关闭&#125;//读数据func readData(intChan chan int, exitChan chan bool) &#123; for &#123; v, ok := &lt;-intChan if !ok &#123; break &#125; fmt.Printf("readData 读到数据=%v\n", v) &#125; //readData 读取完数据后, 即任务完成 exitChan &lt;- true close(exitChan)&#125;func main() &#123; //创建两个管道 intChan := make(chan int, 50) exitChan := make(chan bool, 1) go writeData(intChan) go readData(intChan, exitChan) for &#123; _, ok := &lt;-exitChan if !ok &#123; break &#125; &#125;&#125; 应用实例2-阻塞 如果将上面代码中的readData协程注释掉,不进行读操作,会怎么样? 123456789101112131415func main() &#123; //创建两个管道 intChan := make(chan int, 50) exitChan := make(chan bool, 1) go writeData(intChan) //go readData(intChan, exitChan) for &#123; _, ok := &lt;-exitChan if !ok &#123; break &#125; &#125;&#125; 这样做的话,程序只是向管道内写入数据,而没有进行读取,就会出现阻塞deadlock, 原因是intChan容量是10,而代码writeData会写入50个数据,因此会阻塞在 writeData 的 channel &lt;- i 应用实例3 要求统计 1-200000 的数字中，哪些是素数?这个问题在本章开篇就提出了，现在我们有 goroutine 和 channel 的知识后，就可以完成了 [测试数据: 80000] 传统的方法，就是使用一个循环，循环的判断各个数是不是素数【ok】。 使用并发/并行的方式，将统计素数的任务分配给多个(4 个)goroutine 去完成，完成任务时间短。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package mainimport ( "fmt" "time")//向 intChan 放入 1-8000个数func putNum(intChan chan int) &#123; for i := 1; i &lt;= 8000; i++ &#123; intChan &lt;- i &#125; //关闭 intChan close(intChan)&#125;//从 intChan 取出数据, 并判断是否为素数,如果是, 就放入到 primeChanfunc primeNum(intChan chan int, primeChan chan int, exitChan chan bool) &#123; var flag bool //循环读取数据,进行素数的判断 for &#123; time.Sleep(time.Millisecond * 10) num, ok := &lt;-intChan //读取数据 if !ok &#123; //intChan取不到 break &#125; flag = true //判断 num 是不是素数 //取余数,除了1和其本身以外,结果都不能为0的话,那么这个数就为素数 for i := 2; i &lt; num; i++ &#123; if num%i == 0 &#123; flag = false break &#125; &#125; if flag &#123; //将这个数放入到 primeChan primeChan &lt;- num &#125; &#125; fmt.Println("有一个 primeNum 协程因为取不到数据, 退出") //这里我们还不能关闭 primeChan //向 exitChan 写入 true exitChan &lt;- true&#125;func main() &#123; //声明管道 intChan := make(chan int, 1000) primeChan := make(chan int, 2000) //放入结果 exitChan := make(chan bool, 4) //因为有4个协程 //开启一个协程, 向 intChan 放入 1-8000 个数 go putNum(intChan) //开启 4 个协程, 从 intChan 取出数据, 并判断是否为素数, 如果是,则放入到 primeChan //4 个协程都是使用的同一个管道 for i := 0; i &lt; 4; i++ &#123; go primeNum(intChan, primeChan, exitChan) &#125; //这里我们主线程, 进行处理 //这里利用协程go去跑(相当于在后台跑),我们就可以马上在下面输出素数的结果 go func() &#123; for i := 0; i &lt; 4; i++ &#123; &lt;-exitChan //当管道 exitChan 没有数据时,这个循环就会一直处于等待状态 &#125; //当我们从 exitChan 取出了 4 个结果, 就可以放心的关闭 primeChan close(primeChan) &#125;() fmt.Println("开始输出素数...") //遍历我们的 primeChan, 把结果取出 for &#123; res, ok := &lt;-primeChan if !ok &#123; break &#125; //将结果输出 fmt.Printf("素数=%d\n", res) &#125; fmt.Println("main 线程退出")&#125; 执行结果: channel注意事项 channel可以声明为只读，或者只写性质 12345678910111213141516171819package mainimport "fmt"func main() &#123; //1.在默认情况下, 管道时双向的 //var chan1 chan int //可读可写 //2.声明为只写 chan2 := make(chan&lt;- int, 3) chan2 &lt;- 20 //num := &lt;-chan2 //error fmt.Println("chan2=", chan2) //3.声明为只读 var chan3 &lt;-chan int num2 := &lt;-chan3 //chan3&lt;- 30 //error fmt.Println("num2=", num2)&#125; channel只读和只写的最佳实践案例 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport "fmt"//只写func send(ch chan&lt;- int, exitChan chan struct&#123;&#125;) &#123; for i := 0; i &lt; 10; i++ &#123; ch &lt;- i &#125; close(ch) var a struct&#123;&#125; exitChan &lt;- a&#125;//只读func recv(ch &lt;-chan int, exitChan chan struct&#123;&#125;) &#123; for &#123; v, ok := &lt;-ch if !ok &#123; break &#125; fmt.Println(v) &#125; var a struct&#123;&#125; exitChan &lt;- a&#125;func main() &#123; ch := make(chan int, 10) exitChan := make(chan struct&#123;&#125;, 2) go send(ch, exitChan) go recv(ch, exitChan) var total = 0 for range exitChan &#123; total++ if total == 2 &#123; break &#125; &#125; fmt.Println("结束...")&#125; 使用 select 可以解决从管道取数据的阻塞问题 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( "fmt" "time")func main() &#123; //使用 select 可以解决从管道取数据的阻塞问题 //1.定义一个管道; 10个数据 int intChan := make(chan int, 10) for i := 0; i &lt; 10; i++ &#123; intChan &lt;- i &#125; //2.定义一个管道; 5个数据 string stringChan := make(chan string, 5) for i := 0; i &lt; 5; i++ &#123; stringChan &lt;- "hello" + fmt.Sprintf("%d", i) &#125; //传统的方法在遍历管道时, 如果不关闭会阻塞而导致 deadlock //问题: 在实际开发中, 可能我们不好确定什么时候关闭该管道 //可以使用 select 方式来解决 for &#123; select &#123; //注意, 如果 intChan 一直没有关闭, 不会一直阻塞而 deadlock //会自动到下一个 case 匹配 case v := &lt;-intChan: fmt.Printf("从 intChan 读取的数据%d\n", v) time.Sleep(time.Second) case v := &lt;-stringChan: fmt.Printf("从 stringChan 读取的数据%s\n", v) time.Sleep(time.Second) default: fmt.Printf("都取不到了, 不玩儿了, 程序员可以加入逻辑\n") time.Sleep(time.Second) return &#125; &#125;&#125; goroutine中使用recover，解决协程中出现panic，导致程序崩溃问题 如果我们启动了一个协程, 但是这个协程出现了panic, 如果我们没有捕获到这和panic,就会造成整个程序崩溃,这时我们可以在 goroutine 中使用 recover 来捕获 panic, 进行处理,这样即使这个协程发生了问题,但是主线程仍然不受影响,可以继续执行 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( "fmt" "time")func sayHello() &#123; for i := 0; i &lt; 10; i++ &#123; time.Sleep(time.Second) fmt.Println("hello world") &#125;&#125;func test() &#123; //这里我们可以使用 defer + recover defer func() &#123; //捕获 test 抛出的 panic if err := recover(); err != nil &#123; fmt.Println("test() 发生错误", err) &#125; &#125;() //定义一个 map var myMap map[int]string // myMap = make(map[int]string, 0) myMap[0] = "golang" //error&#125;func main() &#123; go sayHello() go test() for i := 0; i &lt; 10; i++ &#123; fmt.Println("main() ok=", i) time.Sleep(time.Second) &#125;&#125; 反射反射的基本介绍1) 反射可以在运行时动态获取变量的各种信息, 比如变量的类型(type)，类别(kind)2) 如果是结构体变量，还可以获取到结构体本身的信息(包括结构体的字段、方法)3) 通过反射，可以修改变量的值，可以调用关联的方法。4) 使用反射，需要 import (“reflect”) 包反射实现运行时反射，允许程序操作具有任意类型的对象。典型的用法是使用静态类型接口{}获取一个值，并通过调用TypeOf提取其动态类型信息，它返回一个type。 对ValueOf的调用将返回一个表示运行时数据的Value。Zero接受一个Type并返回一个Value，表示该类型的0值。 应用场景常见的反射应用场景有以下两种 不知道接口调用哪个函数,根据传入参数在运行时确定调用的具体接口,这种需要对函数或方法反射,例如以下这种桥接模式,比如我前面提出问题 1func bridge(funcPtr interface&#123;&#125;, args ...interface&#123;&#125;) 第一个参数 funcPtr 以接口的形式传入函数指针,函数参数 args 以可变参数的形式传入,bridge 函数中可以用反射来动态执行 funcPtr 函数 对结构体序列化时, 如果结构体有指定Tag,也会使用到反射生成对应的字符串 123456789101112131415161718192021222324package mainimport ( "encoding/json" "fmt")type Monster struct &#123; Name string `json:"name"` //打标签,注意冒号后面不要加空格 Age int `json:"age"` Skill string `json:"skill"`&#125;func main() &#123; monster := Monster&#123;"牛魔王", 500, "芭蕉扇"&#125; //将monster变量序列化为 json 格式字符串 //json.Marshal 函数中使用反射,这个讲解反射时,再详细介绍 jsonStr, err := json.Marshal(monster) if err != nil &#123; fmt.Println("json 处理错误", err) &#125; fmt.Println("jsonStr", jsonStr) //输出byte fmt.Println("jsonStr", string(jsonStr)) //byte转字符串&#125; 反射重要的函数和概念 reflect.TypeOf(变量名), 获取变量名的类型,返回reflect.Type类型 reflect.ValueOf(变量名), 获取变量的值,返回reflect.Value类型;reflect.Value 是一个结构体类型,通过 reflect.Value, 可以获取到关于该变量的很多信息 变量、interface{} 和 reflect.Value 是可以相互转换的,这点在实际开发中,会经常使用到 反射的快速入门 请编写一个案例，演示对(结构体类型、interface{}、reflect.Value)进行反射的基本操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package mainimport ( "fmt" "reflect")//演示反射func reflectTest01(b interface&#123;&#125;) &#123; //通过反射获取的传入的变量的 type, kind 值 //1. 先获取到 reflect.Type rType := reflect.TypeOf(b) fmt.Println("rType=", rType) //2. 获取到 reflect.Value rVal := reflect.ValueOf(b) n2 := 2 + rVal.Int() fmt.Println("n2=", n2) fmt.Printf("rVal=%v rVal type=%T\n", rVal, rVal) //下面我们将 rVal 转成 interface&#123;&#125; iV := rVal.Interface() //将 interface&#123;&#125; 通过断言转成需要的类型 num2 := iV.(int) fmt.Println("num2=", num2)&#125;//演示反射(对结构体的反射)func reflectTest02(b interface&#123;&#125;) &#123; //通过反射获取的传入的变量 type kind 值 //1. 先获取到 reflect.Type rType := reflect.TypeOf(b) fmt.Println("rType=", rType) //2. 获取到 reflect.Value rVal := reflect.ValueOf(b) //下面我们将 rVal 转成 interface&#123;&#125; iV := rVal.Interface() fmt.Printf("iv=%v iv type=%T\n", iV, iV) //将 interface&#123;&#125; 通过断言转成 需要的类型 //这里,我们就简单使用了一带检测的类型断言 //可以使用 switch 的断言形式来做的更加的灵活 stu, ok := iV.(Student) if ok &#123; fmt.Printf("stu.Name=%v\n", stu.Name) &#125;&#125;type Student struct &#123; Name string Age int&#125;type Monster struct &#123; Name string Age int&#125;func main() &#123; //编写一个案例 //演示对(基本数据类型/interface&#123;&#125;/reflect.Value)进行反射的基本操作 //1.先定义一个 int //var num int = 0 //reflectTest01(num) //2.定义一个 Student 的实例 stu := Student&#123; Name: "tom", Age: 20, &#125; reflectTest02(stu)&#125; 可以参考文章golang反射案例 反射的注意事项 reflect.Value.Kind，获取变量的类别，返回的是一个常量 Type 和 Kind 的区别 Type 是类型, Kind 是类别， Type 和 Kind 可能是相同的，也可能是不同的.比如(相同): var num int = 10, num的Type是int , Kind也是int比如(不同): var stu Student, stu 的 Type 是 pkg1.Student , Kind 是 struct 1234567891011121314package mainimport ( "fmt" "reflect")func main() &#123; var n int64 = 10 nType := reflect.TypeOf(n) nKind := reflect.Kind(n) fmt.Printf("n的Type=%v n的Kind=%v\n", nType, nKind)&#125; 执行结果 1n的Type=int64 n的Kind=uint32 通过反射可以在让变量在 interface{} 和 reflect.Value 之间相互转换 使用反射的方式来获取变量的值(并返回对应的类型),要求数据类型匹配,比如 x 是 int类型,那么就应该使用 reflect.Value(x).Int(), 而不能使用其他的,否则报panic 通过反射的来修改变量, 注意当使用 SetXxx 方法来设置需要通过对应的指针类型来完成, 这样才能改变传入的变量的值, 同时需要使用到 reflect.Value.Elem() 12345678910111213141516171819package mainimport ( "fmt" "reflect")func testInt(b interface&#123;&#125;) &#123; val := reflect.ValueOf(b) fmt.Printf("val type=%T\n", val) val.Elem().SetInt(110) //修改传入的值 fmt.Printf("val=%v\n", val)&#125;func main() &#123; var num int = 20 testInt(&amp;num) //指向地址 fmt.Println("num=", num)&#125; 执行结果 123val type=reflect.Valueval=0xc0000140a0num= 110 reflect.Value.Elem() 应该如何理解? Elem() 用于获取指针指向变量 反射最佳实践 使用反射来遍历结构体的字段，调用结构体的方法，并获取结构体标签的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package mainimport ( "fmt" "reflect")//定义一个 Monster 结构体type Monster struct &#123; Name string `json:"name"` Age int `json:"monster_age"` Score float32 `json:"成绩"` Sex string `json:"性别"`&#125;//方法: 返回两个数的和func (s Monster) GetSum(n1, n2 int) int &#123; return n1 + n2&#125;//方法: 接收四个值,给 s 赋值func (s Monster) Set(name string, age int, score float32, sex string) &#123; s.Name = name s.Age = age s.Score = score s.Sex = sex&#125;//方法: 显示 s 的值func (s Monster) Print() &#123; fmt.Println("----start----") fmt.Println(s) fmt.Println("-----end-----")&#125;func TestStruct(a interface&#123;&#125;) &#123; //获取 reflect.Type 的类型 typ := reflect.TypeOf(a) //获取 reflect.Value 的类型 val := reflect.ValueOf(a) //获取到 a 对应的类别 kd := val.Kind() //如果传入的不是struct,就退出 if kd != reflect.Struct &#123; fmt.Println("expect struct") return &#125; //获取到该结构体有几个字段 num := val.NumField() fmt.Printf("struct has %d fields\n", num) //4 //变量结构体的所有字段 for i := 0; i &lt; num; i++ &#123; fmt.Printf("Field %d: 值为=%v\n", i, val.Field(i)) //获取到 struct 标签, 注意需要通过 reflect.Type 来获取 tag 标签的值 tagVal := typ.Field(i).Tag.Get("json") //如果该字段于 tag 标签就显示, 否则就不显示 if tagVal != "" &#123; fmt.Printf("Field %d: tag为=%v\n", i, tagVal) &#125; &#125; //获取到该结构体有多少个方法 numOfMethod := val.NumMethod() fmt.Printf("struct has %d method\n", numOfMethod) //var params []reflect.Value //方法的排序默认是按照 函数名 的排序(ASCII码) val.Method(1).Call(nil) //获取到第二个方法,调用它 //调用结构体的第一个方法 Method(0) var params []reflect.Value //声明了 []reflect.Value params = append(params, reflect.ValueOf(10)) params = append(params, reflect.ValueOf(40)) res := val.Method(0).Call(params) //传入的参数是 []reflect.Value, 返回 []reflect.Value fmt.Println("res=", res[0].Int()) //返回结果, 返回的结果是 []reflect.Value*&#125;func main() &#123; //创建一个 Monster 实例 var a Monster = Monster&#123; Name: "黄皮子", Age: 400, Score: 30.8, &#125; //将 Monster 实例传递给 TestStruct 函数 TestStruct(a)&#125; 个人练习 要求: 编写一个 Cal 结构体,有两个字段 Num1和Num2 Cal的方法 GetSub(name string) 使用反射遍历 Cal 结构体所有的字段信息 使用反射机制完成对 GetSub 的调用, 输出形式为 “tom完成了减法运行, 8 - 3 = 5” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( "fmt" "reflect")type Cal struct &#123; Num1 int `json:"num1"` Num2 int `json:"num2"`&#125;//方法: 两数相减func (c Cal) GetSub(name string) &#123; res := c.Num1 - c.Num2 fmt.Printf("%v完成了减法运行, %d - %d = %d\n",name, c.Num1, c.Num2, res)&#125;func TestReflect(inter interface&#123;&#125;) &#123; interType := reflect.TypeOf(inter) interValue := reflect.ValueOf(inter) interKind := interValue.Kind() if interKind != reflect.Struct &#123; fmt.Println("不是结构体!") return &#125; num := interValue.NumField() fmt.Printf("struct has %d fields\n", num) for i := 0; i &lt; num; i++ &#123; fmt.Printf("Field %d: 值为=%v\n", i, interValue.Field(i)) //获取到 struct 标签, 注意需要通过 reflect.Type 来获取 tag 标签的值 tagVal := interType.Field(i).Tag.Get("json") //如果该字段于 tag 标签就显示, 否则就不显示 if tagVal != "" &#123; fmt.Printf("Field %d: tag为=%v\n", i, tagVal) &#125; &#125; //获取到该结构体有多少个方法 numOfMethod := interValue.NumMethod() fmt.Printf("struct has %d method\n", numOfMethod) var na []reflect.Value na = append(na, reflect.ValueOf("tom")) interValue.Method(0).Call(na)&#125;func main() &#123; var a Cal = Cal&#123; Num1: 20, Num2: 10, &#125; TestReflect(a)&#125; TCP编程 Golang 的主要设计目标之一就是面向大规模后端服务程序，网络通信这块是服务端程序必不可少也是至关重要的一部分。 网络编程有两种: 1) TCPsocket编程，是网络编程的主流。之所以叫Tcpsocket编程，是因为底层是基于Tcp/ip协议的. 比如: QQ 聊天2) b/s结构的http编程，我们使用浏览器去访问服务器时，使用的就是http协议，而http底层依旧是用 tcp socket 实现的。 比如: 京东商城 【这属于 go web 开发范畴 】 TCP/IP协议 TCP/IP(Transmission Control Protocol/Internet Protocol)的简写,中文译名为传输控制协议/因特网互联协议，又叫网络通讯协议，这个协议是 Internet 最基本的协议、Internet 国际互联网络的基础，简单地说，就是由网络层的 IP 协议和传输层的 TCP 协议组成的。 OSI与TCP/IP参考模型 端口 0号端口是保留端口 1-1024是固定端口(程序员不要使用) 22 =&gt; SSH远程登录协议 23 =&gt; telnet 21 =&gt; ftp 25 =&gt; smtp 80 =&gt; iis 7 =&gt; echo 1025-65535是动态端口(程序员可以使用) TCP-SOCKET编程快速入门服务端的处理流程 监听端口 8888 接收客户端的 TCP 连接, 建立客户端和服务器端的链接 创建 goroutine, 处理该链接的请求(通常客户端会通过链接发送请求包) 客户端的处理流程 建立与服务端的链接 发送请求数据(终端), 接收服务器端返回的结果数据 关闭链接 流程示意图 代码实现服务端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( "fmt" "net")func process(conn net.Conn) &#123; defer conn.Close() for &#123; //创建一个新的切片 buf := make([]byte, 1024) //1.等待客户端通过 conn 发送信息 //2.如果客户端没有 write[发送],那么协程就阻塞在这里 fmt.Printf("服务器在等待客户端 %s 发送信息\n", conn.RemoteAddr().String()) n, err := conn.Read(buf) //从 conn 读取 if err != nil &#123; fmt.Printf("客户端退出 err=%v\n", err) return &#125; //3.显示客户端发送的内容到服务器的终端 fmt.Print(string(buf[:n])) &#125;&#125;func main() &#123; fmt.Println("服务器开始监听...") listen, err := net.Listen("tcp", "0.0.0.0:8888") if err != nil &#123; fmt.Printf("listen err=%v\n", err) return &#125; defer listen.Close() //延时关闭listen //循环等待客户端来链接我 for &#123; //等待客户端链接 fmt.Println("等待客户端来连接...") conn, err := listen.Accept() if err != nil &#123; fmt.Println("Accept() err=", err) &#125; else &#123; fmt.Printf("Accept() suc con=%v 客户端ip=%v\n", conn, conn.RemoteAddr().String()) &#125; //这里准备一个协程, 为客户端服务 go process(conn) &#125; //fmt.Printf("listen suc=%v\n", listen)&#125; 客户端代码12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( "bufio" "fmt" "net" "os" "strings")func main() &#123; conn, err := net.Dial("tcp", "127.0.0.1:8888") if err != nil &#123; fmt.Println("client dial err=", err) return &#125; //功能一: 客户端可以发送单行数据, 然后就退出 reader := bufio.NewReader(os.Stdin) //os.Stdin 代表标准输入[终端] for &#123; //从终端读取一行用户数据, 并准备发送给服务器 line, err := reader.ReadString('\n') if err != nil &#123; fmt.Println("readString err=", err) &#125; //如果用户输入的是 exit 就退出 line = strings.Trim(line, "\r\n") if line == "exit" &#123; fmt.Println("客户端退出...") break &#125; //再将 line 发送给服务器 _, err = conn.Write([]byte(line + "\n")) if err != nil &#123; fmt.Println("conn write err=", err) &#125; &#125;&#125; 海量用户即时通讯系统开发流程 需求分析 设计阶段 编码实现 测试阶段 实施 需求分析 用户注册 用户登录 显示在线用户列表 4) 群聊(广播) 点对点聊天 离线留言 界面设计 数据库选择 项目要保存用户信息和消息数据,因此需要使用到数据库,这里我们选择使用 Redis 数据库 实现功能客户端登录菜单 功能: 显示客户端菜单 界面 二级菜单 显示在线用户列表 发送信息 信息列表 退出系统 代码实现 client/main.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( "fmt")//用户IDvar userId string//用户密码var userPwd stringfunc main() &#123; //接收用户的选择 var key string //判断是否继续显示菜单 var loop = true for &#123; fmt.Println("--------------------欢迎登录多人聊天系统--------------------") fmt.Println("\t\t\t1 登录聊天室") fmt.Println("\t\t\t2 注册用户") fmt.Println("\t\t\tq 退出系统") fmt.Println("请选择进行的操作[1|2|q]:") fmt.Scanf("%v\n", &amp;key) switch key &#123; case "1": fmt.Println("登录聊天室") case "2": fmt.Println("注册用户") case "q": fmt.Println("退出系统") loop = false default: fmt.Println("输入有误, 请重新输入!") &#125; if !loop &#123; break &#125; if key == "1" &#123; //用户登录 fmt.Println("请输入用户的Id:") fmt.Scanf("%v\n", &amp;userId) fmt.Println("请输入用户的密码:") fmt.Scanf("%v\n", &amp;userPwd) err := login(userId, userPwd) if err != nil &#123; panic(err) &#125; else &#123; fmt.Println("登录成功") &#125; &#125; &#125;&#125; client/login.go 12345678910package mainimport ( "fmt")func login(userId string, userPwd string) (err error) &#123; fmt.Printf("userId=%v, userPwd=%v\n", userId, userPwd) return nil&#125; 客户端用户登录步骤一思路分析: 先确定消息 Message 的格式和结构 然后根据上图的分析完成代码 server/main.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( "encoding/binary" "fmt" "net" "redis/src/golang_study/18-tcp/tcpdemo/common/message")// 处理客户端的通讯func proc(conn net.Conn) &#123; //延时关闭conn defer conn.Close() buf := make([]byte, 4096) //循环接收客户端发送的信息 for &#123; fmt.Println("读取客户端发送的数据...") n, err := conn.Read(buf[:4]) if n != 4 || err != nil &#123; fmt.Println("conn.Read err=", err) return &#125; fmt.Println("读取到的buf=", buf[:4]) &#125;&#125;func main() &#123; fmt.Println("服务器在 8889 端口监听中...") listen, err := net.Listen("tcp", "0.0.0.0:8889") if err != nil &#123; fmt.Println("net.Listen err=", err) return &#125; defer listen.Close() //一旦监听成功, 就等待客户端来链接服务器 for &#123; fmt.Println("等待客户端来链接服务器...") conn, err := listen.Accept() if err != nil &#123; fmt.Println("net.Accept err=", err) &#125; //一旦链接成功, 就启动一个协程和客户端保持通讯 go proc(conn) &#125;&#125; common/message/message.go 12345678910111213141516171819202122package messageconst ( LoginMesType = "LoginMes" LoginResMesType = "LoginResMes")type Message struct &#123; Type string `json:"type"` //消息类型 Data string `json:"data"` //消息的类型&#125;type LoginMes struct &#123; UserId int `json:"userId"` UserPwd string `json:"userPwd"` UserName string `json:"userName"`&#125;type LoginResMes struct &#123; Code int `json:"code"` // 返回状态码 500 表示该用户未注册, 200 表示登录成功 Error string `json:"error"` //返回错误信息&#125; client/main.go 和前面的代码一样，没有修改 client/login.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport ( "encoding/binary" "encoding/json" "fmt" "net" "redis/src/golang_study/18-tcp/tcpdemo/common/message")func login(userId int, userPwd string) (err error) &#123; // fmt.Printf("userId=%v, userPwd=%v\n", userId, userPwd) // return nil // 1. 链接到服务器 conn, err := net.Dial("tcp", "localhost:8889") if err != nil &#123; fmt.Println("net.Dial err=", err) return &#125; //延时关闭 defer conn.Close() // 2. 准备通过 conn 发送消息给服务 var mes message.Message mes.Type = message.LoginMesType // 3. 创建一个 LoginMes 结构体 var loginMes message.LoginMes loginMes.UserId = userId loginMes.UserPwd = userPwd // 4. 将 loginMes 序列化 data, err := json.Marshal(loginMes) if err != nil &#123; fmt.Println("json.Marshal err=", err) return &#125; // 5. 把data 赋值给 mes.Data 字段 mes.Data = string(data) // 6. 将 mes 进行序列化操作 data, err = json.Marshal(mes) if err != nil &#123; fmt.Println("json.Marshal err=", err) return &#125; // 7. 到这个时候, data 就是我们要发送的信息 // 先把 data 的长度发送给服务器 // 先获取到 data 的长度 =&gt; 转成一个表示长度的 byte 切片 pkgLen := uint32(len(data)) var buf [4]byte binary.BigEndian.PutUint32(buf[:4], pkgLen) // 发送长度 n, err := conn.Write(buf[:4]) if n != 4 || err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; fmt.Printf("客户端, 发送消息的长度=%d 内容=%s", len(data), string(data)) return&#125; 步骤二接下来需要完成客户端可以发送消息本身，服务器端可以正常接收到消息,并根据客户端发送的消息(LoginMes), 判断用户的合法性，并返回相应的 LoginResMes思路分析: 让客户端发送消息本身 服务器端接受到消息， 然后反序列化成对应的消息结构体. 服务器端根据反序列化成对应的消息， 判断是否登录用户是合法, 返回 LoginResMes 客户端解析返回的 LoginResMes,显示对应界面 这里我们需要做函数的封装 代码实现: 修改client/login.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package mainimport ( "encoding/binary" "encoding/json" "fmt" "net" "redis/src/golang_study/18-tcp/tcpdemo/common/message" "time")func login(userId int, userPwd string) (err error) &#123; // fmt.Printf("userId=%v, userPwd=%v\n", userId, userPwd) // return nil // 1. 链接到服务器 conn, err := net.Dial("tcp", "localhost:8889") if err != nil &#123; fmt.Println("net.Dial err=", err) return &#125; //延时关闭 defer conn.Close() // 2. 准备通过 conn 发送消息给服务 var mes message.Message mes.Type = message.LoginMesType // 3. 创建一个 LoginMes 结构体 var loginMes message.LoginMes loginMes.UserId = userId loginMes.UserPwd = userPwd // 4. 将 loginMes 序列化 data, err := json.Marshal(loginMes) if err != nil &#123; fmt.Println("json.Marshal err=", err) return &#125; // 5. 把data 赋值给 mes.Data 字段 mes.Data = string(data) // 6. 将 mes 进行序列化操作 data, err = json.Marshal(mes) if err != nil &#123; fmt.Println("json.Marshal err=", err) return &#125; // 7. 到这个时候, data 就是我们要发送的信息 // 先把 data 的长度发送给服务器 // 先获取到 data 的长度 =&gt; 转成一个表示长度的 byte 切片 pkgLen := uint32(len(data)) var buf [4]byte binary.BigEndian.PutUint32(buf[:4], pkgLen) // 发送长度 n, err := conn.Write(buf[:4]) if n != 4 || err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; //发送消息本身 _, err = conn.Write(data) if err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; // 休眠 20 秒 time.Sleep(20 * time.Second) fmt.Println("休眠了 20 秒") // fmt.Printf("客户端, 发送消息的长度=%d 内容=%s", len(data), string(data)) return&#125; 代码解释: 下图为 login.go 中修改/添加的部分 修改 server/main.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package mainimport ( "encoding/binary" "encoding/json" "fmt" "io" "net" "redis/src/golang_study/18-tcp/tcpdemo/common/message")func readPkg(conn net.Conn) (mes message.Message, err error) &#123; buf := make([]byte, 4096) fmt.Println("读取客户端发送的数据...") _, err = conn.Read(buf[:4]) if err != nil &#123; fmt.Println("conn.Read err=", err) return &#125; // 根据 buf[:4] 转成一个 uint32 类型 // var pkgLen uint32 pkgLen := binary.BigEndian.Uint32(buf[:4]) fmt.Println("读取到的buf=", buf[:4]) // 根据 pkgLen 读取消息内容 n, err := conn.Read(buf[:pkgLen]) if uint32(n) != pkgLen || err != nil &#123; fmt.Println("conn.Read fail err=", err) return &#125; // 将 pkgLen 反序列化为 message.Message // 官方解释: // func Unmarshal(data []byte, v interface&#123;&#125;) error // Unmarshal函数解析json编码的数据并将结果存入v指向的值。 err = json.Unmarshal(buf[:pkgLen], &amp;mes) if err != nil &#123; fmt.Println("json.unmarshal fail err=", err) return &#125; return mes, err&#125;// 处理客户端的通讯func proc(conn net.Conn) &#123; //延时关闭conn defer conn.Close() //循环接收客户端发送的信息 for &#123; // 这里我们将读取数据包封装成一个函数 readPkg, 返回 Message, err msg, err := readPkg(conn) if err != nil &#123; if err == io.EOF &#123; fmt.Println("客户端已经退出, 服务端自动退出...") return &#125; else &#123; fmt.Println("readPkg err=", err) return &#125; &#125; //输出客户端发送的信息 fmt.Println("msg=", msg) &#125;&#125;func main() &#123; fmt.Println("服务器在 8889 端口监听中...") listen, err := net.Listen("tcp", "0.0.0.0:8889") if err != nil &#123; fmt.Println("net.Listen err=", err) return &#125; defer listen.Close() //一旦监听成功, 就等待客户端来链接服务器 for &#123; fmt.Println("等待客户端来链接服务器...") conn, err := listen.Accept() if err != nil &#123; fmt.Println("net.Accept err=", err) &#125; //一旦链接成功, 就启动一个协程和客户端保持通讯 go proc(conn) &#125;&#125; 代码解释: 下图为 server/ming.go 中新增的函数 新增的 readPkg 函数封装了以前函数 proc 中for循环中的内容,目前的内容如下图 代码测试执行结果如下图 步骤三 能够完成登录，并提示相应信息 修改 common/message/message.go 12345678910111213141516171819202122232425262728package messageconst ( LoginMesType = "LoginMes" LoginResMesType = "LoginResMes" RegisterMesType = "RegisterMes")type Message struct &#123; Type string `json:"type"` //消息类型 Data string `json:"data"` //消息的类型&#125;type LoginMes struct &#123; UserId int `json:"userId"` UserPwd string `json:"userPwd"` UserName string `json:"userName"`&#125;type LoginResMes struct &#123; Code int `json:"code"` // 返回状态码 500 表示该用户未注册, 200 表示登录成功 Error string `json:"error"` //返回错误信息&#125;//注册逻辑type RegisterMes struct &#123; //...&#125; 修改server/main.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184package mainimport ( "encoding/binary" "encoding/json" "fmt" "io" "net" "redis/src/golang_study/18-tcp/tcpdemo/common/message")func readPkg(conn net.Conn) (mes message.Message, err error) &#123; buf := make([]byte, 4096) fmt.Println("读取客户端发送的数据...") _, err = conn.Read(buf[:4]) if err != nil &#123; fmt.Println("conn.Read err=", err) return &#125; // 根据 buf[:4] 转成一个 uint32 类型 // var pkgLen uint32 pkgLen := binary.BigEndian.Uint32(buf[:4]) fmt.Println("读取到的buf=", buf[:4]) // 根据 pkgLen 读取消息内容 n, err := conn.Read(buf[:pkgLen]) if uint32(n) != pkgLen || err != nil &#123; fmt.Println("conn.Read fail err=", err) return &#125; // 将 pkgLen 反序列化为 message.Message // 官方解释: // func Unmarshal(data []byte, v interface&#123;&#125;) error // Unmarshal函数解析json编码的数据并将结果存入v指向的值。 err = json.Unmarshal(buf[:pkgLen], &amp;mes) if err != nil &#123; fmt.Println("json.unmarshal fail err=", err) return &#125; return mes, err&#125;func writePkg(conn net.Conn, data []byte) (err error) &#123; //先发送一个长度给对方 pkgLen := uint32(len(data)) var buf [4]byte binary.BigEndian.PutUint32(buf[:4], pkgLen) // 发送长度 n, err := conn.Write(buf[:4]) if n != 4 || err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; //发送消息本身 n, err = conn.Write(data) if n != int(pkgLen) || err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; return&#125;// 处理客户端的通讯func proc(conn net.Conn) &#123; //延时关闭conn defer conn.Close() //循环接收客户端发送的信息 for &#123; // 这里我们将读取数据包封装成一个函数 readPkg, 返回 Message, err mes, err := readPkg(conn) if err != nil &#123; if err == io.EOF &#123; fmt.Println("客户端已经退出, 服务端自动退出...") return &#125; else &#123; fmt.Println("readPkg err=", err) return &#125; &#125; //输出客户端发送的信息 // fmt.Println("msg=", msg) err = ServerProcessMes(conn, &amp;mes) if err != nil &#123; return &#125; &#125;&#125;//编写一个 ServerProcessLogin 函数, 专门处理登录请求func ServerProcessLogin(conn net.Conn, mes *message.Message) (err error) &#123; //核心代码 //1. 先从mes中取出mes.Data, 并直接反序列化成LoginMes var loginMes message.LoginMes err = json.Unmarshal([]byte(mes.Data), &amp;loginMes) if err != nil &#123; fmt.Println("json.Unmarshal fail err=", err) return &#125; //2.声明一个 resMes var resMes message.Message resMes.Type = message.LoginResMesType //3. 声明一个 LoginResMes, 并完成赋值 var loginResMes message.LoginResMes //4. 如果用户 id=100, 密码=123456, 认为合法, 否则不合法 if loginMes.UserId == 100 &amp;&amp; loginMes.UserPwd == "123456" &#123; //合法 loginResMes.Code = 200 &#125; else &#123; //不合法 loginResMes.Code = 500 // 500状态码, 表示该用户不存在 loginResMes.Error = "该用户不存在, 请注册再使用" &#125; //5. 将 loginResMes 序列化 data, err := json.Marshal(loginResMes) if err != nil &#123; fmt.Println("json.Marshal fail err=", err) return &#125; //6. 将 data 赋值给 resMes resMes.Data = string(data) //7. 对 resMes 进行序列化,准备发送 data, err = json.Marshal(resMes) if err != nil &#123; fmt.Println("json.Marshal fail err=", err) return &#125; //8. 发送data, 我们将其封装到writePkg函数 err = writePkg(conn, data) return&#125;//编写一个 ServerProcessMes 函数//功能: 根据客户端发送消息种类不同, 来决定调用哪个函数来处理func ServerProcessMes(conn net.Conn, mes *message.Message) (err error) &#123; switch mes.Type &#123; case message.LoginMesType: //处理登录 err = ServerProcessLogin(conn, mes) case message.RegisterMesType: //处理注册 default: fmt.Println("消息类型不存在, 无法处理...") &#125; return&#125;func main() &#123; fmt.Println("服务器在 8889 端口监听中...") listen, err := net.Listen("tcp", "0.0.0.0:8889") if err != nil &#123; fmt.Println("net.Listen err=", err) return &#125; defer listen.Close() //一旦监听成功, 就等待客户端来链接服务器 for &#123; fmt.Println("等待客户端来链接服务器...") conn, err := listen.Accept() if err != nil &#123; fmt.Println("net.Accept err=", err) &#125; //一旦链接成功, 就启动一个协程和客户端保持通讯 go proc(conn) &#125;&#125; 下图为server/main.go代码中在之前基础上增加的内容 在client下新建 utils.go 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport ( "encoding/binary" "encoding/json" "fmt" "net" "redis/src/golang_study/18-tcp/tcpdemo/common/message")func readPkg(conn net.Conn) (mes message.Message, err error) &#123; buf := make([]byte, 4096) fmt.Println("读取客户端发送的数据...") _, err = conn.Read(buf[:4]) if err != nil &#123; fmt.Println("conn.Read err=", err) return &#125; // 根据 buf[:4] 转成一个 uint32 类型 // var pkgLen uint32 pkgLen := binary.BigEndian.Uint32(buf[:4]) fmt.Println("读取到的buf=", buf[:4]) // 根据 pkgLen 读取消息内容 n, err := conn.Read(buf[:pkgLen]) if uint32(n) != pkgLen || err != nil &#123; fmt.Println("conn.Read fail err=", err) return &#125; // 将 pkgLen 反序列化为 message.Message // 官方解释: // func Unmarshal(data []byte, v interface&#123;&#125;) error // Unmarshal函数解析json编码的数据并将结果存入v指向的值。 err = json.Unmarshal(buf[:pkgLen], &amp;mes) if err != nil &#123; fmt.Println("json.unmarshal fail err=", err) return &#125; return mes, err&#125;func writePkg(conn net.Conn, data []byte) (err error) &#123; //先发送一个长度给对方 pkgLen := uint32(len(data)) var buf [4]byte binary.BigEndian.PutUint32(buf[:4], pkgLen) // 发送长度 n, err := conn.Write(buf[:4]) if n != 4 || err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; //发送消息本身 n, err = conn.Write(data) if n != int(pkgLen) || err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; return&#125; 修改 client/login.go 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package mainimport ( "encoding/binary" "encoding/json" "fmt" "net" "redis/src/golang_study/18-tcp/tcpdemo/common/message")func login(userId int, userPwd string) (err error) &#123; // fmt.Printf("userId=%v, userPwd=%v\n", userId, userPwd) // return nil // 1. 链接到服务器 conn, err := net.Dial("tcp", "localhost:8889") if err != nil &#123; fmt.Println("net.Dial err=", err) return &#125; //延时关闭 defer conn.Close() // 2. 准备通过 conn 发送消息给服务 var mes message.Message mes.Type = message.LoginMesType // 3. 创建一个 LoginMes 结构体 var loginMes message.LoginMes loginMes.UserId = userId loginMes.UserPwd = userPwd // 4. 将 loginMes 序列化 data, err := json.Marshal(loginMes) if err != nil &#123; fmt.Println("json.Marshal err=", err) return &#125; // 5. 把data 赋值给 mes.Data 字段 mes.Data = string(data) // 6. 将 mes 进行序列化操作 data, err = json.Marshal(mes) if err != nil &#123; fmt.Println("json.Marshal err=", err) return &#125; // 7. 到这个时候, data 就是我们要发送的信息 // 先把 data 的长度发送给服务器 // 先获取到 data 的长度 =&gt; 转成一个表示长度的 byte 切片 pkgLen := uint32(len(data)) var buf [4]byte binary.BigEndian.PutUint32(buf[:4], pkgLen) // 发送长度 n, err := conn.Write(buf[:4]) if n != 4 || err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; //发送消息本身 _, err = conn.Write(data) if err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; // 休眠 20 秒 // time.Sleep(20 * time.Second) // fmt.Println("休眠了 20 秒") // fmt.Printf("客户端, 发送消息的长度=%d 内容=%s", len(data), string(data)) // 处理服务器端返回的信息 mes, err = readPkg(conn) if err != nil &#123; fmt.Println("readPkg(conn) err=", err) return &#125; // 将 mes 的Data部分反序列化成 LoginResMes var loginResMes message.LoginResMes err = json.Unmarshal([]byte(mes.Data), &amp;loginResMes) if loginResMes.Code == 200 &#123; fmt.Println("登录成功") &#125; else if loginResMes.Code == 500 &#123; fmt.Println(loginResMes.Error) &#125; return&#125; 下图为 client/login.go 中在原来的基础上所增加的内容 执行测试结果: client端 server端 步骤四 程序代码改进 前面的程序虽然完成了功能，但是没有结构，系统的可读性、扩展性和维护性都不好，因此需要对程序的结构进行改进。 先改进服务端, 先画出程序的框架图[思路]，再写代码 步骤 先把分析出来的文件，创建好，然后放到相应的文件夹[包] 现在根据各个文件，完成的任务不同，将 main.go 的代码剥离到对应的文件中即可 修改server/utils/utils.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package utilsimport ( "encoding/binary" "encoding/json" "fmt" "net" "golang_study/18-tcp/tcpdemo/common/message")// 将这些方法关联到结构体中type Transfer struct &#123; Conn net.Conn Buf [4096]byte //这时传输时,使用缓存&#125;func (t *Transfer) ReadPkg() (mes message.Message, err error) &#123; buf := make([]byte, 4096) fmt.Println("读取客户端发送的数据...") _, err = t.Conn.Read(buf[:4]) if err != nil &#123; fmt.Println("conn.Read err=", err) return &#125; // 根据 buf[:4] 转成一个 uint32 类型 // var pkgLen uint32 pkgLen := binary.BigEndian.Uint32(buf[:4]) fmt.Println("读取到的buf=", buf[:4]) // 根据 pkgLen 读取消息内容 n, err :=t.Conn.Read(buf[:pkgLen]) if uint32(n) != pkgLen || err != nil &#123; fmt.Println("conn.Read fail err=", err) return &#125; // 将 pkgLen 反序列化为 message.Message // 官方解释: // func Unmarshal(data []byte, v interface&#123;&#125;) error // Unmarshal函数解析json编码的数据并将结果存入v指向的值。 err = json.Unmarshal(buf[:pkgLen], &amp;mes) if err != nil &#123; fmt.Println("json.unmarshal fail err=", err) return &#125; return&#125;func (t *Transfer) WritePkg(data []byte) (err error) &#123; //先发送一个长度给对方 pkgLen := uint32(len(data)) var buf [4]byte binary.BigEndian.PutUint32(buf[:4], pkgLen) // 发送长度 n, err := t.Conn.Write(buf[:4]) if n != 4 || err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; //发送消息本身 n, err = t.Conn.Write(data) if n != int(pkgLen) || err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; return&#125; 修改server/process/userProcess.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package processimport ( "encoding/json" "fmt" "golang_study/18-tcp/tcpdemo/common/message" "golang_study/18-tcp/tcpdemo/server/utils" "net")type UserProcess struct &#123; Conn net.Conn Buf [4096]byte&#125;//编写一个 ServerProcessLogin 函数, 专门处理登录请求func (u *UserProcess) ServerProcessLogin(mes *message.Message) (err error) &#123; //核心代码 //1. 先从mes中取出mes.Data, 并直接反序列化成LoginMes var loginMes message.LoginMes err = json.Unmarshal([]byte(mes.Data), &amp;loginMes) if err != nil &#123; fmt.Println("json.Unmarshal fail err=", err) return &#125; //2.声明一个 resMes var resMes message.Message resMes.Type = message.LoginResMesType //3. 声明一个 LoginResMes, 并完成赋值 var loginResMes message.LoginResMes //4. 如果用户 id=100, 密码=123456, 认为合法, 否则不合法 if loginMes.UserId == 100 &amp;&amp; loginMes.UserPwd == "123456" &#123; //合法 loginResMes.Code = 200 &#125; else &#123; //不合法 loginResMes.Code = 500 // 500状态码, 表示该用户不存在 loginResMes.Error = "该用户不存在, 请注册再使用" &#125; //5. 将 loginResMes 序列化 data, err := json.Marshal(loginResMes) if err != nil &#123; fmt.Println("json.Marshal fail err=", err) return &#125; //6. 将 data 赋值给 resMes resMes.Data = string(data) //7. 对 resMes 进行序列化,准备发送 data, err = json.Marshal(resMes) if err != nil &#123; fmt.Println("json.Marshal fail err=", err) return &#125; //8. 发送data, 我们将其封装到writePkg函数 //因为使用分层模式(mvc), 我们先创建一个 Transfer 实例, 然后读取 tf := &amp;utils.Transfer&#123; Conn: u.Conn, &#125; err = tf.WritePkg(data) return&#125; 修改server/main/processor.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( "fmt" "golang_study/18-tcp/tcpdemo/common/message" "golang_study/18-tcp/tcpdemo/server/process" "golang_study/18-tcp/tcpdemo/server/utils" "io" "net")type Processor struct &#123; Conn net.Conn&#125;//编写一个 ServerProcessMes 函数//功能: 根据客户端发送消息种类不同, 来决定调用哪个函数来处理func (p *Processor) ServerProcessMes(mes *message.Message) (err error) &#123; switch mes.Type &#123; case message.LoginMesType: //处理登录 //创建一个 UserProcess 实例 up := &amp;process.UserProcess&#123; Conn: p.Conn, &#125; err = up.ServerProcessLogin(mes) case message.RegisterMesType: //处理注册 default: fmt.Println("消息类型不存在, 无法处理...") &#125; return&#125;func (p *Processor) Process_main() (err error) &#123; //循环的客户端发送的信息 for &#123; //这里我们将读取数据包, 直接封装成一个函数 readPkg(), 返回 Message, Err //创建一个 Transfer 实例完成读包任务 tf := &amp;utils.Transfer&#123; Conn: p.Conn, &#125; mes, err := tf.ReadPkg() if err != nil &#123; if err == io.EOF &#123; fmt.Println("客户端退出, 服务器端也退出...") return err &#125; else &#123; fmt.Println("readPkg err=", err) return err &#125; &#125; err = p.ServerProcessMes(&amp;mes) if err != nil &#123; return err &#125; &#125;&#125; 修改server/main/main.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport ( "fmt" "net")// 处理客户端的通讯func proc(conn net.Conn) &#123; //延时关闭conn defer conn.Close() //这里调用总控,创建一个 processor := &amp;Processor&#123; Conn: conn, &#125; err := processor.Process_main() if err != nil &#123; fmt.Println("客户端和服务器通讯协程错误=err", err) return &#125;&#125;func main() &#123; fmt.Println("服务器在 8889 端口监听中...") listen, err := net.Listen("tcp", "0.0.0.0:8889") if err != nil &#123; fmt.Println("net.Listen err=", err) return &#125; defer listen.Close() //一旦监听成功, 就等待客户端来链接服务器 for &#123; fmt.Println("等待客户端来链接服务器...") conn, err := listen.Accept() if err != nil &#123; fmt.Println("net.Accept err=", err) &#125; //一旦链接成功, 就启动一个协程和客户端保持通讯 go proc(conn) &#125;&#125; 步骤五 修改客户端代码 示意图如下: 先把各个文件放到对应的文件夹[包] 将 server/utils.go 拷贝到 client/utils/utils.go 创建了server/process/userProcess.go 说明: 该文件就是在原来的 login.go 做了一个改进，即封装到 UserProcess 结构体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package processimport ( "encoding/binary" "encoding/json" "fmt" "golang_study/18-tcp/tcpdemo/client/utils" "golang_study/18-tcp/tcpdemo/common/message" "net")type UserProcess struct &#123; //暂时不需要字段&#125;//给关联一个用户登录的方法//写一个函数, 完成登录func (u *UserProcess) Login(userId int, userPwd string) (err error) &#123; // 1. 链接到服务器 conn, err := net.Dial("tcp", "localhost:8889") if err != nil &#123; fmt.Println("net.Dial err=", err) return &#125; //延时关闭 defer conn.Close() // 2. 准备通过 conn 发送消息给服务 var mes message.Message mes.Type = message.LoginMesType // 3. 创建一个 LoginMes 结构体 var loginMes message.LoginMes loginMes.UserId = userId loginMes.UserPwd = userPwd // 4. 将 loginMes 序列化 data, err := json.Marshal(loginMes) if err != nil &#123; fmt.Println("json.Marshal err=", err) return &#125; // 5. 把data 赋值给 mes.Data 字段 mes.Data = string(data) // 6. 将 mes 进行序列化操作 data, err = json.Marshal(mes) if err != nil &#123; fmt.Println("json.Marshal err=", err) return &#125; // 7. 到这个时候, data 就是我们要发送的信息 // 先把 data 的长度发送给服务器 // 先获取到 data 的长度 =&gt; 转成一个表示长度的 byte 切片 pkgLen := uint32(len(data)) var buf [4]byte binary.BigEndian.PutUint32(buf[:4], pkgLen) // 发送长度 n, err := conn.Write(buf[:4]) if n != 4 || err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; //发送消息本身 _, err = conn.Write(data) if err != nil &#123; fmt.Println("conn.Write(bytes) fail", err) return &#125; // 休眠 20 秒 // time.Sleep(20 * time.Second) // fmt.Println("休眠了 20 秒") // fmt.Printf("客户端, 发送消息的长度=%d 内容=%s", len(data), string(data)) ft := utils.Transfer&#123; Conn: conn, &#125; // 处理服务器端返回的信息 mes, err = ft.ReadPkg() if err != nil &#123; fmt.Println("readPkg(conn) err=", err) return &#125; // 将 mes 的Data部分反序列化成 LoginResMes var loginResMes message.LoginResMes err = json.Unmarshal([]byte(mes.Data), &amp;loginResMes) if loginResMes.Code == 200 &#123; fmt.Println("登录成功") //循环显示登陆成功后的菜单 for &#123; ShowMenu() &#125; &#125; else if loginResMes.Code == 500 &#123; fmt.Println(loginResMes.Error) &#125; return&#125; 上面代码中变化的内容如下图 创建了server/process/server.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package processimport ( "fmt" "golang_study/18-tcp/tcpdemo/server/utils" "net" "os")//显示登录成功后的界面func ShowMenu() &#123; fmt.Println("----------恭喜xxx登录成功----------") fmt.Println("----------1. 显示在线用户列表----------") fmt.Println("----------2. 发送消息----------") fmt.Println("----------3. 信息列表----------") fmt.Println("----------4. 退出系统----------") fmt.Println("请选择(1-4):") var key int fmt.Scanf("%d\n", &amp;key) switch key &#123; case 1: fmt.Println("显示在线用户列表") case 2: fmt.Println("发送消息") case 3: fmt.Println("信息列表") case 4: fmt.Println("退出系统") os.Exit(0) default: fmt.Println("你输入的选项不正确!") &#125;&#125;//和服务器保持通讯func ServerProcessMes(conn net.Conn) &#123; //创建一个 transfer 实例, 不停的读取服务器发送的消息 tf := &amp;utils.Transfer&#123; Conn: conn, &#125; for &#123; fmt.Println("客户端正在等待读取服务器发送的消息") mes, err := tf.ReadPkg() if err != nil &#123; fmt.Println("tf.ReadPkg err=", err) return &#125; //如果读取到消息, 又事下一步处理逻辑 fmt.Printf("mes=%v\n", mes) &#125;&#125; 上面代码中增加的内容如下图 修改 client/main/main.go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( "fmt" "golang_study/18-tcp/tcpdemo/client/process")//用户IDvar userId int//用户密码var userPwd stringfunc main() &#123; //接收用户的选择 var key string //判断是否继续显示菜单 var loop = true for &#123; fmt.Println("--------------------欢迎登录多人聊天系统--------------------") fmt.Println("\t\t\t1 登录聊天室") fmt.Println("\t\t\t2 注册用户") fmt.Println("\t\t\tq 退出系统") fmt.Println("请选择进行的操作[1|2|q]:") fmt.Scanf("%v\n", &amp;key) switch key &#123; case "1": fmt.Println("登录聊天室") fmt.Println("请输入用户的Id:") fmt.Scanf("%v\n", &amp;userId) fmt.Println("请输入用户的密码:") fmt.Scanf("%v\n", &amp;userPwd) //完成登录 //1. 创建一个 UserProcess 的实例 up := &amp;process.UserProcess&#123;&#125; up.Login(userId, userPwd) case "2": fmt.Println("注册用户") case "q": fmt.Println("退出系统") loop = false default: fmt.Println("输入有误, 请重新输入!") &#125; if !loop &#123; break &#125; &#125;&#125; 上面代码中变化的内容如下图 Redis操作Redis手动添加用户示意图如下 json数据格式如下 1&#123;"type":"LoginMes","data":"&#123;\"userId\":100,\"userPwd\":\"123456\",\"userName\":\"poker\"&#125;"&#125; 具体redis操作如下 1234127.0.0.1:6379&gt; hset users 100 "&#123;\"userId\":100,\"userPwd\":\"123456\",\"userName\":\"poker\"&#125;"(integer) 1127.0.0.1:6379&gt; hget users 100"&#123;\"userId\":100,\"userPwd\":\"123456\",\"userName\":\"poker\"&#125;" 代码实现Redis添加用户 如输入的用户名密码在 Redis 中存在则登录，否则退出系统，并给出相应的提示信息: 用户不存在,你也可以重新注册，再登录 输入的密码不正确 首先创建对应的文件 Redis Redis 是一个NoSql数据库,不是传统的关系型数据库 Redis 全程为 REmote Dictionary Server Redis性能非常高,单机能够达到 15w qps, 通常用来做缓存,也可以持久化. Redis是完全开源免费的, 高性能的分布式内存数据库,基于内存运行并支持持久化的NoSql数据库 官网: https://redis.io https://www.redis.cn 操作原理图 Redis的安装 我的笔记本为 MAC OS, 这里只演示 Mac 上安装 Redis 的过程 参考链接: MAC安装redis的简单方法 1brew install redis@6.2 启动redis 1brew services start redis 检查端口号6379 1netstat -AaLlnW | grep 6379 客户端访问 12redis-cli127.0.0.1:6379&gt; Redis的基本使用使用手册参考:Redis命令参考 说明: Redis 安装好后，默认有 16 个数据库，初始默认使用 0 号库, 编号(index)是 0…15 添加 key-val [set] 12127.0.0.1:6379&gt; set key1 helloOK 查看当前 redis 的 所有 key [keys *] 123127.0.0.1:6379&gt; keys *1) &quot;key2&quot;2) &quot;key1&quot; 获取key对应的值 [getkey] 12127.0.0.1:6379&gt; get key1&quot;hello&quot; 切换 redis 数据库 [select index] 12345678127.0.0.1:6379&gt; select 1OK127.0.0.1:6379[1]&gt; get key1(nil)127.0.0.1:6379[1]&gt; select 0OK127.0.0.1:6379&gt; get key1&quot;hello&quot; 如何查看当前数据库的key-val数量 [dbsize] 1234127.0.0.1:6379&gt; set key2 imauOK127.0.0.1:6379&gt; dbsize(integer) 2 清空当前数据库的key-val和清空所有数据库的 key-val [flushdb flushall] flushdb =&gt; 清空当前index的数据库 flushall =&gt; 清空左右index的数据库 Redis 的 Crud 操作Redis 的五大数据类型Redis 的五大数据类型是: String(字符串) 、Hash (哈希)、List(列表)、Set(集合) 和 zset(sorted set:有序集合) String(字符串) string 是 redis 最基本的类型，一个 key 对应一个 value。 string 类型是二进制安全的。除普通的字符串外，也可以存放图片等数据。 redis 中字符串 value 最大是 512M 1234567891011# 定义一个key和value127.0.0.1:6379&gt; set address beijingOK# 查询指定的key127.0.0.1:6379&gt; get address&quot;beijing&quot;# 删除指定的key127.0.0.1:6379&gt; del address(integer) 1127.0.0.1:6379&gt; get address(nil) setex(set with expire)键秒值 12345678910# setex [key] [n秒] [value]# 超过 n 秒之后,删除这个key127.0.0.1:6379&gt; setex mess01 10 helloworldOK127.0.0.1:6379&gt; get mess01&quot;helloworld&quot;127.0.0.1:6379&gt; get mess01&quot;helloworld&quot;127.0.0.1:6379&gt; get mess01(nil) mset[同时设置一个或多个 key-value 对] mget[同时获取多个 key-value] 123456789127.0.0.1:6379&gt; mset m1 hello m2 worldOK127.0.0.1:6379&gt; get m1&quot;hello&quot;127.0.0.1:6379&gt; get m2&quot;world&quot;127.0.0.1:6379&gt; mget m1 m21) &quot;hello&quot;2) &quot;world&quot; Hash (哈希) 类似 golang 里的 Map Redis hash 是一个键值对集合。var user1 map[string]string Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 12345678910111213141516171819202122232425127.0.0.1:6379&gt; hset user1 name poker(integer) 1127.0.0.1:6379&gt; hset user1 age 25(integer) 1127.0.0.1:6379&gt; hset user1 job coder(integer) 1127.0.0.1:6379&gt; hget user1 name&quot;poker&quot;127.0.0.1:6379&gt; hget user1 age&quot;25&quot;127.0.0.1:6379&gt; hget user1 job&quot;coder&quot;# 查看key中的field个数127.0.0.1:6379&gt; hlen user2(integer) 3127.0.0.1:6379&gt; hgetall user11) &quot;name&quot;2) &quot;poker&quot;3) &quot;age&quot;4) &quot;25&quot;5) &quot;job&quot;6) &quot;coder&quot; hmset(同时设定多个) hmget(同时查看多个) 123456127.0.0.1:6379&gt; hmset user2 name jenny age 25 job &quot;good coder &quot;OK127.0.0.1:6379&gt; hmget user2 name age job1) &quot;jenny&quot;2) &quot;25&quot;3) &quot;good coder &quot; hexists(判定哈希表中key的field是否存在) 12345127.0.0.1:6379&gt; hexists user2 name(integer) 1# 0就表示该 field 不存在127.0.0.1:6379&gt; hexists user2 name1(integer) 0 List(列表) 列表是简单的字符串列表,按照插入顺序排序,你可以添加一个元素到列表的头部或者尾部 List 本质是个链表, List 的元素是有序的，元素的值可以重复 1234567891011121314151617181920212223242526272829303132333435363738394041424344# 从左到右依次传入数据127.0.0.1:6379&gt; lpush city tinjian beijing shanghai(integer) 3127.0.0.1:6379&gt; lrange city 0 01) &quot;shanghai&quot;127.0.0.1:6379&gt; lrange city 0 11) &quot;shanghai&quot;2) &quot;beijing&quot;# 查看所有field元素127.0.0.1:6379&gt; lrange city 0 -11) &quot;shanghai&quot;2) &quot;beijing&quot;3) &quot;tinjian&quot;# 从右到左依次传入数据127.0.0.1:6379&gt; rpush city shenzhen nanjing(integer) 5127.0.0.1:6379&gt; lrange city 0 -11) &quot;shanghai&quot;2) &quot;beijing&quot;3) &quot;tinjian&quot;4) &quot;shenzhen&quot;5) &quot;nanjing&quot;127.0.0.1:6379&gt; lpop city&quot;shanghai&quot;127.0.0.1:6379&gt; lrange city 0 -11) &quot;beijing&quot;2) &quot;tinjian&quot;3) &quot;shenzhen&quot;4) &quot;nanjing&quot;127.0.0.1:6379&gt; rpop city&quot;nanjing&quot;127.0.0.1:6379&gt; lrange city 0 -11) &quot;beijing&quot;2) &quot;tinjian&quot;3) &quot;shenzhen&quot;# 查看key的元素个数127.0.0.1:6379&gt; llen city(integer) 3 特别说明 List 数据可以从左或右添加数据 如果 List 的数据全部移除,那么对应的键也会删除 Set(集合) sadd [添加值] smembers [取出所有值] sismember [判断值是否是成员] srem [删除指定值] 123456789101112131415161718192021222324252627127.0.0.1:6379&gt; sadd emails tom@sohu.com(integer) 1# 判断指定的值是否存在127.0.0.1:6379&gt; sismember emails tom@sohu.com(integer) 1127.0.0.1:6379&gt; sismember emails tom1@sohu.com(integer) 0127.0.0.1:6379&gt; sadd emails shang@sohu.com(integer) 1127.0.0.1:6379&gt; sadd emails jack@sohu.com(integer) 1# 输出所有值127.0.0.1:6379&gt; smembers emails1) &quot;shang@sohu.com&quot;2) &quot;jack@sohu.com&quot;3) &quot;tom@sohu.com&quot;# 删除指定值127.0.0.1:6379&gt; srem emails tom@sohu.com(integer) 1127.0.0.1:6379&gt; smembers emails1) &quot;shang@sohu.com&quot;2) &quot;jack@sohu.com&quot; Golang 操作 Redis安装第三方开源 Redis 库使用第三方开源的 Redis 库: go-redis 安装方式: 12345# 1.切换到当前go文件目录中# 2.初始化一个 mod 文件go mod init demo01# 3.安装 github.com/go-redis/redisgo get -u github.com/go-redis/redis 安装过程碰到了很多莫名其妙的问题,没有来得及记录,有问题及时百度~ 注意: 官方源码文档中给出的快速使用示例,代码跟引入的包有些出入,因为go-redis版本原因, 有些地方使用方式不同 注: 以下内容通过官方文档的定义进行的编写 Set/Get-String字符串操作 通过 Golang 添加和获取 key-value 在redis中添加两个键值 12345redis-cli127.0.0.1:6379&gt; set car1 baomaOK127.0.0.1:6379&gt; set car2 aodiOK 快速入门 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport ( "fmt" "github.com/go-redis/redis")func ExampleClient() &#123; //连接本地 redis 数据库 rdb := redis.NewClient(&amp;redis.Options&#123; Addr: "localhost:6379", Password: "", // no password set DB: 0, // use default DB &#125;) defer rdb.Close() // 添加一对redis的键值 // 最后一个参数是过期。0表示密钥没有过期时间 err := rdb.Set("test", "aaa", 0).Err() if err != nil &#123; panic(err) &#125; // 输出刚刚上面添加的键值 val, err := rdb.Get("test").Result() if err != nil &#123; panic(err) &#125; fmt.Println("key", val) // 输出 car1 val2, err := rdb.Get("car1").Result() if err == redis.Nil &#123; fmt.Println("car1 does not exist") &#125; else if err != nil &#123; panic(err) &#125; else &#123; fmt.Println("car1", val2) &#125; //输出 car2 val3, err := rdb.Get("car2").Result() if err == redis.Nil &#123; fmt.Println("car2 does not exist") &#125; else if err != nil &#123; panic(err) &#125; else &#123; fmt.Println("car2", val3) &#125; // car3没有添加,所以不存在 val4, err := rdb.Get("car3").Result() if err == redis.Nil &#123; fmt.Println("car3 does not exist") &#125; else if err != nil &#123; panic(err) &#125; else &#123; fmt.Println("car3", val4) &#125;&#125;func main() &#123; ExampleClient()&#125; MSet/MGet操作-String字符串操作 MSet/MGet 数据操作数据 通过 Golang 对 Redis 操作，一次操作可以 Set / Get 多个 key-val 数据 MSet的官方定义如下图, 参数为一个接口类型的切片,我们可以传入一个 string 类型的切片或者使用for循环依次遍历map切片,传入一对键值字符串(我感觉后者更方便管理,代码也更加简洁,一会儿看下面的代码就可以了) MGet的官方定义如下图, 参数为一个string类型的切片,我们可以传入一个 string 类型的切片 MGet方法的返回值 *SliceCmd是一个空的结构体(众所周知,空的结构体更加灵活,可以随意调用定义的各种函数),里面已经定义了多个函数,其中Result返回值, 返回的是一个接口切片和error信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( "fmt" "github.com/go-redis/redis")func ExampleClient() &#123; rdb := redis.NewClient(&amp;redis.Options&#123; Addr: "localhost:6379", Password: "", // no password set DB: 0, // use default DB &#125;) defer rdb.Close() //方式一: 可以使用map切片 strArr := make(map[string]string) strArr["animal1"] = "Monkey" strArr["animal2"] = "Elephant" strArr["animal3"] = "Tiger" // 添加redis的键值 for i, v := range strArr &#123; err := rdb.MSet(i, v).Err() if err != nil &#123; panic(err) &#125; &#125; //方式二: 也可以使用string类型的切片 //strArr := []string&#123;"animal1", "Monkey", "animal2", "elephant", "animal3", "tiger"&#125; // 添加redis的键值 // err := rdb.MSet(strArr).Err() // if err != nil &#123; // panic(err) // &#125; // strArr_key := []string&#123;"animal1", "animal2", "animal3"&#125; for key := range strArr &#123; // 输出刚刚上面添加的键值 result, err := rdb.MGet(key).Result() if err == redis.Nil &#123; fmt.Println("this key does not exist") &#125; else if err != nil &#123; panic(err) &#125; else &#123; for _, v := range result &#123; fmt.Printf("%v=%v\n", key, v) &#125; &#125; &#125;&#125;func main() &#123; ExampleClient()&#125; HSet/HGet-Hash操作 通过 Golang 对 Redis 操作 Hash 数据类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( "fmt" "github.com/go-redis/redis")func ExampleClient() &#123; rdb := redis.NewClient(&amp;redis.Options&#123; Addr: "localhost:6379", Password: "", // no password set DB: 0, // use default DB &#125;) defer rdb.Close() //1 HSet 添加hash键值 err := rdb.HSet("userinfo", "name", "tom").Err() if err != nil &#123; panic(err) &#125; err = rdb.HSet("userinfo", "age", "6").Err() if err != nil &#123; panic(err) &#125; //2 HGet 输出hash键值 res := "" res, err = rdb.HGet("userinfo", "name").Result() if err == redis.Nil &#123; fmt.Println("userinfo name does not exist") &#125; else if err != nil &#123; panic(err) &#125; else &#123; fmt.Println("userinfo-name", res) &#125; res, err = rdb.HGet("userinfo", "age").Result() if err == redis.Nil &#123; fmt.Println("userinfo age does not exist") &#125; else if err != nil &#123; panic(err) &#125; else &#123; fmt.Println("userinfo-age", res) &#125;&#125;func main() &#123; ExampleClient()&#125; HMSet/HMGet-Hash操作 对 hash 数据结构，field-val 是批量放入和读取 根据官方文档, HMSet传入的是一个map切片,我们需要自己定义然后传参即可 MHGet方法传参时,传入的是一个 []string数组 HMGet方法的返回值 *SliceCmd是一个空的结构体,里面已经定义了多个函数,其中Result返回值, 返回的是一个接口切片和error信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( "fmt" "github.com/go-redis/redis")func ExampleClient() &#123; rdb := redis.NewClient(&amp;redis.Options&#123; Addr: "localhost:6379", Password: "", // no password set DB: 0, // use default DB &#125;) defer rdb.Close() m := make(map[string]interface&#123;&#125;) m["name"] = "jack" m["age"] = "7" //1 HMSet err := rdb.HMSet("userinfo1", m).Err() if err != nil &#123; panic(err) &#125; //2 HMGet // 定义一个string类型切片,指定field值 str := []string&#123;"name", "age"&#125; // Result返回的是一个 string 类型的 interface 接口 result, err := rdb.HMGet("userinfo1", str...).Result() if err == redis.Nil &#123; fmt.Println("userinfo1 does not exist") &#125; else if err != nil &#123; panic(err) &#125; else &#123; fmt.Println("userinfo1=", result) fmt.Printf("result的类型=%T\n", result) &#125; // 循环遍历 result ,借助上面定义的 str 输出 userinfo1 的索引与值 fmt.Println("userinfo1的键值内容如下:") for i, v := range result &#123; fmt.Printf("%v=%v\n", str[i], v) &#125;&#125;func main() &#123; ExampleClient()&#125; 列表操作 列表中比较常用的指令有: LPush/RPush/LInsert/RInsert/LRange遍历 等 LPush/RPush 从下图可以得知,values传入的值是一个 接口切片,可以传入任意类型数据,这里我们直接传入任意数量的字符串 可以使用LRange遍历列表的数据 LInsert/RInsert 下面图中的定义可能会有人看不懂 key =&gt; 键值 op =&gt; after/before pivot =&gt; 指定的数据位置 value =&gt; 需要添加的数组 举个例子 12rdb.LPush("hobby","篮球")rdb.LInsert("hobby","before","篮球","乒乓球") 上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package mainimport ( "fmt" "github.com/go-redis/redis")func ExampleClient() &#123; rdb := redis.NewClient(&amp;redis.Options&#123; Addr: "localhost:6379", Password: "", // no password set DB: 0, // use default DB &#125;) defer rdb.Close() // Lpush向列表中添加数据 strArr1 := []string&#123;"1.唱", "2.跳"&#125; err := rdb.LPush("蔡徐坤的hobby", strArr1).Err() if err != nil &#123; panic(err) &#125; // Rpush向列表中添加数据 strArr2 := []string&#123;"3.rap", "4.篮球"&#125; err = rdb.RPush("蔡徐坤的hobby", strArr2).Err() if err != nil &#123; panic(err) &#125; // LRange 读取数据 result, err := rdb.LRange("蔡徐坤的hobby", 0, -1).Result() if err == redis.Nil &#123; fmt.Println("this key does not exist") &#125; else if err != nil &#123; panic(err) &#125; else &#123; fmt.Println("result=", result) &#125; // LInsert 在列表中的指定位置添加数据 err = rdb.LInsert("蔡徐坤的hobby", "before", "3.rap", "鸡你太美").Err() if err != nil &#123; panic(err) &#125; //RInsert 这里不做演示了,原理同上 // LRange 读取数据 result, err = rdb.LRange("蔡徐坤的hobby", 0, -1).Result() if err == redis.Nil &#123; fmt.Println("this key does not exist") &#125; else if err != nil &#123; panic(err) &#125; else &#123; fmt.Println("result=", result) &#125; // 删除该键值,方便重复进行调试 rdb.Del("蔡徐坤的hobby")&#125;func main() &#123; ExampleClient()&#125; Set-集合操作SAdd用来向集合中添加键值 SMembers用来输出集合中的数据 SIsMember 用于判断一个值在集合中是否存在,从下图可以看出,该方法返回一个*BoolCmd *BoolCmd的Result方法会返回一个bool类型的值 上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package mainimport ( "fmt" "github.com/go-redis/redis")// 输出集合中的内容func Smembers(rdb *redis.Client, urls string) []string &#123; result, err := rdb.SMembers(urls).Result() if err == redis.Nil &#123; fmt.Println("this key does not exist") &#125; else if err != nil &#123; panic(err) &#125; return result&#125;//判断集合中某个值是否存在func SisMember(rdb *redis.Client, urls string, url string) bool &#123; result, err := rdb.SIsMember(urls, url).Result() if err == redis.Nil &#123; fmt.Println("this key does not exist") &#125; else if err != nil &#123; panic(err) &#125; return result&#125;//计算集合的大小func Scard(rdb *redis.Client, urls string) &#123; result, err := rdb.SCard("urls").Result() if err == redis.Nil &#123; fmt.Println("this key does not exist") &#125; else if err != nil &#123; panic(err) &#125; else &#123; fmt.Printf("%v 的集合大小=%d\n", urls, result) &#125;&#125;func ExampleClient() &#123; rdb := redis.NewClient(&amp;redis.Options&#123; Addr: "localhost:6379", Password: "", // no password set DB: 0, // use default DB &#125;) fmt.Printf("rdb的类型为%T\n", rdb) defer rdb.Close() // SAdd 向无序集合中添加数据 err := rdb.SAdd("urls", "www.baidu.com", "www.google.com").Err() if err != nil &#123; panic(err) &#125; // 输出集合中的内容 res_urls := Smembers(rdb, "urls") fmt.Println("urls=", res_urls) //计算集合大小 Scard(rdb, "urls") //判断集合中某个值是否存在 res_bool := SisMember(rdb, "urls", "www.baidu.com") if res_bool &#123; // 当 res_bool 为 true 时 fmt.Println("www.baidu.com 存在") &#125; else &#123; fmt.Println("www.baidu.com 不存在") &#125; //删除指定值 err = rdb.SRem("urls", "www.baidu.com").Err() if err != nil &#123; panic(err) &#125; else &#123; fmt.Println("www.baidu.com 已被删除") &#125; //判断集合中某个值是否存在 res_bool = SisMember(rdb, "urls", "www.baidu.com") if res_bool &#123; // 当 res_bool 为 true 时 fmt.Println("www.baidu.com 存在") &#125; else &#123; fmt.Println("www.baidu.com 不存在") &#125; // 输出集合中的内容 res_urls = Smembers(rdb, "urls") fmt.Println("urls=", res_urls)&#125;func main() &#123; ExampleClient()&#125; Redis链接池 说明: 通过 Golang 对 Redis 操作， 还可以通过 Redis 链接池, 流程如下: 1) 事先初始化一定数量的链接，放入到链接池 2) 当 Go 需要操作 Redis 时，直接从 Redis 链接池取出链接即可。 2) 这样可以节省临时获取 Redis 链接的时间，从而提高效率 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport ( "fmt" "net" "time" "github.com/go-redis/redis")// 声明一个全局变量var pool *redis.Clientfunc init() &#123; pool = redis.NewClient( &amp;redis.Options&#123; //连接池容量及闲置连接数量 PoolSize: 15, // 连接池最大socket连接数，默认为4倍CPU数， 4 * runtime.NumCPU MinIdleConns: 10, //在启动阶段创建指定数量的Idle连接，并长期维持idle状态的连接数不少于指定数量 //超时 DialTimeout: 5 * time.Second, //连接建立超时时间，默认5秒。 ReadTimeout: 3 * time.Second, //读超时，默认3秒， -1表示取消读超时 WriteTimeout: 3 * time.Second, //写超时，默认等于读超时 PoolTimeout: 4 * time.Second, //当所有连接都处在繁忙状态时，客户端等待可用连接的最大等待时长，默认为读超时+1秒。 //闲置连接检查包括IdleTimeout，MaxConnAge IdleCheckFrequency: 60 * time.Second, //闲置连接检查的周期，默认为1分钟，-1表示不做周期性检查，只在客户端获取连接时对闲置连接进行处理。 IdleTimeout: 5 * time.Minute, //闲置超时，默认5分钟，-1表示取消闲置超时检查 MaxConnAge: 0 * time.Second, //连接存活时长，从创建开始计时，超过指定时长则关闭连接，默认为0，即不关闭存活时长较长的连接 //命令执行失败时的重试策略 MaxRetries: 0, // 命令执行失败时，最多重试多少次，默认为0即不重试 MinRetryBackoff: 8 * time.Millisecond, //每次计算重试间隔时间的下限，默认8毫秒，-1表示取消间隔 MaxRetryBackoff: 512 * time.Millisecond, //每次计算重试间隔时间的上限，默认512毫秒，-1表示取消间隔 //可自定义连接函数 Dialer: func() (net.Conn, error) &#123; netDialer := &amp;net.Dialer&#123; Timeout: 5 * time.Second, KeepAlive: 5 * time.Minute, &#125; return netDialer.Dial("tcp", "127.0.0.1:6379") &#125;, //钩子函数 //仅当客户端执行命令时需要从连接池获取连接时，如果连接池需要新建连接时则会调用此钩子函数 OnConnect: func(conn *redis.Conn) error &#123; fmt.Printf("conn=%v\n", conn) return nil &#125;, &#125;, )&#125;func main() &#123; // 先从 pool 取出一个链接 err := pool.Set("user1", "poker", 0).Err() if err != nil &#123; panic(err) &#125; result, err := pool.Get("user1").Result() if err != nil &#123; panic(err) &#125; fmt.Println("result=", result)&#125;]]></content>
      <categories>
        <category>开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux运维常见问题]]></title>
    <url>%2F2022%2F05%2F01%2FLinux%E8%BF%90%E7%BB%B4%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试题可以参考:面试题总结 查看系统相关信息查看网卡流量watch123456789101112[root@3 ~]# watch ifconfig eth0Every 2.0s: ifconfig eth0 Sun May 1 21:53:10 2022eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.2.3.101 netmask 255.255.255.0 broadcast 10.2.3.255 inet6 fe80::546f:77ff:fe6f:78 prefixlen 64 scopeid 0x20&lt;link&gt; ether 56:6f:77:6f:00:78 txqueuelen 1000 (Ethernet) RX packets 980997 bytes 63958819 (60.9 MiB) RX errors 0 dropped 140820 overruns 0 frame 0 TX packets 109994 bytes 6171909 (5.8 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 dstat 1234567891011121314[root@3 ~]# dstatYou did not select any stats, using -cdngy by default.----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--usr sys idl wai hiq siq| read writ| recv send| in out | int csw 0 0 100 0 0 0|1277B 1515B| 0 0 | 0 0 | 54 56 0 0 100 0 0 0| 0 0 | 485B 130B| 0 0 | 95 103 0 0 100 0 0 0| 0 0 | 348B 898B| 0 0 | 84 109 0 0 100 0 0 0| 0 0 | 449B 370B| 0 0 | 93 110 0 0 100 0 0 0| 0 0 | 450B 370B| 0 0 | 84 91 0 0 100 0 0 0| 0 0 | 467B 370B| 0 0 | 90 101 0 0 100 0 0 0| 0 0 | 306B 370B| 0 0 | 72 95 q 0 0 100 0 0 0| 0 0 | 501B 740B| 0 0 | 69 92 0 0 100 0 0 0| 0 345k| 186B 130B| 0 0 | 78 101 0 0 100 0 0 0| 0 0 | 485B 370B| 0 0 | 70 90 sysstat 此命令根据参数的不同,可以查看系统不同的信息,详情请见:https://linux.cn/article-4028-1.html 也可以参考百度文库:https://wenku.baidu.com/view/e89049fdcd2f0066f5335a8102d276a2002960e6.html 123456789101112131415[root@3 ~]# yum -y install sysstat[root@3 ~]# sar -n DEV 1 2 // -n DEV表示查看网络信息,1表示一秒一次,2表示一共两次Linux 3.10.0-957.el7.x86_64 (3.101-CentOS7.6) 05/01/2022 _x86_64_ (8 CPU)09:59:51 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s09:59:52 PM eth0 6.00 0.00 0.42 0.00 0.00 0.00 0.0009:59:52 PM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0009:59:52 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s09:59:53 PM eth0 6.00 1.00 0.36 0.19 0.00 0.00 0.0009:59:53 PM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00Average: IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/sAverage: eth0 6.00 0.50 0.39 0.09 0.00 0.00 0.00Average: lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 cat直接查看 12345[root@3 ~]# cat /proc/net/devInter-| Receive | Transmit face |bytes packets errs drop fifo frame compressed multicast|bytes packets errs drop fifo colls carrier compressed eth0: 95970470 988296 0 141200 0 0 0 0 6464566 114062 0 0 0 0 0 0 lo: 336200 6724 0 0 0 0 0 0 336200 6724 0 0 0 0 0 0 proc/net/dev中每一项的含义是： bytes: The total number of bytes of data transmitted or received by the interface.（接口发送或接收的数据的总字节数） packets: The total number of packets of data transmitted or received by the interface.（接口发送或接收的数据包总数） errs: The total number of transmit or receive errors detected by the device driver.（由设备驱动程序检测到的发送或接收错误的总数） drop: The total number of packets dropped by the device driver.（设备驱动程序丢弃的数据包总数） fifo: The number of FIFO buffer errors.（FIFO缓冲区错误的数量） frame: The number of packet framing errors.（分组帧错误的数量） colls: The number of collisions detected on the interface.（接口上检测到的冲突数） compressed: The number of compressed packets transmitted or received by the device driver. (This - - appears to be unused in the 2.2.15 kernel.)（设备驱动程序发送或接收的压缩数据包数） carrier: The number of carrier losses detected by the device driver.（由设备驱动程序检测到的载波损耗的数量） multicast: The number of multicast frames transmitted or received by the device driver.（设备驱动程序发送或接收的多播帧数） 查看进程查看进程已运行时间 123456789[root@3 ~]# ps -eo pid,lstart,etime,command PID STARTED ELAPSED COMMAND 1 Fri Apr 29 14:00:04 2022 2-08:53:16 /usr/lib/systemd/systemd --switched-root --system --deserialize 22 2 Fri Apr 29 14:00:04 2022 2-08:53:16 [kthreadd] 3 Fri Apr 29 14:00:04 2022 2-08:53:16 [ksoftirqd/0] 5 Fri Apr 29 14:00:04 2022 2-08:53:16 [kworker/0:0H] 6 Fri Apr 29 14:00:04 2022 2-08:53:16 [kworker/u32:0] 7 Fri Apr 29 14:00:04 2022 2-08:53:16 [migration/0] 8 Fri Apr 29 14:00:04 2022 2-08:53:16 [rcu_bh] 进程相关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112## processes 进程管理##ps查看当前系统执行的线程列表，进行瞬间状态，不是连续状态，连续状态需要使用top名称查看 更多常用参数请使用 man ps查看ps##显示所有进程详细信息ps aux##-u 显示某个用户的进程列表ps -f -u www-data ## -C 通过名字或者命令搜索进程ps -C apache2## --sort 根据进程cpu使用率降序排列，查看前5个进程 -pcpu表示降序 pcpu升序ps aux --sort=-pcpu | head -5 ##-f 用树结构显示进程的层次关系，父子进程情况下ps -f --forest -C apache2 ##显示一个父进程的所有子进程ps -o pid,uname,comm -C apache2ps --ppid 2359 ##显示一个进程的所有线程 -L 参数ps -p 3150 -L ##显示进程的执行时间 -o参数ps -e -o pid,comm,etime ##watch命令可以用来实时捕捉ps显示进程watch -n 1 'ps -e -o pid,uname,cmd,pmem,pcpu --sort=-pmem,-pcpu | head -15' ##jobs 查看后台运行的进程 jobs命令执行的结果，＋表示是一个当前的作业，减号表是是一个当前作业之后的一个作业，jobs -l选项可显示所有任务的PID,jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息jobs##查看后台运营的进程号jobs -p##查看现在被终止或者退出的进程号jobs -n##kill命令 终止一个前台进程可以使用Ctrl+C键 kill 通过top或者ps获取进程id号 kill [-s 信号 | -p ] [ -a ] 进程号 ...##发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。关闭进程号12的进程kill 12##等同于在前台运行PID为123的进程时按下Ctrl+C键kill -2 123##如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程 kill -9 123##列出所有信号名称##HUP 1 终端断线##INT 2 中断（同 Ctrl + C）##QUIT 3 退出（同 Ctrl + \）##TERM 15 终止##KILL 9 强制终止##CONT 18 继续（与STOP相反， fg/bg命令）##STOP 19 暂停（同 Ctrl + Z）kill -l##得到指定信号的数值kill -l KILL##杀死指定用户所有进程kill -u peidalinuxkill -9 $(ps -ef | grep peidalinux) ##将后台中的命令调至前台继续运行 将进程123调至前台执行fg 123##将一个在后台暂停的命令，变成继续执行bg 123##该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思 下面输出被重定向到myout.file文件中nohup command &gt; myout.file 2&gt;&amp;1 &amp;##at：计划任务，在特定的时间执行某项工作，在特定的时间执行一次。## 格式：at HH:MM YYYY-MM-DD //HH（小时）:MM（分钟） YYYY（年）-MM（月份）-DD（日）##HH[am pm]+D(天) days //HH（小时）[am（上午）pm（下午）]+days（天）at 12:00（时间） //at命令设定12:00执行一项操作#at&gt;useradd aaa //在at命令里设定添加用户aaa#ctrl+d //退出at命令#tail -f /etc/passwd //查看/etc/passwd文件后十行是否增加了一个用户aaa##计划任务设定后，在没有执行之前我们可以用atq命令来查看系统没有执行工作任务。atq##启动计划任务后，如果不想启动设定好的计划任务可以使用atrm命令删除。atrm 1 //删除计划任务1##pstree命令：列出当前的进程，以及它们的树状结构 格式：pstree [选项] [pid|user]pstree##nice命令：改变程序执行的优先权等级 应用程序优先权值的范围从-20～19，数字越小，优先权就越高。一般情况下，普通应用程序的优先权值（CPU使用权值）都是0，如果让常用程序拥有较高的优先权等级，自然启动和运行速度都会快些。需要注意的是普通用户只能在0～19之间调整应用程序的优先权值，只有超级用户有权调整更高的优先权值（从-20～19）。nice [-n &lt;优先等级&gt;][--help][--version][命令]nice -n 5 ls##sleep命令：使进程暂停执行一段时间date;sleep 1m;date##renice命令 renice命令允许用户修改一个正在运行进程的优先权。利用renice命令可以在命令执行时调整其优先权。##其中，参数number与nice命令的number意义相同。（1） 用户只能对自己所有的进程使用renice命令。（2） root用户可以在任何进程上使用renice命令。（3） 只有root用户才能提高进程的优先权renice -5 -p 5200 #PID为5200的进程nice设为-5 ##pmap命令用于显示一个或多个进程的内存状态。其报告进程的地址空间和内存状态信息 #pmap PID pmap 20367 查看Linux系统每个IP的连接数1netstat -n | awk '/^tcp/&#123;print $5&#125;' | awk -F: '&#123;print $1&#125;' | sort | uniq -c | sort -nr awk数量统计 统计Apache/Nginx日志中某一天不同IP的访问量 &lt;统计日志&gt; 例如: awk ‘{a[$1]++}END{for(i in a){printf(“%d\t%s\n”,a[i],i)}}’ access.log | sort -nr | head -5 1234567891011[root@test nginx_log]# grep '07/Aug/2012' access.log |awk '&#123;a[$1]++&#125; END&#123;for(i in a)&#123;print i,a[i]&#125; &#125;' |sort -k2 -rn |head222.130.129.42 5761123.126.51.94 988123.126.68.22 588123.114.46.141 41861.135.249.218 368110.75.173.162 330110.75.173.163 327110.75.173.161 321110.75.173.160 319110.75.173.164 314 相关解释 {a[$1]++} 对每行内容，以第一个字段（估计就是IP地址吧）为数组下标进行计数。若遇第一个字段相同的情况，计数累加。用于统计各个IP地址出现的次数。 END{for(i in a){printf(“%d\t%s\n”,a[i],i)}} 对数组中的每个下标，打印最终统计次数及IP地址，中间以TAB分隔。 sort -nr 由于之前的打印是次数在前，所以这里可以用sort按数字由大到小排序 head -5 取前5个，即出现次数最多的（访问频率最高的） 查看inode信息 除了文件本身的文件名称之外,文件所有的信息都在inode中保存. 1234567891011121314# 查看文件的inode信息[root@3 ~]# stat /etc/passwd File: ‘/etc/passwd’ Size: 1047 Blocks: 8 IO Block: 4096 regular fileDevice: fd00h/64768d Inode: 67498799 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Context: system_u:object_r:passwd_file_t:s0Access: 2022-05-02 14:01:01.743000000 +0800Modify: 2021-05-25 18:03:10.665000000 +0800Change: 2021-05-25 18:03:10.669000000 +0800# 查看文件的inode号码[root@3 ~]# ls -i /etc/passwd67498799 /etc/passwd 性能相关1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#查看当前系统loaduptime#查看系统状态和每个进程的系统资源使用状况top#可视化显示CPU的使用状况htop#查看每个CPU的负载信息mpstat -P ALL 1#每隔1秒查看磁盘IO的统计信息iostat -xkdz 1#每隔一秒查看虚拟内存的使用信息vmstat 1#查看内存使用统计信息free#查看网络使用信息nicstat -z 1#类似vmstat的显示优化的工具dstat 1#查看系统活动状态，比如系统分页统计，块设备IO统计等sar#网络连接状态查看netstat -s#进程资源使用信息查看pidstat 1pidstat -d 1#查看某个进程的系统调用信息 -p后面是进程id，-tttT 进程系统后的系统调用时间strace -tttT -p 12670#统计IO设备输入输出的系统调用信息strace -c dd if=/dev/zero of=/dev/null bs=512 count=1024k#tcpdump 查看网络数据包tcpdump -nr /tmp/out.tcpdump#块设备的读写事件信息统计btrace /dev/sdb #iotop查看某个进程的IO操作统计信息iotop -bod5#slabtop 查看内核 slab内存分配器的使用信息slabtop -sc#系统参数设置sysctl -a#系统性能指标统计信息perf stat gzip file1#系统cpu活动状态查看perf record -a -g -F 997 sleep 10 磁盘IO检查1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768##iostat是查看磁盘活动统计情况##显示所有设备负载情况 r/s: 每秒完成的读 I/O 设备次数。即 rio/s；w/s: 每秒完成的写 I/O 设备次数。即 wio/s等iostat ##每隔2秒刷新磁盘IO信息，并且每次显示3次iostat 2 3#显示某个磁盘的IO信息iostat -d sda1##显示tty和cpu信息iostat -t##以M为单位显示磁盘IO信息iostat -m##查看TPS和吞吐量信息 kB_read/s：每秒从设备（drive expressed）读取的数据量；kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；iostat -d -k 1 1#查看设备使用率（%util）、响应时间（await）iostat -d -x -k 1 1#查看CPU状态iostat -c 1 3#统计进程(pid)的stat,进程的stat自然包括进程的IO状况pidstat#只显示IOpidstat -d 1 #-d IO 信息,-r 缺页及内存信息-u CPU使用率-t 以线程为统计单位1 1秒统计一次pidstat -u -r -d -t 1#文件级IO分析,查看当前文件由哪些进程打开lsof ls /proc/pid/fd#利用 sar 报告磁盘 I/O 信息DEV 正在监视的块设备 tps 每秒钟物理设备的 I/O 传输总量 rd_sec/s 每秒从设备读取的扇区数量 wr_sec/s 每秒向设备写入的扇区数量 avgrq-sz I/O 请求的平均扇区数#avgqu-sz I/O 请求的平均队列长度 await I/O 请求的平均等待时间，单位为毫秒 svctm I/O 请求的平均服务时间，单位为毫秒 %util I/O 请求所占用的时间的百分比，即设备利用率sar -pd 10 3 #iotop top的io版iotop#查看页面缓存信息 其中的Cached 指用于pagecache的内存大小（diskcache-SwapCache）。随着写入缓存页，Dirty 的值会增加 一旦开始把缓存页写入硬盘,Writeback的值会增加直到写入结束。cat /proc/meminfo #查看有多少个pdflush进程 Linux 用pdflush进程把数据从缓存页写入硬盘#pdflush的行为受/proc/sys/vm中的参数的控制/proc/sys/vm/dirty_writeback_centisecs (default 500): 1/100秒, 多长时间唤醒pdflush将缓存页数据写入硬盘。默认5秒唤醒2个（更多个）线程。如果wrteback的时间长于dirty_writeback_centisecs的时间，可能会出问题cat /proc/sys/vm/nr_pdflush_threads#查看I/O 调度器#调度算法#noop anticipatory deadline [cfq] #deadline : deadline 算法保证对既定的IO请求以最小的延迟时间。#anticipatory：有个IO发生后，如果又有进程请求IO，则产生一个默认6ms猜测时间，猜测下一个进程请求IO是干什么。这对于随机读取会造成较大的延时。对数据库应用很糟糕，而对于Web Server等则会表现不错。#cfq: 对每个进程维护一个IO队列，各个进程发来的IO请求会被cfq以轮循方式处理，对每一个IO请求都是公平。适合离散读的应用。#noop: 对所有IO请求都用FIFO队列形式处理。默认IO不会存在性能问题。cat /sys/block/[disk]/queue/scheduler#改变IO调度器$ echo deadline &gt; /sys/block/sdX/queue/scheduler#提高调度器请求队列的$ echo 4096 &gt; /sys/block/sdX/queue/nr_requests 概念进程与线程概念 进程： 是系统进行资源分配和调度的一个独立单位. 是程序的一次执行，每个进程都有自己的地址空间、内存、数据栈及其他辅助记录运行轨迹的数据 线程： 是进程的一个实体，是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位 所有的线程运行在同一个进程中，共享相同的运行资源和环境 线程一般是并发执行的，使得实现了多任务的并行和数据共享。 区别（1）通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。（2）线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程主要是为了节约CPU时间，发挥利用，根据具体情况而定。线程的运行中需要使用计算机的内存资源和CPU。（3）进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。（4）线程的上下文切换远大于进程间上下文切换的速度。（5）进程是不可执行的实体，程序是一个没有生命的实体，只有当处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。 进程和线程的关系（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。（3）处理机分给线程，即真正在处理机上运行的是线程。（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体. 进程与线程的区别（1）调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位（2）并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行（3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.（4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。 软链接与硬链接的区别 路径 软链接: 必须是绝对路径 硬链接: 可以是相对路径,也可以是绝对路径 权限 软链接: 链接文件权限永远是 777 硬链接: 跟源文件权限一致 变更源文件 软链接: 不可以删除与移动源文件 硬链接: 可以删除与移动源文件 inode数量 软链接: inode数量与源文件不通 硬链接: inode数量与源文件相同 文件与目录 软链接: 对目录与文件都生效 硬链接: 只对文件生效 跨文件系统 软链接: 可以跨文件系统 硬链接: 不可以跨文件系统 cookie与session的区别： cookie数据保存在客户端，session数据保存在服务器端。 session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。 CDN访问流程 ①当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。 ②CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。 ③用户向CDN的全局负载均衡设备发起内容URL访问请求。 ④CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。 ⑤区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。 ⑥全局负载均衡设备把服务器的IP地址返回给用户。 ⑦用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。 DNS服务器根据用户IP地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。使用CDN服务的网站，只需将其域名解析权交给CDN的GSLB设备，将需要分发的内容注入CDN，就可以实现内容加速了。 进程间如何通信 通信方法 无法介于内核态与用户态的原因 管道（不包括命名管道） 局限于父子进程间的通信。 消息队列 在硬、软中断中无法无阻塞地接收数据。 信号量 无法介于内核态和用户态使用。 共享内存 需要信号量辅助，而信号量又无法使用。 什么是rootkit入侵者入侵后往往会进行清理脚印和留后门等工作，最常使用的后门创建工具就是rootkit。不要被名字所迷惑，这个所谓的“rootkit”可不是给超级用户root用的，它是入侵者在入侵了一台主机后，用来做创建后门并加以伪装用的程序包。这个程序包里通常包括了日志清理器，后门等程序。同时，程序包里通常还带有一些伪造的ps、ls、who、w、netstat等原本属于系统本身的程序。这样的话，程序员在试图通过这些命令查询系统状况的时候，就无法通过这些假的系统程序发觉入侵者的行踪。 在一些黑客组织中,rootkit (或者backdoor) 是一个非常感兴趣的话题。各种不同的rootkit被开发并发布在internet上。在这些rootkit之中, LKM尤其被人关注, 因为它是利用现代操作系统的模块技术。作为内核的一部分运行,这种rootkit将会越来越比传统技术更加强大更加不易被发觉。一旦被安装运行到目标机器上, 系统就会完全被控制在hacker手中了。甚至系统管理员根本找不到安全隐患的痕迹, 因为他们不能再信任它们的操作系统了。 后门程序的目的就是甚至系统管理员企图弥补系统漏洞的时候也可以给hacker系统的访问权限。 什么是蜜罐蜜罐技术本质上是一种对攻击方进行欺骗的技术，通过布置一些作为诱饵的主机、网络服务或者信息，诱使攻击方对它们实施攻击，从而可以对攻击行为进行捕获和分析，了解攻击方所使用的工具与方法，推测攻击意图和动机，能够让防御方清晰地了解他们所面对的安全威胁，并通过技术和管理手段来增强实际系统的安全防护能力。 蜜罐好比是情报收集系统。蜜罐好像是故意让人攻击的目标，引诱黑客前来攻击。所以攻击者入侵后，你就可以知道他是如何得逞的，随时了解针对服务器发动的最新的攻击和漏洞。还可以通过窃听黑客之间的联系，收集黑客所用的种种工具，并且掌握他们的社交网络。 Linux中什么是WatchdogWatchdog在实现上可以是硬件电路也可以是软件定时器，能够在系统出现故障时自动重新启动系统。在Linux 内核下, watchdog的基本工作原理是：当watchdog启动后(即/dev/watchdog 设备被打开后)，如果在某一设定的时间间隔内/dev/watchdog没有被执行写操作, 硬件watchdog电路或软件定时器就会重新启动系统 访问一个网站的流程用户输入网站按回车， 查找本地缓存，如果有就打开页面，如果没有，利用DNS做域名解析，递归查询，一级一级的向上提交查询请求，知道查询到为止HOSTS表 –&gt; 本地DNS –&gt;上层DNS(包括根DNS) 经过了DNS解析，知道了网站的IP地址，然后建立tcp三次握手; 建立请求后，发送请求报文，默认请求的是index.html 传送完毕，断开连接 三次握手，四次挥手三次握手 由客户端(用户)发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的。并且还将报文中SYN字段置为 1，表示需要建立TCP连接请求。 服务端(就是百度服务器)会回复客户端(用户)发送的TCP连接请求报文，其中包含seq序列号，也是由回复端随机生成的， 并且将回复报文的SYN字段置1，而且会产生ACK验证字段，ACK 验证字段数值是在客户端发过来的seq序列号基础上加 1 进行回复: 并且还会回复ack确认控制字段，以便客户端收到信息时，知晓自己的TCP建立请求已得到了确认。 客户端收到服务端发送的TCP建立请求后，会使自己的原有序列号加 1 进行再次发送序列号， 并且再次回复ACK验证请求，在B端发送过来的seq基础上加1，进行回复; 同时也会回复 ack 确认控制字段， 以便B收到信息时，知晓自己的TCP建立请求已经得到了确认。 四次挥手* *第一次挥手: Client 发送一个 FIN，用来关闭 Client 到 Server 的数据传送，Client 进入 FIN_WAIT_1 状态。 第二次挥手: Server 收到 FIN 后，发送一个 ACK 给 Client，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)，Server 进入 CLOSE_WAIT 状态。 第三次挥手: Server 发送一个FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。 第四次挥手: Client 收到 FIN 后，Client 进入 TIME_WAIT 状态，接着发送一个 ACK 给Server，确认序号为收到序号+1， Server进入CLOSED状态，完成四次挥手. LVS相关LVS 负载均衡有哪些策略LVS一共有三种工作模式: DR Tunnel NAT 谈谈你对LVS的理解LVS是一个虚拟的服务器集群系统，在unix系统下实现负载均衡的功能;采用IP负载均衡技术和机遇内容请求分发技术来实现。 LVS采用三层结构，分别是: 第一层: 负载调度器 第二层: 服务池 第三层:共享存储 负载调度器(load balancer/ Director)，是整个集群的总代理，它有两个网卡，一个网卡面对访问网站的客户端，一个网卡面对整个集群的内部。负责将客户端的请求发送到一组服务器上执行，而客户也认为服务是来自这台主的。举个生动的例子，集群是个公司，负载调度器就是在外接揽生意，将接揽到的生意分发给后台的真正干活的真正的主机们。当然需要将活按照一定的算法分发下去，让大家都公平的干活。 服务器池(server pool/ Realserver)，是一组真正执行客户请求的服务器，可以当做WEB服务器。就 是上面例子中的小员工。 共享存储(shared storage)，它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相 同的内容，提供相同的服务。一个公司得有一个后台账目吧，这才能协调。不然客户把钱付给了A，而 换B接待客户，因为没有相同的账目。B说客户没付钱，那这样就不是客户体验度的问题了。 负载均衡的原理是什么当客户端发起请求时，请求直接发给Director Server(调度器)，这时会根据设定的调度算法，将请求按照算法的规定智能的分发到真正的后台服务器。以达到将压力均摊。 但是我们知道，http的连接时无状态的，假设这样一个场景，我登录某宝买东西，当我看上某款商品时，我将它加入购物车，但是我刷新了一下页面，这时由于负载均衡的原因，调度器又选了新的一台服务器为我提供服务，我刚才的购物车内容全都不见了，这样就会有十分差的用户体验。 所以就还需要一个存储共享，这样就保证了用户请求的数据是一样的 LVS由哪两部分组成的LVS由ipvs和ipvsadm组成 ipvs(ip virtual server): 一段代码工作在内核空间，叫ipvs，是真正生效实现调度的代码。 ipvsadm: 另外一段是工作在用户空间，叫ipvsadm，负责为ipvs内核框架编写规则，定义谁是集群服务，而谁是后端真实的服务器(Real Server) LVS相关的术语 DS: Director Server。指的是前端负载均衡器节点。 RS: Real Server。后端真实的工作服务器。 VIP: Virtual IP 向外部直接面向用户请求，作为用户请求的目标的IP地址。 DIP: Director Server IP，主要用于和内部主机通讯的IP地址。 RIP: Real Server IP，后端服务器的IP地址。 CIP: Client IP，访问客户端的IP地址。 LVS-NAT模式的原理 (1). 当用户请求到达 Director Server，此时请求的数据报文会先到内核空间的 PREROUTING 链。 此时报文的源IP为CIP，目标IP为VIP (2). PREROUTING检查发现数据包的目标 IP 是本机，将数据包送至 INPUT 链 (3). IPVS比对数据包请求的服务是否为集群服务，若是，修改数据包的目标IP地址为后端服务器 IP， 然后将数据包发至POSTROUTING链。 此时报文的源IP为CIP，目标IP为RIP (4). POSTROUTING链通过选路，将数据包发送给Real Server (5). Real Server比对发现目标为自己的IP，开始构建响应报文发回给Director Server。 此时报文的源IP为RIP，目标IP为CIP (6). Director Server在响应客户端前，此时会将源IP地址修改为自己的VIP地址，然后响应给客户端。 此时报文的源IP为VIP，目标IP为CIP LVS-NAT模型的特性 RS 应该使用私有地址，RS 的网关必须指向 DIP DIP 和 RIP 必须在同一个网段内 请求和响应报文都需要经过 Director Server，高负载场景中，Director Server 易成为性能瓶颈 支持端口映射 RS 可以使用任意操作系统 缺陷: 对 Director Server 压力会比较大，请求和响应都需经过 Director server LVS-DR模式原理 (1) 当用户请求到达 Director Server，此时请求的数据报文会先到内核空间的 PREROUTING 链。 此时报文的源IP为 CIP，目标 IP 为 VIP (2) PREROUTING 检查发现数据包的目标IP是本机，将数据包送至 INPUT 链 (3) IPVS比对数据包请求的服务是否为集群服务，若是，将请求报文中的源 MAC 地址修改为 DIP 的 MAC 地址，将目标 MAC 地址修改 RIP 的 MAC 地址，然后将数据包发至 POSTROUTING 链。 此时的源 IP 和目的 IP 均未修改，仅修改了源 MAC 地址为 DIP 的 MAC 地址，目标 MAC 地址为 RIP 的 MAC 地址 (4) 由于 DS 和 RS 在同一个网络中，所以是通过二层来传输。POSTROUTING 链检查目标 MAC 地址为 RIP 的 MAC 地址，那么此时数据包将会发至Real Server。 (5) RS 发现请求报文的 MAC 地址是自己的 MAC 地址，就接收此报文。处理完成之后，将响应报文通过 lo 接口传送给 eth0 网卡然后向外发出。 此时的源 IP 地址为 VIP，目标 IP 为 CIP (6) 响应报文最终送达至客户端 LVS-DR模型的特性特点: 保证前端路由将目标地址为 VIP 报文统统发给 Director Server，而不是 RS RS 可以使用私有地址; 也可以是公网地址，如果使用公网地址，此时可以通过互联网对RIP进行直接访问 RS 跟 Director Server 必须在同一个物理网络中 所有的请求报文经由 Director Server，但响应报文不能经过 Director Server 不支持地址转换，也不支持端口映射 RS 可以是大多数常见的操作系统 RS 的网关绝不允许指向DIP(因为我们不允许他经过director) RS 上的 lo 接口配置 VIP 的 IP 地址 缺陷: RS 和 DS 必须在同一机房中 LVS三种负载均衡模式的比较三种负载均衡: nat，tunneling，dr| 类目 | NAT | TUN | DR || :——–: | :——–: | :———–: | :—————: || 操作系统 | 任意 | 支持隧道 | 多数(支持non-arp) || 服务器网络 | 私有网络 | 局域网/广域网 | 局域网 || 服务器数目 | 10-20 | 100 | 大于100 || 服务器网关 | 负载均衡器 | 自己的路由 | 自己的路由 || 效率 | 一般 | 高 | 最高 | LVS的负载调度算法 轮叫调度 加权轮叫调度 最小连接调度 加权最小连接调度 基于局部性能的最少连接 带复制的基于局部性能最小连接 目标地址散列调度 源地址散列调度 LVS与nginx的区别lvs的优势(互联网老辛): 抗负载能力强，因为 lvs 工作方式的逻辑是非常简单的，而且工作在网络的第 4 层，仅作请求分发用，没有流量，所以在效率上基本不需要太过考虑。lvs 一般很少出现故障，即使出现故障一般也是其他地方(如内存、CPU等)出现问题导致 lvs 出现问题。 配置性低，这通常是一大劣势同时也是一大优势，因为没有太多的可配置的选项，所以除了增减服务器，并不需要经常去触碰它，大大减少了人为出错的几率。 工作稳定，因为其本身抗负载能力很强，所以稳定性高也是顺理成章的事，另外各种 lvs 都有完整的双机热备方案，所以一点不用担心均衡器本身会出什么问题，节点出现故障的话，lvs 会自动判别，所以系统整体是非常稳定的。 无流量，lvs 仅仅分发请求，而流量并不从它本身出去，所以可以利用它这点来做一些线路分流之用。没有流量同时也保住了均衡器的 IO 性能不会受到大流量的影响。 lvs 基本上能支持所有应用，因为 lvs 工作在第4层，所以它可以对几乎所有应用做负载均衡，包括 http、数据库、聊天室等。 nginx与LVS的对比: nginx工作在网络的第7层，所以它可以针对 http 应用本身来做分流策略，比如针对域名、目录结构等，相比之下 lvs 并不具备这样的功能，所以 nginx 单凭这点可以利用的场合就远多于 lvs 了;但 nginx 有用的这些功能使其可调整度要高于lvs，所以经常要去触碰，由 lvs 的第2条优点来看，触碰多了，人为出现问题的几率也就会大。 nginx对网络的依赖较小，理论上只要 ping 得通，网页访问正常，nginx就能连得通，nginx 同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路; lvs 就比较依赖于网络环境，目前来看服务器在同一网段内并且 lvs 使用 direct 方式分流，效果较能得到保证。另外注意，lvs 需要向托管商至少申请多于一个 ip 来做visual ip。 nginx 安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。lvs 的安装和配置、测试就要花比较长的时间，因为同上所述，lvs 对网络依赖性比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦的多。 nginx也同样能承受很高负载且稳定，但负载度和稳定度差 lvs 还有几个等级:nginx处理所有流量所以受限于机器 IO 和配置;本身的bug也还是难以避免的;nginx没有现成的双机热备方案，所以跑在单机上还是风险比较大，单机上的事情全都很难说。 nginx 可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前 lvs 中 ldirectd 也能支持针对服务器内部的情况来监控，但 lvs 的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，nginx 会把上传切到另一台服务器重新处理，而 lvs 就直接断掉了。 两者配合使用: nginx 用来做 http 的反向代理，能够 upsteam 实现 http 请求的多种方式的均衡转发。由于采用的是异步转发可以做到如果一个服务器请求失败，立即切换到其他服务器，直到请求成功或者最后一台服务器失败为止。这可以最大程度的提高系统的请求成功率。 lvs采用的是同步请求转发的策略。这里说一下同步转发和异步转发的区别。同步转发是在 lvs 服务器接收到请求之后，立即 redirect 到一个后端服务器，由客户端直接和后端服务器建立连接。异步转发是 nginx 在保持客户端连接的同时，发起一个相同内容的新请求到后端，等后端返回结果后，由 nginx 返回给客户端。 进一步来说:当做为负载均衡服务器的 nginx 和 lvs 处理相同的请求时，所有的请求和响应流量都会经过 nginx; 但是使用 lvs 时，仅请求流量经过 lvs 的网络，响应流量由后端服务器的网络返回。 也就是，当作为后端的服务器规模庞大时，nginx的网络带宽就成了一个巨大的瓶颈。 但是仅仅使用 lvs 作为负载均衡的话，一旦后端接受到请求的服务器出了问题，那么这次请求就失败了。 但是如果在lvs的后端在添加一层nginx(多个)，每个nginx后端再有几台应用服务器，那么结合两者的优势，既能避免单nginx的流量集中瓶颈，又能避免单lvs时一锤子买卖的问题。 负载均衡的作用有哪些1、转发功能 按照一定的算法【权重、轮询】，将客户端请求转发到不同应用服务器上，减轻单个服务器压力，提高系统并发量。 2、故障移除 通过心跳检测的方式，判断应用服务器当前是否可以正常工作，如果服务器期宕掉，自动将请求发送到其他应用服务器。 3、恢复添加 如检测到发生故障的应用服务器恢复工作，自动将其添加到处理用户请求队伍中。 Nginx与Apache相关常见问题 nginx负载均衡实现的策略 轮询(默认) 权重 ip_hash fair(第三方插件) url_hash(第三方插件) nginx做负载均衡用到的模块 upstream 定义负载节点池。 location 模块进行URL匹配。 proxy模块发送请求给upstream定义的节点池。 负载均衡有哪些实现方式 硬件负载 HTTP重定向负载均衡 DNS负载均衡 反向代理负载均衡 IP层负载均衡 数据链路层负载均衡 web服务有哪些 apache nginx IIS tomcat lighttpd weblogic 为什么要用nginx 跨平台、配置简单，非阻塞、高并发连接: 处理2-3万并发连接数，官方监测能支持5万并发 内存消耗小: 开启10个nginx才占150M内存，nginx处理静态文件好,耗费内存少 内置的健康检查功能: 如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。 节省宽带: 支持GZIP压缩，可以添加浏览器本地缓存 稳定性高: 宕机的概率非常小 接收用户请求是异步的 nginx的性能为什么比apache高nginx采用的是epoll模型和kqueue网络模型，而apache采用的是select模型 举一个例子来解释两种模型的区别: 菜鸟驿站放着很多快件，以前去拿快件都是短信通知你有快件，然后你去了之后，负责菜鸟驿站的人在一堆快递里帮你找，直到找到为止。 但现在菜鸟驿站的方式变了，他会发你一个地址，比如 3-3-5009. 这个就是第三个货架的第三排，从做往右第九个。 如果有几百个人同时去找快递，这两种方式哪个更有效率，不言而喻。 之前还看到这个例子也比较形象: 123456&gt; 假设你在大学读书，住的宿舍楼有很多间房间，你的朋友要来找你。select版宿管大妈就会带着你的朋友挨个房间去找，直到找到你为止。而epoll版宿管大妈会先记下每位同学的房间号，你的朋友来时，只需告诉你的朋友你住在哪个房间即可，不用亲自带着你的朋友满大楼找人。如果来了10000个人，都要找自己住这栋楼的同学时，select版和epoll版宿管大妈，谁的效率更高，不言自明。同理，在高并发服务器中，轮询I/O是最耗时间的操作之一，select和epoll的性能谁的性能更高，同样十分明了 select 采用的是轮询的方式来处理请求，轮询的次数越多，耗时也就越多。 nginx和apache的区别Nginx 轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源 抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。 nginx 处理静态文件好，静态处理性能比 apache 高三倍以上 nginx 的设计高度模块化，编写模块相对简单 nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题， apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃 nginx 作为负载均衡服务器，支持 7 层负载均衡七层负载可以有效的防止ddos攻击 nginx本身就是一个反向代理服务器，也可以左右邮件代理服务器来使用 Apache apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache apache 发展到现在，模块超多，基本想到的都可以找到 apache 更为成熟，少 bug ，nginx 的 bug 相对较多 apache 对 PHP 支持比较简单，nginx 需要配合其他后端用 apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。 apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区 两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接(万级别)可以对应一个进程。 需要稳定用 apache，需要高性能用 nginx 反向代理与正向代理以及区别正向代理: 所谓的正向代理就是: 需要在用户端去配置的。配置完再去访问具体的服务，这叫正向代理 正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。 正向代理的用途: 提高访问速度 隐藏客户真实IP 反向代理: 反向代理是在服务端的，不需要访问用户关心。用户访问服务器A, A服务器是代理服务器，将用户服务 再转发到服务器B.这就是反向代理 反向代理的作用: 缓存，将服务器的响应缓存在自己的内存中，减少服务器的压力。 负载均衡，将用户请求分配给多个服务器。 访问控制 nginx如何处理http请求四个步骤: 读取解析请求行; 读取解析请求头; 开始最重要的部分，即多阶段处理; nginx 把请求处理划分成了11个阶段，也就是说当 nginx 读取了请求行和请求头之后，将请求封装了结构体ngx_http_request_t，然后每个阶段的 handler 都会根据这个 ngx_http_request_t，对请求进行处理，例如重写uri，权限控制，路径查找，生成内容以及记录日志等等; 最后将结果返回给客户端。 也可以这么回答: 首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master 进程里面先初始化好这个监控的Socket(创建 Socket，设置 addr、reuse 等选项，绑定到指定的 ip 地址端口，再 listen 监听)。 然后，再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程 )出多个子进程出来。 之后，子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与 nginx进行三次握手，与 nginx 建立好一个连接后。此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ， 然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体。 接着，设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。 最后，Nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了。 nginx虚拟主机有哪些 基于域名的虚拟主机 基于端口的虚拟主机 基于 IP 的虚拟主机 apache中的Worker和Prefork的区别它们都是MPM, Worker 和 prefork 有它们各自在Apache上的运行机制. 它们完全依赖于你想要以哪一种模式启动你的Apache. Worker 和 MPM 基本的区别在于它们产生子进程的处理过程, 在 Prefork MPM 中, 一个主 httpd 进行被启动，这个主进程会管理所有其它子进程为客户端请求提供服务. 而在worker MPM中一个httpd进程被激活，则会使用不同的线程来为客户端请求提供服务. Prefork MPM 使用多个子进程，每一个进程带有一个线程; 而 worker MPM 使用多个子进程，每一个进程带有多个线程. Prefork MPM中的连接处理, 每一个进程一次处理一个连接而在Worker mpm中每一个线程一次处理一个连接. 内存占用 Prefork MPM 占用庞大的内存, 而Worker占用更小的内存 nginx的优化 gzip压缩优化 expires缓存 网络IO事件模型优化 隐藏软件名称和版本号 防盗链优化 禁止恶意域名解析 禁止通过IP地址访问网站 HTTP请求方法优化 防DOS攻击单IP并发连接的控制，与连接速率控制 严格设置web站点目录的权限 将nginx进程以及站点运行于监牢模式 通过robot协议以及HTTP_USER_AGENT防爬虫优化 配置错误页面根据错误码指定网页反馈给用户 nginx日志相关优化访问日志切割轮询，不记录指定元素日志、最小化日志目录权限 限制上传到资源目录的程序被访问，防止木马入侵系统破坏文件 FastCGI参数buffer和cache配置文件的优化 php.ini和php-fpm.conf配置文件的优化 有关web服务的Linux内核方面深度优化(网络连接、IO、内存等) nginx加密传输优化(SSL) web服务器磁盘挂载及网络文件系统的优化 使用nginx cache nginx的session不同步怎么办我们可以采用 ip_hash 指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。即每个访客固定访问一个后端服务器，可以解决 session 的问题。 其他办法: 那就是用 spring_session+redis，把session放到缓存中实现 session 共享。 Tomcat相关Tomcat作为web的优缺点缺点:tomcat 只能用做 java 服务器，处理静态请求的能力不如 nginx 和 apache，高并发能力有限 优点: 动态解析容器，处理动态请求，是编译 JSP/Servlet 的容器，轻量级 tomcat的三个端口及作用 8005: 关闭Tomcat通信接口 8009: 与其他httpd服务器通信接口，用于http服务器的集合 8080: 建立httpd连接用，如浏览器访问 Tomcat缺省端口是多少，怎么修改 找到Tomcat目录下的conf文件夹 进入conf文件夹里面找到server.xml文件 打开server.xml文件 在server.xml文件里面找到下列信息 把Connector标签的8080端口改成你想要的端口 Tomcat的工作模式是什么Tomcat作为servlet容器，有三种工作模式: 独立的servlet容器，servlet容器是web服务器的一部分; 进程内的servlet容器，servlet容器是作为web服务器的插件和java容器的实现，web服务器插件在内部地址空间打开一个jvm使得java容器在内部得以运行。反应速度快但伸缩性不足; 进程外的servlet容器，servlet容器运行于web服务器之外的地址空间，并作为web服务器的插件和 java 容器实现的结合。反应时间不如进程内但伸缩性和稳定性比进程内优; 进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类: Tomcat作为应用程序服务器:请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等; Tomcat作为独立服务器:请求来自于web浏览器; Web请求在Tomcat请求中的请求流程 浏览器输入URL地址; 查询本机hosts文件寻找IP; 查询DNS服务器寻找IP; 向该IP发送Http请求; Tomcat容器解析主机名; Tomcat容器解析Web应用; Tomcat容器解析资源名称; Tomcat容器获取资源; Tomcat响应浏览器。 Tomcat优化 Tomcat的运行模式 : bio,nio, apr 一般使用nio模式，bio效率低，apr对系统配置有一些更高的要求 关键配置maxThreads: 最大线程数，默认是200，minspareThread: 最小活跃线程数，默认是25maxqueuesize: 最大等待队列个数 影响性能的配置:compression 设置成on，开启压缩禁用AJP连接器: 用nginx+Tomcat的架构，用不到AJPenableLookups=false 关闭反查域名，直接返回ip，提高效率disableUploadTimeou=false 上传是否使用超时机制acceptCount=300 , 当前所有可以使用的处理请求都被使用时，传入请求连接最大队列长队，超过个数不予处理，默认是100keepalive timeout=120000 场链接保持时间 优化jvm /bin/catalina.sh -server: jvm的server工作模式，对应的有client工作模式。使用“java -version”可以查看当前工作 模式 -Xms1024m: 初始Heap大小，使用的最小内存 -Xmx1024m: Java heap 最大值，使用的最大内存。经验: 设置 Xms 大小等于 Xmx 大小 -XX:NewSize=512m:表示新生代初始内存的大小，应该小于 -Xms 的值 -XX:MaxNewSize=1024M:表示新生代可被分配的内存的最大上限，应该小于 -Xmx 的值 -XX:PermSize=1024m:设定内存的永久保存区域,内存的永久保存区域，VM 存放 Class 和 Meta 信息，JVM在运行期间不会清除该区域 -XX:MaxPermSize=1024m:设定最大内存的永久保存区域。经验: 设置PermSize大小等于 MaxPermSize大小 -XX:+DisableExplicitGC:自动将System.gc() 调用转换成一个空操作，即应用中调用System.gc() 会变成一个空操作，避免程序员在代码里进行System.gc()这种危险操作。System.gc() 除非是到了万不得也的情况下使用，都应该交给 JVM。 fastcgi 和cgi的区别cgi: web 服务器会根据请求的内容，然后会 fork 一个新进程来运行外部 c 程序(或 perl 脚本…)， 这个进程会把处理完的数据返回给 web 服务器，最后 web 服务器把内容发送给用户，刚才 fork 的进程也随之退出。 如果下次用户还请求该动态脚本，那么 web 服务器又再次 fork 一个新进程，周而复始的进行 fastcgi: web 服务器收到一个请求时，他不会重新 fork 一个进程(因为这个进程在 web 服务器启动时就开启了，而且不会退出)，web 服务器直接把内容传递给这个进程(进程间通信，但 fastcgi 使用了别的方式，tcp 方式通信)，这个进程收到请求后进行处理，把结果返回给 web 服务器，最后自己接着等待下一个请求的到来，而不是退出。 Keepalived相关keepalived 是什么广义上讲是高可用，狭义上讲是主机的冗余和管理 Keepalived起初是为 LVS 设计的，专门用来监控集群系统中各个服务节点的状态，它根据 TCP/IP 参考模型的第三、第四层、第五层交换机制检测每个服务节点的状态，如果某个服务器节点出现异常，或者工作出现故障，Keepalived 将检测到，并将出现的故障的服务器节点从集群系统中剔除，这些工作全部是自动完成的，不需要人工干涉，需要人工完成的只是修复出现故障的服务节点。 后来 Keepalived 又加入了 VRRP 的功能，VRRP(VritrualRouterRedundancyProtocol,虚拟路由冗余协议)出现的目的是解决静态路由出现的单点故障问题，通过 VRRP 可以实现网络不间断稳定运行，因此 Keepalvied 一方面具有服务器状态检测和故障隔离功能，另外一方面也有 HAcluster 功能。 所以 keepalived 的核心功能就是健康检查和失败切换。 所谓的健康检查，就是采用 tcp 三次握手，icmp 请求，http 请求，udp echo 请求等方式对负载均衡器后面的实际的服务器(通常是承载真实业务的服务器)进行保活; 而失败切换主要是应用于配置了主备模式的负载均衡器，利用 VRRP 维持主备负载均衡器的心跳，当主负载均衡器出现问题时，由备负载均衡器承载对应的业务，从而在最大限度上减少流量损失，并提供服务的稳定性 如何理解VRRP协议为什么使用 VRRP ? 主机之间的通信都是通过配置静态路由或者(默认网关)来完成的，而主机之间的路由器一旦发生故障，通信就会失效，因此这种通信模式当中，路由器就成了一个单点瓶颈，为了解决这个问题，就引入了 VRRP 协议。 VRRP 协议是一种容错的主备模式的协议，保证当主机的下一跳路由出现故障时，由另一台路由器来代替出现故障的路由器进行工作，通过 VRRP 可以在网络发生故障时透明的进行设备切换而不影响主机之间的数据通信。 VRRP 的三种状态: VRRP路由器在运行过程中有三种状态: Initialize状态: 系统启动后就进入Initialize，此状态下路由器不对 VRRP 报文做任何处理; Master状态; Backup状态; 一般主路由器处于Master状态，备份路由器处于Backup状态。 keepalived的工作原理keepalived 采用是模块化设计，不同模块实现不同的功能。 keepalived 主要有三个模块，分别是 core、check 和 vrrp。 core: 是 keepalived 的核心，负责主进程的启动和维护，全局配置文件的加载解析等 check: 负责 healthchecker(健康检查)，包括了各种健康检查方式，以及对应的配置的解析包括LVS的配置解析;可基于脚本检查对IPVS后端服务器健康状况进行检查 vrrp: VRRPD子进程，VRRPD 子进程就是来实现 VRRP 协议的 Keepalived 高可用对之间是通过 VRRP 进行通信的， VRRP是通过竞选机制来确定主备的，主的优先级高于备，因此，工作时主会优先获得所有的资源，备节点处于等待状态，当主宕机的时候，备节点就会接管主节点的资源，然后顶替主节点对外提供服务 在 Keepalived 服务对之间，只有作为主的服务器会一直发送 VRRP 广播包,告诉备它还活着，此时备不会抢占主，当主不可用时，即备监听不到主发送的广播包时，就会启动相关服务接管资源，保证业务的连续性.接管速度最快 出现脑裂的原因什么是脑裂? 在高可用(HA)系统中，当联系2个节点的“心跳线”断开时，本来为一整体、动作协调的HA系统， 就分裂成为2个独立的个体。 由于相互失去了联系，都以为是对方出了故障。两个节点上的HA软件像“裂脑人”一样，争抢“共享 资源”、争起“应用服务”，就会发生严重后果。共享资源被瓜分、两边“服务”都起不来了;或者两边 “服务”都起来了，但同时读写“共享存储”，导致数据损坏 都有哪些原因导致脑裂? 高可用服务器对之间心跳线链路发生故障，导致无法正常通信。 因心跳线坏了(包括断了，老化)。 因网卡及相关驱动坏了，ip配置及冲突问题(网卡直连) 因心跳线间连接的设备故障(网卡及交换机) 因仲裁的机器出问题(采用仲裁的方案) 高可用服务器上开启了 iptables 防火墙阻挡了心跳消息传输。 高可用服务器上心跳网卡地址等信息配置不正确，导致发送心跳失败 其他服务配置不当等原因，如心跳方式不同，心跳广插冲突、软件Bug等。 如何解决keepalived脑裂问题在实际生产环境中，我们从以下方面防止脑裂: 同时使用串行电缆和以太网电缆连接、同时使用两条心跳线路，这样一条线路断了，另外一条还是好的，依然能传送心跳消息 当检查脑裂时强行关闭一个心跳节点(这个功能需要特殊设备支持，如stonith、fence)相当于备节点接收不到心跳消息，通过单独的线路发送关机命令关闭主节点的电源 做好对脑裂的监控报警 解决常见方案: 如果开启防火墙，一定要让心跳消息通过，一般通过允许IP段的形式解决 可以拉一条以太网网线或者串口线作为主被节点心跳线路的冗余 开发检测程序通过监控软件检测脑裂 Linux系统常见日志文件与各自的用途 路径 用途 /var/log/messages 内核及公共消息日志 /var/log/cron 计划任务日志 /var/log/dmesg 系统引导日志 /var/log/maillog 邮件系统日志 /var/log/secure 记录与访问限制相关日志 /etc/logrotate.d 此目录下是各个服务的日志轮询配置文件 Linux系统的运行级别 0=&gt;关机 1=&gt;单用户 2=&gt;多用户有网络服务 3=&gt;多用户无网络服务 4=&gt;保留 5=&gt;图形界面 6=&gt;重启 Linux开机过程1.开机BIOS自检 2.MBR引导 3.grub引导菜单 4.加载内核kernel 5.启动init进程 6.读取inittab文件，执行rc.sysinit,rc等脚本 7.启动mingetty，进入系统登陆界面 详情请参考链接:Linux开机过程 网络协议STP协议主要用途： STP通过阻塞冗余链路，来消除桥接网络中可能存在的路径回环； 当前活动路径发生故障时，STP激活冗余链路恢复网络连通性。 为什么要用STP: 原因：交换网络存在环路时引起：广播环路（广播风暴）；桥表损坏。 介绍一下ACL和NAT? ACL： 访问控制列表（ACL）是应用在路由器接口的指令列表（规则），用来告诉路由器哪些数据包可以接收转发，哪些数据包需要拒绝； ACL的工作原理 ：读取第三层及第四层包头中的信息，根据预先定义好的规则对包进行过滤； 使用ACL实现网络控制：实现访问控制列表的核心技术是包过滤； ACL的两种基本类型（标准访问控制列表；扩展访问控制列表） NAT： 改变IP包头使目的地址，源地址或两个地址在包头中被不同地址替换。 NAT有几种方式? 静态NAT 动态NAT PAT RIP协议RIP是Routing Information Protocol（路由信息协议）的简称，它是一种较为简单的内部网关协议（Interior Gateway Protocol）。RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量来衡量到达目的网络的距离。RIP通过UDP报文进行路由信息的交换，使用的端口号为520。 RIP包括RIP-1和RIP-2两个版本，RIP-2对RIP-1进行了扩充，使其更具有优势。 RIP是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量值来衡量到达目的地址的距离。在RIP网络中，缺省情况下，设备到与它直接相连网络的跳数为0，通过一个设备可达的网络的跳数为1，其余依此类推。也就是说，度量值等于从本网络到达目的网络间的设备数量。为限制收敛时间，RIP规定度量值取0～15之间的整数，大于或等于16的跳数被定义为无穷大，即目的网络或主机不可达。由于这个限制，使得RIP不可能在大型网络中得到应用。 静态路由的缺陷 配置量大 只能适用于小型网络中 维护麻烦，无法自动适应网络的拓扑变化 动态路由协议：可以根据网络拓扑的变化根据协议来选择路径 动态路由协议分为： 内部网关协议：运行在同一个AS号内的路由协议。如：RIP、OSPF、EIGRP（思科设备专用） 外部网关协议：运行在不同AS号之间的路由协议。如：BGP 内部网关协议分为： 距离矢量协议（RIP、EIGRP） 链路状态协议（OSPF） RIP协议：属于内部网关协议，是一个距离矢量协议，工作在UDP的520端口 有类路由协议：在发送路由更新的时候是不会携带子网掩码的（已经被淘汰） 无类路由协议：在发送路由更新的时候携带子网掩码。 RIP的两个版本 RIPv1：是一个有类路由协议，是通过广播（255.255.255.255）的形式来发送路由更新的。 RIPv2：是一个无类路由协议，是通过组播（224.0.0.9）的形式来发送路由更新的。 RIP的选路标准：通过跳数来衡量路径，RIP认为跳数越少，路径越优先。同时这也是它的缺陷，因为RIP有可能选择了一条次优路径。 RIPv1的特点： 有类别路由协议。 广播更新。 基于UDP，端口号520 RIP是一个基于UDP的路由协议，并且RIPv1的数据包不能超过512字节（RIP报文头部占用4个字节,而每个路由条目占用20个八位组字节。因此,RIP消息最大为4+(25*20)=504个字节,再加上8个字节的UDP头部,所以RIP数据报的大小(不含IP包的头部)最大可达512个字节。）。RIPv1的协议报文中没有携带掩码信息，所以RIPv1在发送和接收路由更新时会根据主类网段掩码和接口地址掩码来处理路由条目。因此RIPv1无法支持路由聚合，也不支持不连续子网。RIPv1的协议报文中没有验证字段，所以RIPv1也不支持验证。 RIPv2特点： 无类别路由协议。 组播更新，组播地址224.0.0.9 基于UDP，端口号520. 支持外部Tag。 支持路由聚合和CIDR 支持指定下一跳。 支持认证。 OSPF协议路由协议OSPF全称为Open Shortest Path First，也就开放的最短路径优先协议，因为OSPF是由IETF开发的，它的使用不受任何厂商限制，所有人都可以使用，所以称为开放的，而最短路径优先（SPF）只是OSPF的核心思想，其使用的算法是Dijkstra算法，最短路径优先并没有太多特殊的含义，并没有任何一个路由协议是最长路径优先的，所有协议，都会选最短的。 OSPF的流量使用IP协议号89。 OSPF工作在单个AS，是个绝对的内部网关路由协议（Interior Gateway Protocol，即IGP）。 OSPF对网络没有跳数限制，支持 Classless Interdomain Routing (CIDR)和Variable-Length Subnet Masks (VLSMs)，没有自动汇总功能，但可以手工在任意比特位汇总，并且手工汇总没有任何条件限制，可以汇总到任意掩码长度。 OSPF支持认证，并且支持明文和MD5认证；OSPF不可以通过Offset list来改变路由的metric。 OSPF并不会周期性更新路由表，而采用增量更新，即只在路由有变化时，才会发送更新，并且只发送有变化的路由信息；事实上，OSPF是间接设置了周期性更新路由的规则，因为所有路由都是有刷新时间的，当达到刷新时间阀值时，该路由就会产生一次更新，默认时间为1800秒，即30分钟，所以OSPF路由的定期更新周期默认为30分钟。 OSPF所有路由的管理距离(Ddministrative Distance)为110，OSPF只支持等价负载均衡。 距离矢量路由协议的根本特征就是自己的路由表是完全从其它路由器学来的，并且将收到的路由条目一丝不变地放进自己的路由表，运行距离矢量路由协议的路由器之间交换的是路由表，距离矢量路由协议是没有大脑的，路由表从来不会自己计算，总是把别人的路由表拿来就用；而OSPF完全抛弃了这种不可靠的算法，OSPF是典型的链路状态路由协议，路由器之间交换的并不是路由表，而是链路状态，OSPF通过获得网络中所有的链路状态信息，从而计算出到达每个目标精确的网络路径。 Kubernetes常见面试题参考链接: https://www.zhihu.com/question/379143600 1、简述etcd及其特点etcd是CoreOS团队发起的开源项目，是一个管理配置信息和服务发现（service discovery）的项目，它的目标是构建一个高可用的分布式键值（key-value）数据库，基于Go语言实现。 特点： 简单：支持REST风格的HTTP+JSON API 安全：支持HTTPS方式的访问 快速：支持并发1k/s的写操作 可靠：支持分布式结构，基于Raft的一致性算法，Raft是一套通过选举主节点来实现分布式系统一致性的算法。 2、简述etcd适应的场景etcd基于其优秀的特点，可广泛的应用于以下场景： 服务发现（Service Discovery）：服务发现主要解决在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听UDP或TCP端口，并且通过名字就可以查找和连接。 消息发布与订阅：在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。应用中用到的一些配置信息放到etcd上进行集中管理。 负载均衡：在分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。etcd本身分布式架构存储的信息访问支持负载均衡。etcd集群化以后，每个etcd的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到etcd中也可以实现负载均衡的效果。 分布式通知与协调：与消息发布和订阅类似，都用到了etcd中的Watcher机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。 分布式锁：因为etcd使用Raft算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。 集群监控与Leader竞选：通过etcd来进行监控实现起来非常简单并且实时性强。 3、简述什么是KubernetesKubernetes是一个全新的基于容器技术的分布式系统支撑平台。是Google开源的容器集群管理系统（谷歌内部：Borg）。在Docker技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。并且具有完备的集群管理能力，多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和发现机制、內建智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制以及多粒度的资源配额管理能力。 4、简述Kubernetes和Docker的关系Docker提供容器的生命周期管理和Docker镜像构建运行时容器。它的主要优点是将将软件/应用程序运行所需的设置和依赖项打包到一个容器中，从而实现了可移植性等优点。 Kubernetes用于关联和编排在多个主机上运行的容器。 5、简述Minikube、Kubectl、Kubelet分别是什么Minikube是一种可以在本地轻松运行一个单节点Kubernetes群集的工具。 Kubectl是一个命令行工具，可以使用该工具控制Kubernetes集群管理器，如检查群集资源，创建、删除和更新组件，查看应用程序。 Kubelet是一个代理服务，它在每个节点上运行，并使从服务器与主服务器通信。 6、简述Kubernetes常见的部署方式常见的Kubernetes部署方式有： kubeadm，也是推荐的一种部署方式； 二进制； minikube，在本地轻松运行一个单节点Kubernetes群集的工具。 7、简述Kubernetes如何实现集群管理在集群管理方面，Kubernetes将集群中的机器划分为一个Master节点和一群工作节点Node。其中，在Master节点运行着集群管理相关的一组进程kube-apiserver、kube-controller-manager和kube-scheduler，这些进程实现了整个集群的资源管理、Pod调度、弹性伸缩、安全控制、系统监控和纠错等管理能力，并且都是全自动完成的。 8、简述Kubernetes的优势、适应场景及其特点Kubernetes作为一个完备的分布式系统支撑平台，其主要优势： 容器编排 轻量级 开源 弹性伸缩 负载均衡 Kubernetes常见场景： 快速部署应用 快速扩展应用 无缝对接新的应用功能 节省资源，优化硬件资源的使用 Kubernetes相关特点： 可移植：支持公有云、私有云、混合云、多重云（multi-cloud）。 可扩展: 模块化,、插件化、可挂载、可组合。 自动化: 自动部署、自动重启、自动复制、自动伸缩/扩展。 9、简述Kubernetes的缺点或当前的不足之处Kubernetes当前存在的缺点（不足）如下： 安装过程和配置相对困难复杂。 管理服务相对繁琐。 运行和编译需要很多时间。 它比其他替代品更昂贵。 对于简单的应用程序来说，可能不需要涉及Kubernetes即可满足。 10、简述Kubernetes相关基础概念 Master：Kubernetes集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有etcd存储服务（可选），运行Api Server进程，Controller Manager服务进程及Scheduler服务进程。 Node（worker）：Node（worker）是Kubernetes集群架构中运行Pod的服务节点，是Kubernetes集群操作的单元，用来承载被分配Pod的运行，是Pod运行的宿主机。运行Docker Eninge服务，守护进程kunelet及负载均衡器kube-proxy。 Pod：运行于Node节点上，若干相关容器的组合。Pod内包含的容器运行在同一宿主机上，使用相同的网络命名空间、IP地址和端口，能够通过localhost进行通信。Pod是Kubernetes进行创建、调度和管理的最小单位，它提供了比容器更高层次的抽象，使得部署和管理更加灵活。一个Pod可以包含一个容器或者多个相关容器。 Label：Kubernetes中的Label实质是一系列的Key/Value键值对，其中key与value可自定义。Label可以附加到各种资源对象上，如Node、Pod、Service、RC等。一个资源对象可以定义任意数量的Label，同一个Label也可以被添加到任意数量的资源对象上去。Kubernetes通过Label Selector（标签选择器）查询和筛选资源对象。 Replication Controller：Replication Controller用来管理Pod的副本，保证集群中存在指定数量的Pod副本。集群中副本的数量大于指定数量，则会停止指定数量之外的多余容器数量。反之，则会启动少于指定数量个数的容器，保证数量不变。Replication Controller是实现弹性伸缩、动态扩容和滚动升级的核心。 Deployment：Deployment在内部使用了RS来实现目的，Deployment相当于RC的一次升级，其最大的特色为可以随时获知当前Pod的部署进度。 HPA（Horizontal Pod Autoscaler）：Pod的横向自动扩容，也是Kubernetes的一种资源，通过追踪分析RC控制的所有Pod目标的负载变化情况，来确定是否需要针对性的调整Pod副本数量。 Service：Service定义了Pod的逻辑集合和访问该集合的策略，是真实服务的抽象。Service提供了一个统一的服务访问入口以及服务代理和发现机制，关联多个相同Label的Pod，用户不需要了解后台Pod是如何运行。 Volume：Volume是Pod中能够被多个容器访问的共享目录，Kubernetes中的Volume是定义在Pod上，可以被一个或多个Pod中的容器挂载到某个目录下。 Namespace：Namespace用于实现多租户的资源隔离，可将集群内部的资源对象分配到不同的Namespace中，形成逻辑上的不同项目、小组或用户组，便于不同的Namespace在共享使用整个集群的资源的同时还能被分别管理。 11、简述Kubernetes集群相关组件Kubernetes Master控制组件，调度管理整个系统（集群），包含如下组件： Kubernetes API Server：作为Kubernetes系统的入口，其封装了核心对象的增删改查操作，以RESTful API接口方式提供给外部客户和内部组件调用，集群内各个功能模块之间数据交互和通信的中心枢纽。 Kubernetes Scheduler：为新建立的Pod进行节点（Node）选择（即分配机器），负责集群的资源调度。 Kubernetes Controller：负责执行各种控制器，目前已经提供了很多控制器来保证Kubernetes的正常运行。 Replication Controller：管理维护Replication Controller，关联Replication Controller和Pod，保证Replication Controller定义的副本数量与实际运行Pod数量一致。 Node Controller：管理维护Node，定期检查Node的健康状态，标识出（失效|未失效）的Node节点。 Namespace Controller：管理维护Namespace，定期清理无效的Namespace，包括Namesapce下的API对象，比如Pod、Service等。 Service Controller：管理维护Service，提供负载以及服务代理。 EndPoints Controller：管理维护Endpoints，关联Service和Pod，创建Endpoints为Service的后端，当Pod发生变化时，实时更新Endpoints。 Service Account Controller：管理维护Service Account，为每个Namespace创建默认的Service Account，同时为Service Account创建Service Account Secret。 Persistent Volume Controller：管理维护Persistent Volume和Persistent Volume Claim，为新的Persistent Volume Claim分配Persistent Volume进行绑定，为释放的Persistent Volume执行清理回收。 Daemon Set Controller：管理维护Daemon Set，负责创建Daemon Pod，保证指定的Node上正常的运行Daemon Pod。 Deployment Controller：管理维护Deployment，关联Deployment和Replication Controller，保证运行指定数量的Pod。当Deployment更新时，控制实现Replication Controller和Pod的更新。 Job Controller：管理维护Job，为Jod创建一次性任务Pod，保证完成Job指定完成的任务数目 Pod Autoscaler Controller：实现Pod的自动伸缩，定时获取监控数据，进行策略匹配，当满足条件时执行Pod的伸缩动作。 12、简述Kubernetes RC的机制Replication Controller用来管理Pod的副本，保证集群中存在指定数量的Pod副本。当定义了RC并提交至Kubernetes集群中之后，Master节点上的Controller Manager组件获悉，并同时巡检系统中当前存活的目标Pod，并确保目标Pod实例的数量刚好等于此RC的期望值，若存在过多的Pod副本在运行，系统会停止一些Pod，反之则自动创建一些Pod。 13、简述Kubernetes Replica Set和Replication Controller之间有什么区别Replica Set和Replication Controller类似，都是确保在任何给定时间运行指定数量的Pod副本。不同之处在于RS使用基于集合的选择器，而Replication Controller使用基于权限的选择器。 14、简述kube-proxy的作用kube-proxy运行在所有节点上，它监听apiserver中service和endpoint的变化情况，创建路由规则以提供服务IP和负载均衡功能。简单理解此进程是Service的透明代理兼负载均衡器，其核心功能是将到某个Service的访问请求转发到后端的多个Pod实例上。 15、简述kube-proxy iptables的原理Kubernetes从1.2版本开始，将iptables作为kube-proxy的默认模式。iptables模式下的kube-proxy不再起到Proxy的作用，其核心功能：通过API Server的Watch接口实时跟踪Service与Endpoint的变更信息，并更新对应的iptables规则，Client的请求流量则通过iptables的NAT机制“直接路由”到目标Pod。 16、简述kube-proxy ipvs的原理IPVS在Kubernetes1.11中升级为GA稳定版。IPVS则专门用于高性能负载均衡，并使用更高效的数据结构（Hash表），允许几乎无限的规模扩张，因此被kube-proxy采纳为最新模式。 在IPVS模式下，使用iptables的扩展ipset，而不是直接调用iptables来生成规则链。iptables规则链是一个线性的数据结构，ipset则引入了带索引的数据结构，因此当规则很多时，也可以很高效地查找和匹配。 可以将ipset简单理解为一个IP（段）的集合，这个集合的内容可以是IP地址、IP网段、端口等，iptables可以直接添加规则对这个“可变的集合”进行操作，这样做的好处在于可以大大减少iptables规则的数量，从而减少性能损耗。 17、简述kube-proxy ipvs和iptables的异同iptables与IPVS都是基于Netfilter实现的，但因为定位不同，二者有着本质的差别：iptables是为防火墙而设计的；IPVS则专门用于高性能负载均衡，并使用更高效的数据结构（Hash表），允许几乎无限的规模扩张。 与iptables相比，IPVS拥有以下明显优势： 为大型集群提供了更好的可扩展性和性能； 支持比iptables更复杂的复制均衡算法（最小负载、最少连接、加权等）； 支持服务器健康检查和连接重试等功能； 可以动态修改ipset的集合，即使iptables的规则正在使用这个集合。 18、简述Kubernetes中什么是静态Pod静态Pod是由kubelet进行管理的仅存在于特定Node的Pod上，他们不能通过API Server进行管理，无法与ReplicationController、Deployment或者DaemonSet进行关联，并且kubelet无法对他们进行健康检查。静态Pod总是由kubelet进行创建，并且总是在kubelet所在的Node上运行。 19、简述Kubernetes中Pod可能位于的状态 Pending：API Server已经创建该Pod，且Pod内还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程。 Running：Pod内所有容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态。 Succeeded：Pod内所有容器均成功执行退出，且不会重启。 Failed：Pod内所有容器均已退出，但至少有一个容器退出为失败状态。 Unknown：由于某种原因无法获取该Pod状态，可能由于网络通信不畅导致。 20、简述Kubernetes创建一个Pod的主要流程？Kubernetes中创建一个Pod涉及多个组件之间联动，主要流程如下： 客户端提交Pod的配置信息（可以是yaml文件定义的信息）到kube-apiserver。 Apiserver收到指令后，通知给controller-manager创建一个资源对象。 Controller-manager通过api-server将Pod的配置信息存储到etcd数据中心中。 Kube-scheduler检测到Pod信息会开始调度预选，会先过滤掉不符合Pod资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行Pod的节点，然后将Pod的资源配置单发送到Node节点上的kubelet组件上。 Kubelet根据scheduler发来的资源配置单运行Pod，运行成功后，将Pod的运行信息返回给scheduler，scheduler将返回的Pod运行状况的信息存储到etcd数据中心。 21、简述Kubernetes中Pod的重启策略Pod重启策略（RestartPolicy）应用于Pod内的所有容器，并且仅在Pod所处的Node上由kubelet进行判断和重启操作。当某个容器异常退出或者健康检查失败时，kubelet将根据RestartPolicy的设置来进行相应操作。 Pod的重启策略包括Always、OnFailure和Never，默认值为Always。 Always：当容器失效时，由kubelet自动重启该容器； OnFailure：当容器终止运行且退出码不为0时，由kubelet自动重启该容器； Never：不论容器运行状态如何，kubelet都不会重启该容器。 同时Pod的重启策略与控制方式关联，当前可用于管理Pod的控制器包括ReplicationController、Job、DaemonSet及直接管理kubelet管理（静态Pod）。 不同控制器的重启策略限制如下： RC和DaemonSet：必须设置为Always，需要保证该容器持续运行； Job：OnFailure或Never，确保容器执行完成后不再重启； kubelet：在Pod失效时重启，不论将RestartPolicy设置为何值，也不会对Pod进行健康检查。 22、简述Kubernetes中Pod的健康检查方式对Pod的健康检查可以通过两类探针来检查：LivenessProbe和ReadinessProbe。 LivenessProbe探针：用于判断容器是否存活（running状态），如果LivenessProbe探针探测到容器不健康，则kubelet将杀掉该容器，并根据容器的重启策略做相应处理。若一个容器不包含LivenessProbe探针，kubelet认为该容器的LivenessProbe探针返回值用于是“Success”。 ReadineeProbe探针：用于判断容器是否启动完成（ready状态）。如果ReadinessProbe探针探测到失败，则Pod的状态将被修改。Endpoint Controller将从Service的Endpoint中删除包含该容器所在Pod的Eenpoint。 startupProbe探针：启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉。 23、简述Kubernetes Pod的LivenessProbe探针的常见方式kubelet定期执行LivenessProbe探针来诊断容器的健康状态，通常有以下三种方式： ExecAction：在容器内执行一个命令，若返回码为0，则表明容器健康。 TCPSocketAction：通过容器的IP地址和端口号执行TCP检查，若能建立TCP连接，则表明容器健康。 HTTPGetAction：通过容器的IP地址、端口号及路径调用HTTP Get方法，若响应的状态码大于等于200且小于400，则表明容器健康。 24、简述Kubernetes Pod的常见调度方式Kubernetes中，Pod通常是容器的载体，主要有如下常见调度方式： Deployment或RC：该调度策略主要功能就是自动部署一个容器应用的多份副本，以及持续监控副本的数量，在集群内始终维持用户指定的副本数量。 NodeSelector：定向调度，当需要手动指定将Pod调度到特定Node上，可以通过Node的标签（Label）和Pod的nodeSelector属性相匹配。 NodeAffinity亲和性调度：亲和性调度机制极大的扩展了Pod的调度能力，目前有两种节点亲和力表达： requiredDuringSchedulingIgnoredDuringExecution：硬规则，必须满足指定的规则，调度器才可以调度Pod至Node上（类似nodeSelector，语法不同）。 preferredDuringSchedulingIgnoredDuringExecution：软规则，优先调度至满足的Node的节点，但不强求，多个优先级规则还可以设置权重值。 Taints和Tolerations（污点和容忍）： Taint：使Node拒绝特定Pod运行； Toleration：为Pod的属性，表示Pod能容忍（运行）标注了Taint的Node。 25、简述Kubernetes初始化容器（init container）init container的运行方式与应用容器不同，它们必须先于应用容器执行完成，当设置了多个init container时，将按顺序逐个运行，并且只有前一个init container运行成功后才能运行后一个init container。当所有init container都成功运行后，Kubernetes才会初始化Pod的各种信息，并开始创建和运行应用容器。 26、简述Kubernetes deployment升级过程 初始创建Deployment时，系统创建了一个ReplicaSet，并按用户的需求创建了对应数量的Pod副本。 当更新Deployment时，系统创建了一个新的ReplicaSet，并将其副本数量扩展到1，然后将旧ReplicaSet缩减为2。 之后，系统继续按照相同的更新策略对新旧两个ReplicaSet进行逐个调整。 最后，新的ReplicaSet运行了对应个新版本Pod副本，旧的ReplicaSet副本数量则缩减为0。 27、简述Kubernetes deployment升级策略在Deployment的定义中，可以通过spec.strategy指定Pod更新的策略，目前支持两种策略：Recreate（重建）和RollingUpdate（滚动更新），默认值为RollingUpdate。 Recreate：设置spec.strategy.type=Recreate，表示Deployment在更新Pod时，会先杀掉所有正在运行的Pod，然后创建新的Pod。 RollingUpdate：设置spec.strategy.type=RollingUpdate，表示Deployment会以滚动更新的方式来逐个更新Pod。同时，可以通过设置spec.strategy.rollingUpdate下的两个参数（maxUnavailable和maxSurge）来控制滚动更新的过程。 28、简述Kubernetes DaemonSet类型的资源特性DaemonSet资源对象会在每个Kubernetes集群中的节点上运行，并且每个节点只能运行一个Pod，这是它和Deployment资源对象的最大也是唯一的区别。因此，在定义yaml文件中，不支持定义replicas。 它的一般使用场景如下： 在去做每个节点的日志收集工作。 监控每个节点的的运行状态。 29、简述Kubernetes自动扩容机制Kubernetes使用Horizontal Pod Autoscaler（HPA）的控制器实现基于CPU使用率进行自动Pod扩缩容的功能。HPA控制器周期性地监测目标Pod的资源性能指标，并与HPA资源对象中的扩缩容条件进行对比，在满足条件时对Pod副本数量进行调整。 Kubernetes中的某个Metrics Server（Heapster或自定义Metrics Server）持续采集所有Pod副本的指标数据。HPA控制器通过Metrics Server的API（Heapster的API或聚合API）获取这些数据，基于用户定义的扩缩容规则进行计算，得到目标Pod副本数量。 当目标Pod副本数量与当前副本数量不同时，HPA控制器就向Pod的副本控制器（Deployment、RC或ReplicaSet）发起scale操作，调整Pod的副本数量，完成扩缩容操作。 30、简述Kubernetes Service类型通过创建Service，可以为一组具有相同功能的容器应用提供一个统一的入口地址，并且将请求负载分发到后端的各个容器应用上。其主要类型有： ClusterIP：虚拟的服务IP地址，该地址用于Kubernetes集群内部的Pod访问，在Node上kube-proxy通过设置的iptables规则进行转发； NodePort：使用宿主机的端口，使能够访问各Node的外部客户端通过Node的IP地址和端口号就能访问服务； LoadBalancer：使用外接负载均衡器完成到服务的负载分发，需要在spec.status.loadBalancer字段指定外部负载均衡器的IP地址，通常用于公有云。 31、简述Kubernetes Service分发后端的策略Service负载分发的策略有：RoundRobin和SessionAffinity RoundRobin：默认为轮询模式，即轮询将请求转发到后端的各个Pod上。 SessionAffinity：基于客户端IP地址进行会话保持的模式，即第1次将某个客户端发起的请求转发到后端的某个Pod上，之后从相同的客户端发起的请求都将被转发到后端相同的Pod上。 32、简述Kubernetes Headless Service在某些应用场景中，若需要人为指定负载均衡器，不使用Service提供的默认负载均衡的功能，或者应用程序希望知道属于同组服务的其他实例。Kubernetes提供了Headless Service来实现这种功能，即不为Service设置ClusterIP（入口IP地址），仅通过Label Selector将后端的Pod列表返回给调用的客户端。 33、简述Kubernetes外部如何访问集群内的服务对于Kubernetes，集群外的客户端默认情况，无法通过Pod的IP地址或者Service的虚拟IP地址：虚拟端口号进行访问。通常可以通过以下方式进行访问Kubernetes集群内的服务： 映射Pod到物理机：将Pod端口号映射到宿主机，即在Pod中采用hostPort方式，以使客户端应用能够通过物理机访问容器应用。 映射Service到物理机：将Service端口号映射到宿主机，即在Service中采用nodePort方式，以使客户端应用能够通过物理机访问容器应用。 映射Sercie到LoadBalancer：通过设置LoadBalancer映射到云服务商提供的LoadBalancer地址。这种用法仅用于在公有云服务提供商的云平台上设置Service的场景。 34、简述Kubernetes ingressKubernetes的Ingress资源对象，用于将不同URL的访问请求转发到后端不同的Service，以实现HTTP层的业务路由机制。 Kubernetes使用了Ingress策略和Ingress Controller，两者结合并实现了一个完整的Ingress负载均衡器。使用Ingress进行负载分发时，Ingress Controller基于Ingress规则将客户端请求直接转发到Service对应的后端Endpoint（Pod）上，从而跳过kube-proxy的转发功能，kube-proxy不再起作用，全过程为：ingress controller + ingress 规则 —-&gt; services。 同时当Ingress Controller提供的是对外服务，则实际上实现的是边缘路由器的功能。 35、简述Kubernetes镜像的下载策略Kubernetes的镜像下载策略有三种：Always、Never、IFNotPresent。 Always：镜像标签为latest时，总是从指定的仓库中获取镜像。 Never：禁止从仓库中下载镜像，也就是说只能使用本地镜像。 IfNotPresent：仅当本地没有对应镜像时，才从目标仓库中下载。默认的镜像下载策略是：当镜像标签是latest时，默认策略是Always；当镜像标签是自定义时（也就是标签不是latest），那么默认策略是IfNotPresent。 36、简述Kubernetes的负载均衡器负载均衡器是暴露服务的最常见和标准方式之一。 根据工作环境使用两种类型的负载均衡器，即内部负载均衡器或外部负载均衡器。内部负载均衡器自动平衡负载并使用所需配置分配容器，而外部负载均衡器将流量从外部负载引导至后端容器。 37、简述Kubernetes各模块如何与API Server通信Kubernetes API Server作为集群的核心，负责集群各功能模块之间的通信。集群内的各个功能模块通过API Server将信息存入etcd，当需要获取和操作这些数据时，则通过API Server提供的REST接口（用GET、LIST或WATCH方法）来实现，从而实现各模块之间的信息交互。 如kubelet进程与API Server的交互：每个Node上的kubelet每隔一个时间周期，就会调用一次API Server的REST接口报告自身状态，API Server在接收到这些信息后，会将节点状态信息更新到etcd中。 如kube-controller-manager进程与API Server的交互：kube-controller-manager中的Node Controller模块通过API Server提供的Watch接口实时监控Node的信息，并做相应处理。 如kube-scheduler进程与API Server的交互：Scheduler通过API Server的Watch接口监听到新建Pod副本的信息后，会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑，在调度成功后将Pod绑定到目标节点上。 38、简述Kubernetes Scheduler作用及实现原理Kubernetes Scheduler是负责Pod调度的重要功能模块，Kubernetes Scheduler在整个系统中承担了“承上启下”的重要功能，“承上”是指它负责接收Controller Manager创建的新Pod，为其调度至目标Node；“启下”是指调度完成后，目标Node上的kubelet服务进程接管后继工作，负责Pod接下来生命周期。 Kubernetes Scheduler的作用是将待调度的Pod（API新创建的Pod、Controller Manager为补足副本而创建的Pod等）按照特定的调度算法和调度策略绑定（Binding）到集群中某个合适的Node上，并将绑定信息写入etcd中。 在整个调度过程中涉及三个对象，分别是待调度Pod列表、可用Node列表，以及调度算法和策略。 Kubernetes Scheduler通过调度算法调度为待调度Pod列表中的每个Pod从Node列表中选择一个最适合的Node来实现Pod的调度。随后，目标节点上的kubelet通过API Server监听到Kubernetes Scheduler产生的Pod绑定事件，然后获取对应的Pod清单，下载Image镜像并启动容器。 39、简述Kubernetes Scheduler使用哪两种算法将Pod绑定到worker节点Kubernetes Scheduler根据如下两种调度算法将 Pod 绑定到最合适的工作节点： 预选（Predicates）：输入是所有节点，输出是满足预选条件的节点。kube-scheduler根据预选策略过滤掉不满足策略的Nodes。如果某节点的资源不足或者不满足预选策略的条件则无法通过预选。如“Node的label必须与Pod的Selector一致”。 优选（Priorities）：输入是预选阶段筛选出的节点，优选会根据优先策略为通过预选的Nodes进行打分排名，选择得分最高的Node。例如，资源越富裕、负载越小的Node可能具有越高的排名。 40、简述Kubernetes kubelet的作用在Kubernetes集群中，在每个Node（又称Worker）上都会启动一个kubelet服务进程。该进程用于处理Master下发到本节点的任务，管理Pod及Pod中的容器。每个kubelet进程都会在API Server上注册节点自身的信息，定期向Master汇报节点资源的使用情况，并通过cAdvisor监控容器和节点资源。 41、简述Kubernetes kubelet监控Worker节点资源是使用什么组件来实现的kubelet使用cAdvisor对worker节点资源进行监控。在Kubernetes系统中，cAdvisor已被默认集成到kubelet组件内，当kubelet服务启动时，它会自动启动cAdvisor服务，然后cAdvisor会实时采集所在节点的性能指标及在节点上运行的容器的性能指标。 42、简述Kubernetes如何保证集群的安全性Kubernetes通过一系列机制来实现集群的安全控制，主要有如下不同的维度： 基础设施方面：保证容器与其所在宿主机的隔离； 权限方面： 最小权限原则：合理限制所有组件的权限，确保组件只执行它被授权的行为，通过限制单个组件的能力来限制它的权限范围。 用户权限：划分普通用户和管理员的角色。 集群方面： API Server的认证授权：Kubernetes集群中所有资源的访问和变更都是通过Kubernetes API Server来实现的，因此需要建议采用更安全的HTTPS或Token来识别和认证客户端身份（Authentication），以及随后访问权限的授权（Authorization）环节。 API Server的授权管理：通过授权策略来决定一个API调用是否合法。对合法用户进行授权并且随后在用户访问时进行鉴权，建议采用更安全的RBAC方式来提升集群安全授权。 敏感数据引入Secret机制：对于集群敏感数据建议使用Secret方式进行保护。 AdmissionControl（准入机制）：对kubernetes api的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。 43、简述Kubernetes准入机制在对集群进行请求时，每个准入控制代码都按照一定顺序执行。如果有一个准入控制拒绝了此次请求，那么整个请求的结果将会立即返回，并提示用户相应的error信息。 准入控制（AdmissionControl）准入控制本质上为一段准入代码，在对kubernetes api的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。常用组件（控制代码）如下： AlwaysAdmit：允许所有请求 AlwaysDeny：禁止所有请求，多用于测试环境。 ServiceAccount：它将serviceAccounts实现了自动化，它会辅助serviceAccount做一些事情，比如如果pod没有serviceAccount属性，它会自动添加一个default，并确保pod的serviceAccount始终存在。 LimitRanger：观察所有的请求，确保没有违反已经定义好的约束条件，这些条件定义在namespace中LimitRange对象中。 NamespaceExists：观察所有的请求，如果请求尝试创建一个不存在的namespace，则这个请求被拒绝。 44、简述Kubernetes RBAC及其特点（优势）RBAC是基于角色的访问控制，是一种基于个人用户的角色来管理对计算机或网络资源的访问的方法。 相对于其他授权模式，RBAC具有如下优势： 对集群中的资源和非资源权限均有完整的覆盖。 整个RBAC完全由几个API对象完成， 同其他API对象一样， 可以用kubectl或API进行操作。 可以在运行时进行调整，无须重新启动API Server。 45、简述Kubernetes Secret作用Secret对象，主要作用是保管私密数据，比如密码、OAuth Tokens、SSH Keys等信息。将这些私密信息放在Secret对象中比直接放在Pod或Docker Image中更安全，也更便于使用和分发。 46、简述Kubernetes Secret有哪些使用方式创建完secret之后，可通过如下三种方式使用： 在创建Pod时，通过为Pod指定Service Account来自动使用该Secret。 通过挂载该Secret到Pod来使用它。 在Docker镜像下载时使用，通过指定Pod的spc.ImagePullSecrets来引用它。 47、简述Kubernetes PodSecurityPolicy机制Kubernetes PodSecurityPolicy是为了更精细地控制Pod对资源的使用方式以及提升安全策略。在开启PodSecurityPolicy准入控制器后，Kubernetes默认不允许创建任何Pod，需要创建PodSecurityPolicy策略和相应的RBAC授权策略（Authorizing Policies），Pod才能创建成功。 48、简述Kubernetes PodSecurityPolicy机制能实现哪些安全策略在PodSecurityPolicy对象中可以设置不同字段来控制Pod运行时的各种安全策略，常见的有： 特权模式：privileged是否允许Pod以特权模式运行。 宿主机资源：控制Pod对宿主机资源的控制，如hostPID：是否允许Pod共享宿主机的进程空间。 用户和组：设置运行容器的用户ID（范围）或组（范围）。 提升权限：AllowPrivilegeEscalation：设置容器内的子进程是否可以提升权限，通常在设置非root用户（MustRunAsNonRoot）时进行设置。 SELinux：进行SELinux的相关配置。 49、简述Kubernetes网络模型Kubernetes网络模型中每个Pod都拥有一个独立的IP地址，并假定所有Pod都在一个可以直接连通的、扁平的网络空间中。所以不管它们是否运行在同一个Node（宿主机）中，都要求它们可以直接通过对方的IP进行访问。设计这个原则的原因是，用户不需要额外考虑如何建立Pod之间的连接，也不需要考虑如何将容器端口映射到主机端口等问题。 同时为每个Pod都设置一个IP地址的模型使得同一个Pod内的不同容器会共享同一个网络命名空间，也就是同一个Linux网络协议栈。这就意味着同一个Pod内的容器可以通过localhost来连接对方的端口。 在Kubernetes的集群里，IP是以Pod为单位进行分配的。一个Pod内部的所有容器共享一个网络堆栈（相当于一个网络命名空间，它们的IP地址、网络设备、配置等都是共享的）。 50、简述Kubernetes CNI模型CNI提供了一种应用容器的插件化网络解决方案，定义对容器网络进行操作和配置的规范，通过插件的形式对CNI接口进行实现。CNI仅关注在创建容器时分配网络资源，和在销毁容器时删除网络资源。在CNI模型中只涉及两个概念：容器和网络。 容器（Container）：是拥有独立Linux网络命名空间的环境，例如使用Docker或rkt创建的容器。容器需要拥有自己的Linux网络命名空间，这是加入网络的必要条件。 网络（Network）：表示可以互连的一组实体，这些实体拥有各自独立、唯一的IP地址，可以是容器、物理机或者其他网络设备（比如路由器）等。 对容器网络的设置和操作都通过插件（Plugin）进行具体实现，CNI插件包括两种类型：CNI Plugin和IPAM（IP Address Management）Plugin。CNI Plugin负责为容器配置网络资源，IPAM Plugin负责对容器的IP地址进行分配和管理。IPAM Plugin作为CNI Plugin的一部分，与CNI Plugin协同工作。 51、简述Kubernetes网络策略为实现细粒度的容器间网络访问隔离策略，Kubernetes引入Network Policy。 Network Policy的主要功能是对Pod间的网络通信进行限制和准入控制，设置允许访问或禁止访问的客户端Pod列表。Network Policy定义网络策略，配合策略控制器（Policy Controller）进行策略的实现。 52、简述Kubernetes网络策略原理Network Policy的工作原理主要为：policy controller需要实现一个API Listener，监听用户设置的Network Policy定义，并将网络访问规则通过各Node的Agent进行实际设置（Agent则需要通过CNI网络插件实现）。 53、简述Kubernetes中flannel的作用Flannel可以用于Kubernetes底层网络的实现，主要作用有： 它能协助Kubernetes，给每一个Node上的Docker容器都分配互相不冲突的IP地址。 它能在这些IP地址之间建立一个覆盖网络（Overlay Network），通过这个覆盖网络，将数据包原封不动地传递到目标容器内。 54、简述Kubernetes Calico网络组件实现原理Calico是一个基于BGP的纯三层的网络方案，与OpenStack、Kubernetes、AWS、GCE等云平台都能够良好地集成。 Calico在每个计算节点都利用Linux Kernel实现了一个高效的vRouter来负责数据转发。每个vRouter都通过BGP协议把在本节点上运行的容器的路由信息向整个Calico网络广播，并自动设置到达其他节点的路由转发规则。 Calico保证所有容器之间的数据流量都是通过IP路由的方式完成互联互通的。Calico节点组网时可以直接利用数据中心的网络结构（L2或者L3），不需要额外的NAT、隧道或者Overlay Network，没有额外的封包解包，能够节约CPU运算，提高网络效率。 55、简述Kubernetes共享存储的作用Kubernetes对于有状态的容器应用或者对数据需要持久化的应用，因此需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。因此需要使用共享存储。 56、简述Kubernetes数据持久化的方式有哪些Kubernetes通过数据持久化来持久化保存重要数据，常见的方式有： EmptyDir（空目录）：没有指定要挂载宿主机上的某个目录，直接由Pod内保部映射到宿主机上。类似于docker中的manager volume。 场景： 只需要临时将数据保存在磁盘上，比如在合并/排序算法中； 作为两个容器的共享存储。 特性： 同个pod里面的不同容器，共享同一个持久化目录，当pod节点删除时，volume的数据也会被删除。 emptyDir的数据持久化的生命周期和使用的pod一致，一般是作为临时存储使用。 Hostpath：将宿主机上已存在的目录或文件挂载到容器内部。类似于docker中的bind mount挂载方式。 特性：增加了Pod与节点之间的耦合。 PersistentVolume（简称PV）：如基于NFS服务的PV，也可以基于GFS的PV。它的作用是统一数据持久化目录，方便管理。 57、简述Kubernetes PV和PVCPV是对底层网络共享存储的抽象，将共享存储定义为一种“资源”。 PVC则是用户对存储资源的一个“申请”。 58、简述Kubernetes PV生命周期内的阶段某个PV在生命周期中可能处于以下4个阶段（Phaes）之一。 Available：可用状态，还未与某个PVC绑定。 Bound：已与某个PVC绑定。 Released：绑定的PVC已经删除，资源已释放，但没有被集群回收。 Failed：自动资源回收失败。 59、简述Kubernetes所支持的存储供应模式Kubernetes支持两种资源的存储供应模式：静态模式（Static）和动态模式（Dynamic）。 静态模式：集群管理员手工创建许多PV，在定义PV时需要将后端存储的特性进行设置。 动态模式：集群管理员无须手工创建PV，而是通过StorageClass的设置对后端存储进行描述，标记为某种类型。此时要求PVC对存储的类型进行声明，系统将自动完成PV的创建及与PVC的绑定。 60、简述Kubernetes CSI模型Kubernetes CSI是Kubernetes推出与容器对接的存储接口标准，存储提供方只需要基于标准接口进行存储插件的实现，就能使用Kubernetes的原生存储机制为容器提供存储服务。CSI使得存储提供方的代码能和Kubernetes代码彻底解耦，部署也与Kubernetes核心组件分离，显然，存储插件的开发由提供方自行维护，就能为Kubernetes用户提供更多的存储功能，也更加安全可靠。 CSI包括CSI Controller和CSI Node： CSI Controller的主要功能是提供存储服务视角对存储资源和存储卷进行管理和操作。 CSI Node的主要功能是对主机（Node）上的Volume进行管理和操作。 61、简述Kubernetes Worker节点加入集群的过程通常需要对Worker节点进行扩容，从而将应用系统进行水平扩展。主要过程如下： 在该Node上安装Docker、kubelet和kube-proxy服务； 然后配置kubelet和kubeproxy的启动参数，将Master URL指定为当前Kubernetes集群Master的地址，最后启动这些服务； 通过kubelet默认的自动注册机制，新的Worker将会自动加入现有的Kubernetes集群中； Kubernetes Master在接受了新Worker的注册之后，会自动将其纳入当前集群的调度范围。 62、简述Kubernetes Pod如何实现对节点的资源控制Kubernetes集群里的节点提供的资源主要是计算资源，计算资源是可计量的能被申请、分配和使用的基础资源。当前Kubernetes集群中的计算资源主要包括CPU、GPU及Memory。CPU与Memory是被Pod使用的，因此在配置Pod时可以通过参数CPU Request及Memory Request为其中的每个容器指定所需使用的CPU与Memory量，Kubernetes会根据Request的值去查找有足够资源的Node来调度此Pod。 通常，一个程序所使用的CPU与Memory是一个动态的量，确切地说，是一个范围，跟它的负载密切相关：负载增加时，CPU和Memory的使用量也会增加。 63、简述Kubernetes Requests和Limits如何影响Pod的调度当一个Pod创建成功时，Kubernetes调度器（Scheduler）会为该Pod选择一个节点来执行。对于每种计算资源（CPU和Memory）而言，每个节点都有一个能用于运行Pod的最大容量值。调度器在调度时，首先要确保调度后该节点上所有Pod的CPU和内存的Requests总和，不超过该节点能提供给Pod使用的CPU和Memory的最大容量值。 64、简述Kubernetes Metric Service在Kubernetes从1.10版本后采用Metrics Server作为默认的性能数据采集和监控，主要用于提供核心指标（Core Metrics），包括Node、Pod的CPU和内存使用指标。 对其他自定义指标（Custom Metrics）的监控则由Prometheus等组件来完成。 65、简述Kubernetes中，如何使用EFK实现日志的统一管理在Kubernetes集群环境中，通常一个完整的应用或服务涉及组件过多，建议对日志系统进行集中化管理，通常采用EFK实现。 EFK是 Elasticsearch、Fluentd 和 Kibana 的组合，其各组件功能如下： Elasticsearch：是一个搜索引擎，负责存储日志并提供查询接口； Fluentd：负责从 Kubernetes 搜集日志，每个Node节点上面的Fluentd监控并收集该节点上面的系统日志，并将处理过后的日志信息发送给Elasticsearch； Kibana：提供了一个 Web GUI，用户可以浏览和搜索存储在 Elasticsearch 中的日志。 通过在每台Node上部署一个以DaemonSet方式运行的Fluentd来收集每台Node上的日志。Fluentd将Docker日志目录/var/lib/docker/containers和/var/log目录挂载到Pod中，然后Pod会在Node节点的/var/log/pods目录中创建新的目录，可以区别不同的容器日志输出，该目录下有一个日志文件链接到/var/lib/docker/contianers目录下的容器日志输出。 66、简述Kubernetes如何进行优雅的节点关机维护由于Kubernetes节点运行大量Pod，因此在进行关机维护之前，建议先使用kubectl drain将该节点的Pod进行驱逐，然后进行关机维护。 67、简述Kubernetes集群联邦Kubernetes集群联邦可以将多个Kubernetes集群作为一个集群进行管理。因此，可以在一个数据中心/云中创建多个Kubernetes集群，并使用集群联邦在一个地方控制/管理所有集群。 68、简述Helm及其优势Helm是Kubernetes的软件包管理工具。类似Ubuntu中使用的APT、CentOS中使用的yum 或者Python中的 pip 一样。 Helm能够将一组Kubernetes资源打包统一管理, 是查找、共享和使用为Kubernetes构建的软件的最佳方式。 Helm中通常每个包称为一个Chart，一个Chart是一个目录（一般情况下会将目录进行打包压缩，形成name-version.tgz格式的单一文件，方便传输和存储）。 在Kubernetes中部署一个可以使用的应用，需要涉及到很多的 Kubernetes 资源的共同协作。使用Helm则具有如下优势： 统一管理、配置和更新这些分散的Kubernetes的应用资源文件； 分发和复用一套应用模板； 将应用的一系列资源当做一个软件包管理。 对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。 对于使用者而言，使用Helm后不用需要编写复杂的应用部署文件，可以以简单的方式在Kubernetes上查找、安装、升级、回滚、卸载应用程序。 69、k8s是什么？请说出你的了解？答：Kubenetes是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。 K8S是Google公司推出的，它来源于由Google公司内部使用了15年的Borg系统，集结了Borg的精华。 70、K8s架构的组成是什么？答：和大多数分布式系统一样，K8S集群至少需要一个主节点（Master）和多个计算节点（Node）。 主节点主要用于暴露API，调度部署和节点的管理； 计算节点运行一个容器运行环境，一般是docker环境（类似docker环境的还有rkt），同时运行一个K8s的代理（kubelet）用于和master通信。计算节点也会运行一些额外的组件，像记录日志，节点监控，服务发现等等。计算节点是k8s集群中真正工作的节点。 K8S架构细分：1、Master节点（默认不参加实际工作）： Kubectl：客户端命令行工具，作为整个K8s集群的操作入口； Api Server：在K8s架构中承担的是“桥梁”的角色，作为资源操作的唯一入口，它提供了认证、授权、访问控制、API注册和发现等机制。客户端与k8s群集及K8s内部组件的通信，都要通过Api Server这个组件； Controller-manager：负责维护群集的状态，比如故障检测、自动扩展、滚动更新等； Scheduler：负责资源的调度，按照预定的调度策略将pod调度到相应的node节点上； Etcd：担任数据中心的角色，保存了整个群集的状态； 2、Node节点： Kubelet：负责维护容器的生命周期，同时也负责Volume和网络的管理，一般运行在所有的节点，是Node节点的代理，当Scheduler确定某个node上运行pod之后，会将pod的具体信息（image，volume）等发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向master返回运行状态。（自动修复功能：如果某个节点中的容器宕机，它会尝试重启该容器，若重启无效，则会将该pod杀死，然后重新创建一个容器）； Kube-proxy：Service在逻辑上代表了后端的多个pod。负责为Service提供cluster内部的服务发现和负载均衡（外界通过Service访问pod提供的服务时，Service接收到的请求后就是通过kube-proxy来转发到pod上的）； container-runtime：是负责管理运行容器的软件，比如docker Pod：是k8s集群里面最小的单位。每个pod里边可以运行一个或多个container（容器），如果一个pod中有两个container，那么container的USR（用户）、MNT（挂载点）、PID（进程号）是相互隔离的，UTS（主机名和域名）、IPC（消息队列）、NET（网络栈）是相互共享的。我比较喜欢把pod来当做豌豆夹，而豌豆就是pod中的container； 71、容器和主机部署应用的区别是什么？答：容器的中心思想就是秒级启动；一次封装、到处运行；这是主机部署应用无法达到的效果，但同时也更应该注重容器的数据持久化问题。 另外，容器部署可以将各个服务进行隔离，互不影响，这也是容器的另一个核心概念。 72、请你说一下kubenetes针对pod资源对象的健康监测机制？答：K8s中对于pod资源对象的健康状态检测，提供了三类probe（探针）来执行对pod的健康监测： 1） livenessProbe探针 可以根据用户自定义规则来判定pod是否健康，如果livenessProbe探针探测到容器不健康，则kubelet会根据其重启策略来决定是否重启，如果一个容器不包含livenessProbe探针，则kubelet会认为容器的livenessProbe探针的返回值永远成功。 2） ReadinessProbe探针 同样是可以根据用户自定义规则来判断pod是否健康，如果探测失败，控制器会将此pod从对应service的endpoint列表中移除，从此不再将任何请求调度到此Pod上，直到下次探测成功。 3） startupProbe探针 启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉，这个问题也可以换另一种方式解决，就是定义上面两类探针机制时，初始化时间定义的长一些即可。 每种探测方法能支持以下几个相同的检查参数，用于设置控制检查时间： initialDelaySeconds：初始第一次探测间隔，用于应用启动的时间，防止应用还没启动而健康检查失败 periodSeconds：检查间隔，多久执行probe检查，默认为10s； timeoutSeconds：检查超时时长，探测应用timeout后为失败； successThreshold：成功探测阈值，表示探测多少次为健康正常，默认探测1次。 上面两种探针都支持以下三种探测方法： 1）Exec：通过执行命令的方式来检查服务是否正常，比如使用cat命令查看pod中的某个重要配置文件是否存在，若存在，则表示pod健康。反之异常。 Exec探测方式的yaml文件语法如下： 123456789101112131415spec: containers: - name: liveness image: k8s.gcr.io/busybox args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600 livenessProbe: #选择livenessProbe的探测机制 exec: #执行以下命令 command: - cat - /tmp/healthy initialDelaySeconds: 5 #在容器运行五秒后开始探测 periodSeconds: 5 #每次探测的时间间隔为5秒 在上面的配置文件中，探测机制为在容器运行5秒后，每隔五秒探测一次，如果cat命令返回的值为“0”，则表示健康，如果为非0，则表示异常。 2）Httpget：通过发送http/htps请求检查服务是否正常，返回的状态码为200-399则表示容器健康（注http get类似于命令curl -I）。 Httpget探测方式的yaml文件语法如下： 1234567891011spec: containers: - name: liveness image: k8s.gcr.io/liveness livenessProbe: #采用livenessProbe机制探测 httpGet: #采用httpget的方式 scheme:HTTP #指定协议，也支持https path: /healthz #检测是否可以访问到网页根目录下的healthz网页文件 port: 8080 #监听端口是8080 initialDelaySeconds: 3 #容器运行3秒后开始探测 periodSeconds: 3 #探测频率为3秒 上述配置文件中，探测方式为项容器发送HTTP GET请求，请求的是8080端口下的healthz文件，返回任何大于或等于200且小于400的状态码表示成功。任何其他代码表示异常。 3）tcpSocket：通过容器的IP和Port执行TCP检查，如果能够建立TCP连接，则表明容器健康，这种方式与HTTPget的探测机制有些类似，tcpsocket健康检查适用于TCP业务。 tcpSocket探测方式的yaml文件语法如下： 1234567891011121314151617spec: containers: - name: goproxy image: k8s.gcr.io/goproxy:0.1 ports:- containerPort: 8080#这里两种探测机制都用上了，都是为了和容器的8080端口建立TCP连接 readinessProbe: tcpSocket: port: 8080 initialDelaySeconds: 5 periodSeconds: 10 livenessProbe: tcpSocket: port: 8080 initialDelaySeconds: 15 periodSeconds: 20 在上述的yaml配置文件中，两类探针都使用了，在容器启动5秒后，kubelet将发送第一个readinessProbe探针，这将连接容器的8080端口，如果探测成功，则该pod为健康，十秒后，kubelet将进行第二次连接。 除了readinessProbe探针外，在容器启动15秒后，kubelet将发送第一个livenessProbe探针，仍然尝试连接容器的8080端口，如果连接失败，则重启容器。 探针探测的结果无外乎以下三者之一： Success：Container通过了检查； Failure：Container没有通过检查； Unknown：没有执行检查，因此不采取任何措施（通常是我们没有定义探针检测，默认为成功）。 若觉得上面还不够透彻，可以移步其官网文档： https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/ 73、如何控制滚动更新过程？答：可以通过下面的命令查看到更新时可以控制的参数： 1[root@master yaml]# kubectl explain deploy.spec.strategy.rollingUpdate maxSurge： 此参数控制滚动更新过程，副本总数超过预期pod数量的上限。可以是百分比，也可以是具体的值。默认为1。 （上述参数的作用就是在更新过程中，值若为3，那么不管三七二一，先运行三个pod，用于替换旧的pod，以此类推） maxUnavailable：此参数控制滚动更新过程中，不可用的Pod的数量。 （这个值和上面的值没有任何关系，举个例子：我有十个pod，但是在更新的过程中，我允许这十个pod中最多有三个不可用，那么就将这个参数的值设置为3，在更新的过程中，只要不可用的pod数量小于或等于3，那么更新过程就不会停止）。 74、K8s中镜像的下载策略是什么？答：可通过命令“kubectl explain pod.spec.containers”来查看imagePullPolicy这行的解释。 K8s的镜像下载策略有三种：Always、Never、IFNotPresent； Always：镜像标签为latest时，总是从指定的仓库中获取镜像； Never：禁止从仓库中下载镜像，也就是说只能使用本地镜像； IfNotPresent：仅当本地没有对应镜像时，才从目标仓库中下载。 默认的镜像下载策略是：当镜像标签是latest时，默认策略是Always；当镜像标签是自定义时（也就是标签不是latest），那么默认策略是IfNotPresent。 75、image的状态有哪些？ Running：Pod所需的容器已经被成功调度到某个节点，且已经成功运行， Pending：APIserver创建了pod资源对象，并且已经存入etcd中，但它尚未被调度完成或者仍然处于仓库中下载镜像的过程 Unknown：APIserver无法正常获取到pod对象的状态，通常是其无法与所在工作节点的kubelet通信所致。 76、pod的重启策略是什么？答：可以通过命令“kubectl explain pod.spec”查看pod的重启策略。（restartPolicy字段） Always：但凡pod对象终止就重启，此为默认策略。 OnFailure：仅在pod对象出现错误时才重启 77、Service这种资源对象的作用是什么？答：用来给相同的多个pod对象提供一个固定的统一访问接口，常用于服务发现和服务访问。 78、版本回滚相关的命令？12345678910[root@master httpd-web]# kubectl apply -f httpd2-deploy1.yaml --record #运行yaml文件，并记录版本信息；[root@master httpd-web]# kubectl rollout history deployment httpd-devploy1 #查看该deployment的历史版本[root@master httpd-web]# kubectl rollout undo deployment httpd-devploy1 --to-revision=1 #执行回滚操作，指定回滚到版本1#在yaml文件的spec字段中，可以写以下选项（用于限制最多记录多少个历史版本）：spec: revisionHistoryLimit: 5 #这个字段通过 kubectl explain deploy.spec 命令找到revisionHistoryLimit &lt;integer&gt;行获得 79、标签与标签选择器的作用是什么？标签：是当相同类型的资源对象越来越多的时候，为了更好的管理，可以按照标签将其分为一个组，为的是提升资源对象的管理效率。 标签选择器：就是标签的查询过滤条件。目前API支持两种标签选择器： 基于等值关系的，如：“=”、“”“==”、“！=”（注：“==”也是等于的意思，yaml文件中的matchLabels字段）； 基于集合的，如：in、notin、exists（yaml文件中的matchExpressions字段）； 注：in:在这个集合中；notin：不在这个集合中；exists：要么全在（exists）这个集合中，要么都不在（notexists）； 使用标签选择器的操作逻辑： 在使用基于集合的标签选择器同时指定多个选择器之间的逻辑关系为“与”操作（比如：- {key: name,operator: In,values: [zhangsan,lisi]} ，那么只要拥有这两个值的资源，都会被选中）； 使用空值的标签选择器，意味着每个资源对象都被选中（如：标签选择器的键是“A”，两个资源对象同时拥有A这个键，但是值不一样，这种情况下，如果使用空值的标签选择器，那么将同时选中这两个资源对象） 空的标签选择器（注意不是上面说的空值，而是空的，都没有定义键的名称），将无法选择出任何资源； 在基于集合的选择器中，使用“In”或者“Notin”操作时，其values可以为空，但是如果为空，这个标签选择器，就没有任何意义了。 两种标签选择器类型（基于等值、基于集合的书写方法）： 123456selector: matchLabels: #基于等值 app: nginx matchExpressions: #基于集合 - &#123;key: name,operator: In,values: [zhangsan,lisi]&#125; #key、operator、values这三个字段是固定的 - &#123;key: age,operator: Exists,values:&#125; #如果指定为exists，那么values的值一定要为空 80、常用的标签分类有哪些？标签分类是可以自定义的，但是为了能使他人可以达到一目了然的效果，一般会使用以下一些分类： 版本类标签（release）：stable（稳定版）、canary（金丝雀版本，可以将其称之为测试版中的测试版）、beta（测试版）； 环境类标签（environment）：dev（开发）、qa（测试）、production（生产）、op（运维）； 应用类（app）：ui、as、pc、sc； 架构类（tier）：frontend（前端）、backend（后端）、cache（缓存）； 分区标签（partition）：customerA（客户A）、customerB（客户B）； 品控级别（Track）：daily（每天）、weekly（每周）。 81、有几种查看标签的方式？答：常用的有以下三种查看方式： 123[root@master ~]# kubectl get pod --show-labels #查看pod，并且显示标签内容[root@master ~]# kubectl get pod -L env,tier #显示资源对象标签的值[root@master ~]# kubectl get pod -l env,tier #只显示符合键值资源对象的pod，而“-L”是显示所有的pod 82、添加、修改、删除标签的命令？12345678910#对pod标签的操作[root@master ~]# kubectl label pod label-pod abc=123 #给名为label-pod的pod添加标签[root@master ~]# kubectl label pod label-pod abc=456 --overwrite #修改名为label-pod的标签[root@master ~]# kubectl label pod label-pod abc- #删除名为label-pod的标签[root@master ~]# kubectl get pod --show-labels #对node节点的标签操作 [root@master ~]# kubectl label nodes node01 disk=ssd #给节点node01添加disk标签[root@master ~]# kubectl label nodes node01 disk=sss –overwrite #修改节点node01的标签[root@master ~]# kubectl label nodes node01 disk- #删除节点node01的disk标签 83、DaemonSet资源对象的特性？DaemonSet这种资源对象会在每个k8s集群中的节点上运行，并且每个节点只能运行一个pod，这是它和deployment资源对象的最大也是唯一的区别。所以，在其yaml文件中，不支持定义replicas，除此之外，与Deployment、RS等资源对象的写法相同。 它的一般使用场景如下： 在去做每个节点的日志收集工作； 监控每个节点的的运行状态； 84、说说你对Job这种资源对象的了解？答：Job与其他服务类容器不同，Job是一种工作类容器（一般用于做一次性任务）。使用常见不多，可以忽略这个问题。 123456#提高Job执行效率的方法：spec: parallelism: 2 #一次运行2个 completions: 8 #最多运行8个 template:metadata: 85、描述一下pod的生命周期有哪些状态？ Pending：表示pod已经被同意创建，正在等待kube-scheduler选择合适的节点创建，一般是在准备镜像； Running：表示pod中所有的容器已经被创建，并且至少有一个容器正在运行或者是正在启动或者是正在重启； Succeeded：表示所有容器已经成功终止，并且不会再启动； Failed：表示pod中所有容器都是非0（不正常）状态退出； Unknown：表示无法读取Pod状态，通常是kube-controller-manager无法与Pod通信。 86、创建一个pod的流程是什么？ 客户端提交Pod的配置信息（可以是yaml文件定义好的信息）到kube-apiserver； Apiserver收到指令后，通知给controller-manager创建一个资源对象； Controller-manager通过api-server将pod的配置信息存储到ETCD数据中心中； Kube-scheduler检测到pod信息会开始调度预选，会先过滤掉不符合Pod资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行pod的节点，然后将pod的资源配置单发送到node节点上的kubelet组件上。 Kubelet根据scheduler发来的资源配置单运行pod，运行成功后，将pod的运行信息返回给scheduler，scheduler将返回的pod运行状况的信息存储到etcd数据中心。 87、删除一个Pod会发生什么事情？答：Kube-apiserver会接受到用户的删除指令，默认有30秒时间等待优雅退出，超过30秒会被标记为死亡状态，此时Pod的状态Terminating，kubelet看到pod标记为Terminating就开始了关闭Pod的工作； 关闭流程如下： pod从service的endpoint列表中被移除； 如果该pod定义了一个停止前的钩子，其会在pod内部被调用，停止钩子一般定义了如何优雅的结束进程； 进程被发送TERM信号（kill -14） 当超过优雅退出的时间后，Pod中的所有进程都会被发送SIGKILL信号（kill -9）。 88、K8s的Service是什么？答：Pod每次重启或者重新部署，其IP地址都会产生变化，这使得pod间通信和pod与外部通信变得困难，这时候，就需要Service为pod提供一个固定的入口。 Service的Endpoint列表通常绑定了一组相同配置的pod，通过负载均衡的方式把外界请求分配到多个pod上 89、k8s是怎么进行服务注册的？答：Pod启动后会加载当前环境所有Service信息，以便不同Pod根据Service名进行通信。 90、k8s集群外流量怎么访问Pod？答：可以通过Service的NodePort方式访问，会在所有节点监听同一个端口，比如：30000，访问节点的流量会被重定向到对应的Service上面。 91、k8s数据持久化的方式有哪些？答： 1）EmptyDir（空目录）：没有指定要挂载宿主机上的某个目录，直接由Pod内保部映射到宿主机上。类似于docker中的manager volume。 主要使用场景： 只需要临时将数据保存在磁盘上，比如在合并/排序算法中； 作为两个容器的共享存储，使得第一个内容管理的容器可以将生成的数据存入其中，同时由同一个webserver容器对外提供这些页面。 emptyDir的特性： 同个pod里面的不同容器，共享同一个持久化目录，当pod节点删除时，volume的数据也会被删除。如果仅仅是容器被销毁，pod还在，则不会影响volume中的数据。 总结来说：emptyDir的数据持久化的生命周期和使用的pod一致。一般是作为临时存储使用。 2）Hostpath：将宿主机上已存在的目录或文件挂载到容器内部。类似于docker中的bind mount挂载方式。 这种数据持久化方式，运用场景不多，因为它增加了pod与节点之间的耦合。 一般对于k8s集群本身的数据持久化和docker本身的数据持久化会使用这种方式，可以自行参考apiService的yaml文件，位于：/etc/kubernetes/main…目录下。 3）PersistentVolume（简称PV）：基于NFS服务的PV，也可以基于GFS的PV。它的作用是统一数据持久化目录，方便管理。 在一个PV的yaml文件中，可以对其配置PV的大小，指定PV的访问模式： ReadWriteOnce：只能以读写的方式挂载到单个节点； ReadOnlyMany：能以只读的方式挂载到多个节点； ReadWriteMany：能以读写的方式挂载到多个节点。以及指定pv的回收策略： recycle：清除PV的数据，然后自动回收； Retain：需要手动回收； delete：删除云存储资源，云存储专用； PS：这里的回收策略指的是在PV被删除后，在这个PV下所存储的源文件是否删除）。 若需使用PV，那么还有一个重要的概念：PVC，PVC是向PV申请应用所需的容量大小，K8s集群中可能会有多个PV，PVC和PV若要关联，其定义的访问模式必须一致。定义的storageClassName也必须一致，若群集中存在相同的（名字、访问模式都一致）两个PV，那么PVC会选择向它所需容量接近的PV去申请，或者随机申请。 MysqlMysql性能优化优化思路： 开启慢查询日志，查看哪些sql耗时长 查看执行慢的sql的执行计划（为优化提供方向） 优化查询sql（怎么优化） 使用【show profils】查看问题sql的使用情况（使用方法是啥） 调整操作系统参数优化（怎么调整） 升级服务硬件（什么条件下升级） 慢查询日志1、MySQL的慢查询日志功能默认是关闭的，需要手动开启 123456show variables like &apos;%slow_query%&apos;- 【slow_query_log】 ：是否开启慢查询日志，1为开启，0为关闭。- 【slow-query-log-file】：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.logshow variables like &apos;long_query_time%&apos;- 【long_query_time】 ：慢查询阈值，当查询时间多于设定的阈值时，记录日志，【单位为秒】。 2、临时开启慢查询功能 12set global slow_query_log = ON;set global long_query_time = 1; 3、永久开启慢查询功能 1234#修改/etc/my.cnf配置文件，重启 MySQL, 这种永久生效.[mysqld]slow_query_log=ONlong_query_time=1 第一行：SQL查询执行的具体时间 第二行：执行SQL查询的连接信息，用户和连接IP 第三行：记录了一些我们比较有用的信息 Query_time：这条SQL执行的时间，越长则越慢 Lock_time：在MySQL服务器阶段(不是在存储引擎阶段)等待表锁时间 Rows_sent：查询返回的行数 Rows_examined：查询检查的行数，越长就当然越费时间 分析慢查询日志的工具mysqldumpslow工具：是MySQL自带的慢查询日志工具 1mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/localhost-slow.log 常用参数说明： -s：是表示按照何种方式排序 al 平均锁定时间 ar 平均返回记录时间 at 平均查询时间（默认） c 计数 l 锁定时间 r 返回记录 t 查询时间 -t：是top n的意思，即为返回前面多少条的数据 -g：后边可以写一个正则匹配模式，大小写不敏感的 查看执行计划1234567891011121314151617create table tuser( id int primary key auto_increment, name varchar(100), age int, sex char(1), address varchar(100));alter table tuser add index idx_name_age(name(100),age);alter table tuser add index idx_sex(sex(1));insert into tuser(id,name,age,sex,address) values (1,&apos;张三&apos;,20,&apos;1&apos;,&apos;北京&apos;);insert into tuser(id,name,age,sex,address) values (2,&apos;李四&apos;,16,&apos;1&apos;,&apos;上海&apos;);insert into tuser(id,name,age,sex,address) values (3,&apos;王五&apos;,34,&apos;1&apos;,&apos;杭州&apos;);insert into tuser(id,name,age,sex,address) values (4,&apos;方六&apos;,26,&apos;2&apos;,&apos;广州&apos;);insert into tuser(id,name,age,sex,address) values (5,&apos;季七&apos;,18,&apos;2&apos;,&apos;上海&apos;);explain select * from tuser where id = 2 id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符. select_type: SELECT 查询的类型。（普通查询、联合查询(union、union all)、子查询等复杂查询） table: 查询的是哪个表 partitions: 匹配的分区 type: join 类型 possible_keys: 此次查询中可能选用的索引 key: 此次查询中确切使用到的索引. ref: 哪个字段或常数与 key 一起被使用 rows: 显示此查询一共扫描了多少行. 这个是一个估计值. filtered: 表示此查询条件所过滤的数据的百分比 extra: 额外的信息 select_type（重要）1、simple 不需要union操作或者不包含子查询的简单select查询 2、primary 个需要union操作或者含有子查询的select 3、union union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union 4、dependent union 出现在union 或union all语句中，但是这个查询要受到外部查询的影响 5、union result 包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null 6、subquery 除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery 7、dependent subquery 表示这个subquery的查询要受到外部表查询的影响 8、derived from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select type（重要） system：表中只有一行数据或者是空表 const：使用唯一索引或者主键 eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。 ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。 fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引 ref_or_null：与ref方法类似，只是增加了null值的比较。 unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值 index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。 range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。 index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引 index：select结果列中使用到了索引，type会显示为index。 ALL：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。 extra（重要） Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。 Using temporary：MySQL在对查询结果排序时使用临时表。 using index：查询时不需要回表查询，直接通过索引就可以获取查询的结果数据。（使用到了覆盖索引） using where：Mysql将对storage engine提取的结果进行过滤，过滤条件字段无索引； Using join buffer：使用了连接缓存,比如说在查询的时候，多表join的次数非常多，那么将配置文件中的缓冲区的joinbuffer调大一些。 impossible where：where子句的值总是false ，不能用来获取任何元组（SELECT * FROM t_user WHERE id = ‘1’ and id = ‘2’） SQL语句优化 为搜索字段（where中的条件）、排序字段、select查询列，创建合适的索引，不过要考虑数据业务场景：查询多还是增删多？ 尽量建立组合索引并注意组合索引的创建顺序，按照顺序组织查询条件、尽量将筛选粒度大的查询条件放到最左边。 尽量使用覆盖索引，SELECT语句中尽量不要使用*。 索引长度尽量短，短索引可以节省索引空间，使查找的速度得到提升，同时内存中也可以装载更多的索引键值。太长的列，可以选择建立前缀索引。 索引更新不能频繁，更新非常频繁的数据不适宜建索引，因为维护索引的成本。order by、group by语句要尽量使用到索引 order by的索引生效，order by排序应该遵循最左前缀查询，如果是使用多个索引字段进行排序，那么排序的规则必须相同（同是升序或者降序），否则索引同样会失效。 LIMIT优化 如果预计SELECT语句的查询结果是一条，最好使用 LIMIT 1，可以停止全表扫描。 处理分页会使用到LIMIT ，当翻页到非常靠后的页面的时候，偏移量会非常大，这时LIMIT的效率会非常差。（单表分页时，使用自增主键排序之后，先使用where条件 id &gt; offset值，limit后面只写rows） （select * from (select * from tuser2 where id &gt; 1000000 and id &lt; 1000500 ORDER BY id) t limit 0, 20） 小表驱动大表，建议使用left join时，以小表关联大表（使用join的话，第一张表是必须全扫描的，以少关联多就可以减少这个扫描次数。） 避免全表扫描 避免mysql放弃索引查询 尽量不使用count(*)、尽量使用count（主键） JOIN两张表的关联字段最好都建立索引 WHERE条件中尽量不要使用not in语句 合理利用慢查询日志、explain执行计划查询、show profile查看SQL执行时的资源使用情况 profile分析语句 Query Profiler是MySQL自带的一种query诊断分析工具 通过它可以分析出一条SQL语句的硬件性能瓶颈在什么地方 1show variables like &apos;%profil%&apos;; profiling ： ON 表示开启 12#开启profile功能set profiling=1; --1是开启、0是关闭 show profile: 展示最近一条语句执行的详细资源占用信息,默认显示 Status和Duration两列 show profile 还可根据 show profiles 列表中的 Query_ID ,选择显示某条记录的性能分析信息 服务器层面优化1、缓冲区优化 设置足够大的innodb_buffer_pool_size ，将数据读取到内存中 建议innodb_buffer_pool_size设置为总内存大小的3/4或者4/5 2、降低磁盘写入次数 生产环境，很多日志是不需要开启的，比如：通用查询日志、慢查询日志、错误日志 使用足够大的写入缓存 innodb_log_file_size（0.25 * innodb_buffer_pool_size） 3、MySQL数据库配置优化 1234567891011innodb_buffer_pool_size #总内存大小的3/4或者4/5innodb_flush_log_at_trx_commit=1 #控制redo log刷新到磁盘的策略sync_binlog=1 #每提交1次事务同步写到磁盘中innodb_max_dirty_pages_pct=30 #脏页占innodb_buffer_pool_size的比例时，触发刷脏页到磁盘。 推荐值为25%~50%。innodb_io_capacity=200 #后台进程最大IO性能指标。默认200，如果SSD，调整为5000~20000innodb_data_file_path #指定innodb共享表空间文件的大小ong_qurey_time=0.3 #慢查询日志的阈值设置，单位秒binlog_format=row #mysql复制的形式，row为MySQL8.0的默认形式。max_connections=200 #调高该参数则应降低interactive_timeout、wait_timeout的值innodb_log_file_size #过大，实例恢复时间长；过小，造成日志切换频繁。general_log=0 #全量日志建议关闭，默认关闭 操作系统优化内核参数优化 CentOS系统针对mysql的参数优化，内核相关参数(/etc/sysctl.conf)，以下参数可以直接放到sysctl.conf文件的末尾。 增加监听队列上限： 123net.core.somaxconn = 65535net.core.netdev_max_backlog = 65535net.ipv4.tcp_max_syn_backlog = 65535 加快TCP连接的回收： 123net.ipv4.tcp_fin_timeout = 10net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1 TCP连接接收和发送缓冲区大小的默认值和最大值: 1234net.core.wmem_default = 87380net.core.wmem_max = 16777216net.core.rmem_default = 87380net.core.rmem_max = 16777216 减少失效连接所占用的TCP资源的数量，加快资源回收的效率： 123net.ipv4.tcp_keepalive_time = 120net.ipv4.tcp_keepalive_intvl = 30net.ipv4.tcp_keepalive_probes = 3 单个共享内存段的最大值： 1234kernel.shmmax = 4294967295#这个参数应该设置的足够大，以便能在一个共享内存段下容纳整个的Innodb缓冲池的大小。#这个值的大小对于64位linux系统，可取的最大值为(物理内存值-1)byte，建议值为大于物理内存的一半，一般取值大于Innodb缓冲池的大小即可。 控制换出运行时内存的相对权重 123vm.swappiness = 0#这个参数当内存不足时会对性能产生比较明显的影响#设置为0，表示Linux内核虚拟内存完全被占用，才会要使用交换区 增加资源限制 打开文件数的限制(/etc/security/limit.conf) 12345678* soft nofile 65535* hard nofile 65535*：表示对所有用户有效soft：表示当前系统生效的设置（soft不能大于hard ）hard：表明系统中所能设定的最大值nofile：表示所限制的资源是打开文件的最大数目65535：限制的数量 磁盘调度策略（选用deadline） 12345678910111213141516171819202122查看调度策略的方法：cat /sys/block/devname/queue/scheduler修改调度策略的方法：echo &gt; /sys/block/devname/queue/scheduler#该模式按进程创建多个队列，各个进程发来的IO请求会被cfq以轮循方式处理，对每个IO请求都是公平#的。该策略适合离散读的应用。cfq (完全公平队列策略，Linux2.6.18之后内核的系统默认策略)#deadline，包含读和写两个队列，确保在一个截止时间内服务请求（截止时间是可调整的），而默认读#期限短于写期限。这样就防止了写操作因为不能被读取而饿死的现象，deadline对数据库类应用是最好的选择。deadline (截止时间调度策略)#noop只实现一个简单的FIFO队列，倾向饿死读而利于写，因此noop对于闪存设备、RAM及嵌入式系统是最好的选择。noop (电梯式调度策略)#本质上与deadline策略一样，但在最后一次读操作之后，要等待6ms，才能继续进行对其它I/O请求进#行调度。它会在每个6ms中插入新的I/O操作，合并写入流，用写入延时换取最大的写入吞吐量。#anticipatory适合于写入较多的环境，比如文件服务器。该策略对数据库环境表现很差。anticipatory (预料I/O调度策略) 服务器硬件优化 尽量选择高频率的内存 提升网络带宽 使用SSD高速磁盘 提升CPU性能（对于数据库并发比较高的场景，CPU的数量比频率重要；对于CPU密集型场景和频繁执行复杂SQL的场景，CPU的频率越高越好） Prometheus知识点总结 HTTP状态码HTTP 状态码分类HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML-基础篇]]></title>
    <url>%2F2022%2F04%2F20%2FHTML-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[相关链接 HTML5开箱即用 HTML5前端知识图谱 标签基础标签1. 整体架构123456789101112&lt;!DOCTYPE html&gt; &lt;!-- 文档类型说明 必须放在文档的最前面 --&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; I'am very happy!&lt;/body&gt;&lt;/html&gt; 2. 标题标签123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;标题标签&lt;/h1&gt; &lt;h1&gt;标题一共六级选,&lt;/h1&gt; &lt;h2&gt;文字加粗一行显,&lt;/h2&gt; &lt;h3&gt;由大到小依次减,&lt;/h3&gt; &lt;h4&gt;由重到轻随之变.&lt;/h4&gt; &lt;h5&gt;语法规范书写后,&lt;/h5&gt; &lt;h6&gt;具体效果刷新见.&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt; 3. 段落和换行标签1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;ABCDEFGHIJKLMN&lt;br/&gt;OPQRSTUVWXYZ&lt;/p&gt; &lt;p&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/p&gt; &lt;p&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 4. 文本格式化标签1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 我是&lt;strong&gt;加粗&lt;/strong&gt;的文字 &lt;br/&gt; 我是&lt;b&gt;加粗&lt;/b&gt;的文字 &lt;br&gt; 我是&lt;em&gt;倾斜&lt;/em&gt;的文字 &lt;br&gt; 我是&lt;i&gt;倾斜&lt;/i&gt;的文字 &lt;br&gt; 我是&lt;del&gt;删除线&lt;/del&gt;标签 &lt;br&gt; 我是&lt;s&gt;删除线&lt;/s&gt;标签 &lt;br&gt; 我是&lt;ins&gt;下划线&lt;/ins&gt;标签 &lt;br&gt; 我是&lt;u&gt;下划线&lt;/u&gt;标签&lt;/body&gt;&lt;/html&gt; 5. div和span标签12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;我是一个div&lt;/div&gt;123 &lt;div&gt;我是一个div&lt;/div&gt; &lt;span&gt;百度&lt;/span&gt; &lt;span&gt;新浪&lt;/span&gt; &lt;span&gt;京东&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 6. 图像标签1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;图像标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;图像标签:&lt;/h4&gt; &lt;img src="./maomi_laoshi-001-2 2.jpg" alt="图片显示不出来时显示此文字" title="鼠标放到图片上显示此文字" width="500"&gt; &lt;h4&gt;图像标签:&lt;/h4&gt; &lt;img src="./maomi_laoshi-001-2 2.jpg" alt="图片显示不出来时显示此文字" title="鼠标放到图片上显示此文字" height="100"&gt; &lt;h4&gt;设定边框:&lt;/h4&gt; &lt;img src="./maomi_laoshi-001-2 2.jpg" alt="图片显示不出来时显示此文字" title="鼠标放到图片上显示此文字" height="100" border="15"&gt;&lt;/body&gt;&lt;/html&gt; 7. 链接标签123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;外部链接&lt;/h2&gt; &lt;h4&gt;当前页面打开页面:&lt;/h4&gt; &lt;a href="https://www.baidu.com" target="_self"&gt;访问百度&lt;/a&gt; &lt;h4&gt;新标签页打开页面:&lt;/h4&gt; &lt;a href="https://www.baidu.com" target="_blank"&gt;访问百度&lt;/a&gt; &lt;h2&gt;内部链接:&lt;/h2&gt; &lt;a href="./yunzhihui.html" target="_blank"&gt;云智慧简介&lt;/a&gt; &lt;h2&gt;空链接:&lt;/h2&gt; &lt;a href="#"&gt;空链接&lt;/a&gt; &lt;h2&gt;下载链接:&lt;/h2&gt; &lt;a href="maomi_laoshi-001-2 2.jpg.zip"&gt;下载文件&lt;/a&gt; &lt;h2&gt;网页元素链接:&lt;/h2&gt; &lt;a href="https://www.baidu.com" target="_blank"&gt;&lt;img src="./maomi_laoshi-001-2 2.jpg" alt="图片" width="500"&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 8. 超链接标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;点击链接,跳转到当前页面中的另一个位置:&lt;/h4&gt; &lt;a href="#early" id="early_return"&gt;1 早年经历&lt;/a&gt; &lt;br&gt; &lt;a href="#act" id="act_return"&gt;2 演艺经历&lt;/a&gt; &lt;br&gt; &lt;a href="#life" id="life_return"&gt;3 个人生活&lt;/a&gt; &lt;br&gt; &lt;a href="#works" id="works_return"&gt;4 主要作品&lt;/a&gt; &lt;br&gt;&lt;a href="#early_return"&gt;&lt;h1 id="early"&gt;早年经历&lt;/h1&gt;&lt;/a&gt;刘德华出生于香港新界，在家中排行老四，幼时随家人搬到了九龙钻石山的木屋区居住，并和姐弟一起帮助家里打理卖稀饭的生意 [20] 。1973年，刘德华随家人搬入香港蓝田邨第15座14楼 [21] 。刘德华从黄大仙天主教小学毕业后升读可立中学 [22] 。在可立中学读书期间，刘德华积极参加校内学校剧社的表演，在老师杜国威的指导下学习戏剧方面的知识。此外，他还参与包括编剧在内的幕后制作。刘德华在中五会考获得1B3D2E（中文读本A）的成绩。中六上学期后，他到香港电视广播有限公司的艺员训练班受训，从而开始了演艺之路 [23] 。&lt;a href="#act_return"&gt;&lt;h1 id="act"&gt;演艺经历&lt;/h1&gt;&lt;/a&gt;港剧时代1981年，刘德华考进第10期无线电视艺员训练班 [24] 。同年，出演个人首部电视剧《江湖再见》，在剧中饰演以贩卖妇女为生的小混混阿龙；该剧获得美国电视节电视剧特别奖 [25] 。刘德华电视剧剧照刘德华电视剧剧照(11张)1982年，刘德华以甲级成绩从艺员训练班毕业后正式签约TVB [26] 。同年在喜剧《花艇小英雄》中饰演败家仔钱日添。12月，与叶德娴搭档主演时装警匪剧《猎鹰》，凭借卧底警察江大伟一角获得关注 [27] 。1983年，主演金庸武侠剧《神雕侠侣》，在剧中饰演外貌俊俏、倜傥不羁的杨过 [28] ；该剧在香港播出后取得62点的收视纪录。同年，与黄日华、梁朝伟、苗侨伟、汤镇业组成“无线五虎将” [29] 。1984年，与赵雅芝合作主演古装武侠剧《魔域桃源》，在剧中饰演资质出众、武功高强的傅青云 [30] 。同年，与梁朝伟共同主演金庸武侠剧《鹿鼎记》，在剧中饰演英明果断的康熙 [31] 。1985年，在古装武侠剧《杨家将》中饰演骁勇善战的杨六郎 [32] 。同年，TVB向刘德华提出加签五年的合约，刘德华因拒绝而被TVB雪藏400天 [33-34] 。1986年，在邵逸夫的调解下，刘德华与TVB和解并签下合约。同年，主演古装剧《真命天子》。1988年，在出演了武侠剧《天狼劫》后，刘德华将演艺事业的重心转向影坛 [34] 。电影时代刘德华写真刘德华写真(4张)1981年，刘德华出演电影处女作《彩云曲》，在片中扮演一个音乐班的学员 [35] 。1982年，在剧情片《投奔怒海》中饰演美军翻译官祖名，并凭借该片获得第2届香港电影金像奖最佳新演员提名 [35] 。1983年，与朱海玲 [36] 搭档主演剧情片《家在香港》，在片中饰演急功近利的青年人亚伦 [37] 。同年，主演动作片《毁灭号地车》，在片中与一个越南少女演绎了一段爱情故事 [38] 。1984年，在爱情片《停不了的爱》中饰演富家公子Eric [39] 。1985年，在与叶德娴共同主演的剧情片《法外情》中饰演少年得志的青年律师刘志鹏 [40] 。1986年，主演科幻冒险片《魔翡翠》，在片中饰演冒险专家猎鹰一号，这也是他首度出演科幻题材的电影 [41] 。同年，出演喜剧片《最佳福星》，在片中饰演身手矫健的特警组警员蓝保 [42] 。1987年，主演警匪片《肝胆相照》，在片中饰演亦正亦邪的犯罪集团成员阿定 [43] 。1988年，主演王家卫执导的黑帮片《旺角卡门》，在片中饰演重情重义的江湖混混华仔，并凭借该片获得第8届香港电影金像奖最佳男主角奖提名 [44] 。同年，主演警匪片《猎鹰计划》，在片中饰演具有正义感的警员国华 [45] 。此外，他还再度与叶德娴合作，在剧情片《法内情》中与叶德娴饰演绎了一段母子情 [46] 。1989年，在动作片《至尊无上》中饰演有“亚洲第一快手”之称的陈亚蟹 [47] 。同年，主演剧情片《神行太保》，在片中饰演一名公正、能干、勇敢的太保。此外，他还主演了动作片《人海孤鸿》，在片中饰演没有接受过良好教育的古惑仔沙士 [48] 。12月，与周润发共同主演动作片《赌神》，在片中饰演赌神高进的徒弟刀仔 [49] 。刘德华刘德华(11张)1990年，主演爱情片《天若有情之追梦人》，在片中饰演善良热情、讲义气的黑社会混混华Dee [50] 。同年，主演剧情片《至尊计状元才》。12月，与周星驰合作主演赌片《赌侠》，在片中饰演身怀绝技的陈刀仔 [51] 。1991年，刘德华开始改变银幕形象，主演了传记题材的系列电影《五亿探长雷洛传》，并在片中首次诠释年龄跨度较大的人物，该系列中的两部作品《五亿探长雷洛传I雷老虎》、《五亿探长雷洛传2:父子情仇》在香港的累积票房达到5300万 [52] 。6月，主演犯罪题材的电影《至尊无上Ⅱ之永霸天下》。此外，他还主演了动作片《九一神雕侠侣》，该片是刘德华投资出品的首部电影作品 [53] 。同年，创办天幕电影公司 [3] 。1992年，凭借传记片《五亿探长雷洛传》获得第11届香港电影金像奖最佳男主角提名 [54] 。8月，与王祖贤、叶德娴合作出演剧情片《庙街十二少》。11月，与林青霞、叶德娴共同主演古装片《绝代双骄》，在片中饰演聪明绝顶的小鱼儿 [55] 。同年，主演爱情片《九二神雕侠侣之痴心情长剑》，在片中饰演痴情大侠情仁 [56] 。1993年，在古装片《战神传说》中扮演一个武功超群的渔民 [57] 。同年，主演动作喜剧片《至尊三十六计之偷天换日》，在片中饰演赌术高明的千门高手钱文迪。此外，他还主演了爱情片《天长地久》，在片中塑造了一个风流不羁的江湖浪子形象 [58] 。1994年，刘德华投资并主演了剧情片《天与地》 [4] ，并担任电影的制片人 [4] ，他在片中饰演面对恶势力却毫不退缩的禁毒专员张一鹏 [59] 。1995年，主演赛车励志片《烈火战车》，在片中饰演叛逆、倔强的阿祖，并凭借该片获得第15届香港电影金像奖最佳男主角提名 [60] 。同年，在动作片《大冒险家》中演绎了立仁从小时候父母双亡到长大后进入泰国空军的故事 [61] 。刘德华刘德华1996年，主演黑帮题材的电影《新上海滩》，在片中饰演对冯程程痴情一片的丁力。1997年，担任剧情片《香港制造》的制作人 [62] 。同年，主演爱情片《天若有情之烽火佳人》，在片中饰演家世显赫的空军少尉刘天伟 [63] 。12月，与梁家辉联袂主演警匪动作片《黑金》，在片中饰演精明干练、嫉恶如仇的调查局机动组组长方国辉 [64] 。1998年，主演动作片《龙在江湖》，饰演重义气的黑帮成员韦吉祥。同年，出演喜剧片《赌侠1999》 [65] 。此外，他还担任剧情片《去年烟花特别多》的制作人 [66] 。剧照海报剧照海报(3张)1999年1月，出演喜剧片《赌侠大战拉斯维加斯》。9月，刘德华与刘青云共同主演警匪片《暗战》；这部电影也成为刘德华表演生涯的转型之作，他在片中改变表演模式，饰演一个身患绝症却不颓废的大盗；并凭借该片获得第19届香港电影金像奖最佳男主角奖 [5] 。10月，在黑帮片《龙在边缘》中饰演决心改邪归正的洪兴帮大哥飞龙。同年，主演爱情片《黑马王子》，在片中饰演出身贫寒、不拘小节的阿华 [67] 。2000年，在动作片《阿虎》中饰演性感开朗、直爽的自由搏击拳手阿虎；该片是刘德华从影以来的第100部电影 [68] ；刘德华凭借该片获得第20届香港电影金像奖最佳男主角提名以及第6届香港电影金紫荆奖最佳男主角奖 [69-70] 。2001年8月3日，刘德华与日本演员反町隆史共同主演的动作片《全职杀手》上映，他在片中饰演为名誉而生的职业杀手Tok [71] ，并担任该片的制片人 [72] 。2002年，刘德华开始拓宽戏路，在与梁朝伟共同主演的警匪片《无间道》中饰混饰演个性复杂的反派人物刘建明 [73-74] ；该片在香港上映两周票房突破3000万港币，最终票房达到5505万港币 [75] ，刘德华凭借该片获得第22届香港电影金像奖最佳男主角提名以及第40届台湾电影金马奖最佳男主角奖提名 [76-77] 。3月28日，刘德华主演的科学幻想片《卫斯理之蓝血人》上映，他在片中饰演功夫出色的冒险家卫斯理 [78] 。2003年2月1日，刘德华主演的爱情喜剧片《老鼠爱上猫》上映，他在片中饰演风流倜傥、热爱自由的大侠展昭 [79] 。3月，主演剧情片《大块头有大智慧》，在片中饰演表面放荡不羁，但内心善良的武僧大块头 [80] 。12月，与梁朝伟共同主演强调正邪对峙、角色互换的警匪片《无间道Ⅲ终极无间》，在片中饰演被派到警队当内鬼的警员刘建明 [81] ；并凭借该片获得第41届台湾电影金马奖最佳男主角奖 [6] 。刘德华获奖照片刘德华获奖照片(2张)2004年1月，凭借剧情片《大块头有大智慧》获得第10届香港电影评论学会大奖最佳男主角奖 [82] 。4月，主演由冯小刚执导的剧情片《天下无贼》，在片中突破固有的银幕形象，饰演痞子气十足的盗贼王薄 [83] 。7月16日，刘德华与金城武、章子怡共同主演的武侠片《十面埋伏》在中国内地上映，他在片中饰演飞刀门在官府的卧底刘捕头 [84] 。同年，他还凭借剧情片《大块头有大智慧》获得第23届香港电影金像奖最佳男主角奖 [85] 。2005年，担任爱情片《再说一次我爱你》的制片人以及男主角，并在片中一人分饰两角，扮演抑郁消沉的高医生以及外向张扬的发型师DEREK [86] 。9月29日，刘德华主演的奇幻剧情片《童梦奇缘》上映 [87] 。同年，担任华语电影传媒大奖中国电影百年形象大使 [88] 。2006年，主演古装动作片《墨攻》 [89] ，在片中饰演用各种计策出奇制胜的革离；该片在中国内地上映三周票房超过6000万元 [90] 。2007年，与李连杰、金城武共同主演古装动作片《投名状》，在片中塑造了赵二虎率性而为的草莽英雄形象 [91] 。2月13日，在剧情片《门徒》中饰演为人低调的毒贩林昆，并凭借该片获得第27届香港电影金像奖最佳男配角奖 [92] 。同年，在香港国际电影节主办的首届亚洲电影大奖颁奖礼上，获得亚洲电影票房巨星大奖 [93] 。2008年，主演古装动作片《三国志之见龙卸甲》，在片中饰演智勇双全的常山赵子龙 [94] 。2009年1月20日，刘德华与舒淇联袂主演的爱情片《游龙戏凤》在中国内地上映；片中他首度扮演钻石王老五的角色，饰演事业成功的程仲森 [95] 。同年，参演战争片《建国大业》 [96] 。刘德华主演的电影刘德华主演的电影(7张)2010年，刘德华主演了由徐克执导的古装片《狄仁杰之通天帝国》，他在片中塑造了一个文武双全的大唐神探形象 [97] 。3月30日，刘德华与范冰冰合作主演的科幻警匪片《未来警察》在中国内地上映；他在片中饰演处事果断的未来警察周志豪 [98] 。5月，获得第十二届世界杰出华人奖 [99] 。2011年2月3日，刘德华与巩俐主演的都市爱情片《我知女人心》上映，他在片中饰演一位游走在美女间的风云人物；同年，在动作片《新少林寺》中饰演骁勇善战的军阀少帅侯杰 [100] 。2012年3月8日，与叶德娴搭档主演的文艺片《桃姐》上映，刘德华在片中饰演生长于大家庭的少爷罗杰 [101] [262] ，并凭借该片获得第48届台湾电影金马奖最佳男主角奖、第31届香港电影金像奖最佳男主角奖 [9] [102] 。2013年1月16日，担任第7届亚洲电影大奖评审团主席 [103] 。6月9日，主演3D特工电影《天机·富春山居图》，在片中饰演身陷不白之冤的国际特工肖锦汉 [104] 。 [105] 同年，主演3D警匪动作片《风暴》在中国内地上映。2014年5月，主演中国首部打拐题材的电影《失孤》，在片中饰演倔强善良的农民雷泽宽。2015年3月20日，主演的电影《失孤》上映 [263] 。9月30日，刘德华主演的警匪片《解救吾先生》上映，他在片中饰演冷静、机智的电影明星吾先生 [106] 。同年，与周润发、张学友共同主演动作喜剧片《澳门风云3》 [107] 。2016年4月1日，刘德华参演的动作片《我的特工爷爷》上映，他在片中饰演嗜赌成性且脾气暴躁的小混混李政久 [108] 。同年，参演魔幻类型的3D动作片《长城》 [109] 。6月，凭借剧情片《失孤》获得第16届中国电影华表奖优秀男演员奖 [110] 。10月1日，刘德华主演的喜剧动作片《王牌逗王牌》上映 [111] ，他在片中饰演破案能力与闯祸能力都很强的囧探宝爷 [112] 。此外，刘德华客串了电影《铁道飞虎》 [113] 。2017年4月28日，主演的警匪动作片《拆弹专家》在中国内地上映 [114] ，他在片中饰演一名卧底拆弹专家，并担任影片的制作人 [115] 。7月，主演由冯德伦执导的动作冒险片《侠盗联盟》，在片中饰演温文尔雅的江洋大盗张丹 [116] 。9月30日，与甄子丹共同主演的动作犯罪片《追龙》上映，刘德华在片中饰演头脑精明的“五亿探长”雷洛 [117] 。2018年2月，凭借警匪片《拆弹专家》获得第37届香港电影金像奖最佳男主角奖提名 [118] 。此外，他还以监制、主演的身份参加《扫毒2》的拍摄 [119] 。5月，担任监制的迷你剧《东方华尔街》播出 [120] 。2019年1月，主演电影《香港地》 [121] 。3月，主演警匪片《拆弹专家2》 [122] 。9月12日，其友情客串的电影《花椒之味》上映 [123] 。同年，与葛优、张涵予主演电影《莫斯科大劫案》，同时他也是该片编剧 [124] 。2020年1月19日，取材经典神话故事的《七圣》系列电影正式启动，刘德华担任监制及主演，在片中饰演孙悟空 [125] 。同年，参与录制的全球户外生活文化实境秀节目《周游记》在浙江卫视播出 [126] 。11月13日，刘德华监制并领衔主演的青春励志电影《热血合唱团》上映 [127] 。12月24日，与刘青云、倪妮共同主演的动作犯罪片《拆弹专家2》上映，在片中饰演一边逃亡一边查明爆炸案真相的前拆弹专家潘乘风，刘德华凭借该片获得第30届华鼎奖最佳男主角奖、最佳专业精神奖 [270] 。2021年，主演庄文强执导的犯罪片《金手指》 [130] 。同年，参演悬疑喜剧片《唐人街探案3》，在片中饰演Q [247] 。2月12日，与肖央、万茜合作主演的犯罪喜剧电影《人潮汹涌》上映，他在片中饰演冷血杀手周全 [129] 。2022年2月，领衔主演宁浩执导的喜剧电影《红毯先生》，在片中饰演过气香港明星刘伟驰 [306] 。刘德华刘德华刘德华刘德华刘德华刘德华音乐时代1985年，加入华星唱片公司；同年，发行首张个人专辑《只知道此刻爱你》，从而正式进入歌坛 [131] 。1987年，加入百代唱片公司。同年，发行粤语专辑《情感的禁区》，其中收录了电影《肝胆相照》的主题曲《当中究竟》以及电影《中国最后一个太监》的主题曲《错觉》 [272] 。1988年2月，发行第三张个人专辑《回到你身边》；这张专辑拓展了歌曲题材的表达范围，专辑所收录的歌曲也不再局限于爱情类型的歌曲 [132] 。1989年2月，发行个人首张普通话专辑《回到你身边·法内情》 [273] 。10月，发行普通话专辑《爱的连线》，收录了包括情歌《在我的胸前安歇》、《忘了爱》在内的8首歌曲 [286] 。1990年，凭借专辑《可不可以》奠定其在歌坛的地位 [133] ；专辑中的歌曲《可不可以》获得第13届十大中文金曲奖 [274] 。6月，发行普通话专辑《如果你是我的传说》 [284] ；专辑发行后在东南亚的销售量达150万张；这张专辑收录的歌曲多数采用了近似的题材与曲式，同名主打歌《如果你是我的传说》由刘德华个人填词 [134] 。12月，发行粤语专辑《再会了》 [285] ；其中主打歌《再会了》获得十大劲歌金曲奖 [276] 。杂志封面杂志封面(7张)1991年2月，发行粤语专辑《爱不完》 [283] ；该专辑发行首日录音带的销量达到16万张，而激光唱片的销量则有7.2万张 [135] 。6月，发行普通话专辑《我和我追逐的梦》，收录了《把今生忘掉》、《不甘寂寞》等10首歌曲 [277] 。8月，发行专辑《一起走过的日子》 [282] ，其中主打歌《一起走过的日子》获得十大劲歌金曲奖以及十大中文金曲奖 [274-275] 。12月，推出普通话专辑《来生缘》，收录了《风中的歌》、《为了你请留下我》、《来生缘》等11首歌曲 [287] 。同年，获得十大劲歌金曲奖最受欢迎男歌手奖 [275] 。1992年，获得十大劲歌金曲奖最受欢迎男歌手奖 [278] 。2月，在提前录制的央视春晚视频中，刘德华与毛阿敏、张雨生合唱歌曲《心中常驻芳华》 [136] ，随后在洛杉矶、旧金山等地举行美加巡回演唱会。7月10日，推出粤语专辑《爱的空间》，其中收录了时装剧《巨人》的主题曲《你震撼我的心灵》 [281] 。7月22日，发行普通话专辑《谢谢你的爱》 [248] ，其中主打歌《谢谢你的爱》成为刘德华音乐生涯的代表作 [249] 。9月，发行加入华纳唱片公司后的首张粤语专辑《真我的风采》；该专辑销量达到40万张 [135] ，其中粤语版的《谢谢你的爱》获得第16届十大中文金曲奖 [279] ，专辑中的歌曲《真我的风采》获得第15届十大中文金曲奖以及十大劲歌金曲奖 [278] [280] 。1993年1月至2月，在香港红磡体育馆举行20场“真我的风采演唱会”。3月，推出加入飞碟唱片公司后的首张专辑《真情难收》 [288] ，其中主打歌曲《一辈子的错》由刘德华个人作词 [289] 。7月，推出粤语专辑《答案就是你》 [290] ，专辑中的歌曲《永远寂寞》获得第16届十大中文金曲奖 [279] 。9月，发行普通话专辑《一生一次》 [297] ，其中歌曲《不能没有你》获得第16届十大中文金曲优秀普通话歌曲奖 [299] 。1994年4月，发行普通话专辑《忘情水》，其中主打歌《忘情水》获得第17届十大中文金曲奖、十大劲歌金曲最受欢迎国语歌曲金奖、第1届华语榜中榜Channel [V]中文Top 20榜中榜歌曲奖 [137] [291-292] 。8月6日至25日，在香港红磡体育馆举行20场演唱会。11月25日，发行普通话专辑《天意》；专辑中表达友情的主打歌曲《友谊历久一样浓》是刘德华个人填词的作品 [293] 。同年，获得十大劲歌金曲奖最受欢迎男歌手奖 [292] 。1995年，加入艺能动音唱片公司。同年，首次登上央视春晚舞台，并演唱歌曲《忘情水》 [13] 。8月，发行普通话专辑《真永远》，其中的代表作是具有励志色彩的歌曲《今天》；该专辑是刘德华在音乐视角上的一个分水岭，从这张专辑开始，刘德华歌唱爱的角度开始变得多元化。此外，他还在洛杉矶、芝加哥等地举行“刘德华真永远美加巡回演唱会”。12月，发行粤语专辑《情未鸟》，同名主打歌《情未鸟》获得十大劲歌金曲奖以及第19届十大中文金曲奖。1996年，发行普通话专辑《相思成灾》，其中主打歌《相思成灾》获得第19届十大中文金曲奖优秀国语歌曲银奖。同年，在香港红磡体育馆举行20场“刘德华反转红馆倒转地球演唱会”。1997年4月，发行普通话专辑《爱如此神奇》，其中爱国主义题材的歌曲《中国人》获得十大中文金曲优秀国语歌曲金奖以及十大劲歌金曲奖。12月，发行普通话专辑《爱在刻骨铭心时》，其中的代表作《世界第一等》是刘德华第一首闽南语歌曲。同年，为迎接香港回归，刘德华与那英合唱《东方之珠》 [138-139] ；在香港回归庆典晚会上，刘德华演唱了代表作《中国人》。刘德华刘德华(12张)1998年，在中央电视台春节联欢晚会上，刘德华与张信哲、毛宁合唱歌曲《大中国》 [140] 。3月，发行粤语专辑《你是我的女人》。11月，发行曲风多元的普通话专辑《笨小孩》；其中与柯受良、吴宗宪合唱的同名主打歌《笨小孩》获得第21届十大中文金曲最受欢迎国语歌曲金奖。1999年5月，发行普通话专辑《人间爱》，并在专辑中融入中国内地的流行音乐元素。8月7日-21日，在香港红磡体育馆举行举行15场“爱你一万年演唱会”。同年，受迈克尔·杰克逊私人邀请，参加“迈克尔·杰克逊与他的好友韩国汉城慈善音乐会” [141] 。2000年8月，发行国语专辑《男人的爱》；专辑主打歌《男人哭吧不是罪》是刘德华个人填词的作品。2001年6月，发行普通话专辑《天开了》 [142] ；其中主打歌《我的心只可容纳你》由刘德华个人填词；而在演唱歌曲《偷听女孩心》时，刘德华还初次尝试了Rap曲风 [143] 。8月17日至31日，在香港红磡体育馆举行15场“夏日Fiesta演唱会”，并在演唱会现场表演了拉丁舞 [144] 。2002年7月，加入加际娱乐后的首张专辑《美丽的一天》，专辑中歌曲的灵感全部来自10个真实故事 [145] ；其中歌曲《练习》获得第二届全球华语歌曲排行榜20大金曲奖以及第25届香港十大中文金曲奖优秀国语歌曲奖 [146] 。同年，在南昌、西安等地举行中国巡回演唱会 [141] 。2003年6月，发行粤语专辑《如果有一天》，同名主打歌《如果有一天》是由刘德华个人填词的作品 [147] 。2004年8月，推出粤语专辑《Coffee or Tea》，刘德华参与其中五首歌曲的创作 [148] ；其中主打歌曲《常言道》获得第27届十大中文金曲奖 [149] 。同年，在香港十大劲歌金曲颁奖典礼上，获得最受欢迎男歌星奖。2005年，刘德华在央视春晚舞台上演唱歌曲《恭喜发财》 [150] 。8月4日，发行了普通话专辑《再说一次我爱你》 [264] ；该专辑以纯爱故事为架构，用十首歌诠释不同角色对爱情的感受 [151] 。12月13日，发行专辑《继续谈情》，其中爱情片《童梦奇缘》的主题曲《下次不敢》是刘德华个人填词的作品 [152] 。2006年8月8日，刘德华发行了粤语专辑《声音》 [265] ，这是一张关注人性的唱片 [153] ；他在该专辑中改变抒情歌曲的风格，尝试演唱摇滚曲风的歌曲《累斗累》以及R&amp;B风格的歌曲《心肝宝贝》。同年，获得十大中文金曲奖优秀流行歌手奖。2007年7月，刘德华推出了涉及爱情、环保、人生态度等主题的普通话专辑《一只牛的异想世界》 [154] 。12月5日，加入寰亚集团旗下的东亚唱片 [155] 。12月21日起，在香港红馆举行16场Wonderful World香港跨年演唱会，并在现场演唱了《一起走过的日子》、《17岁》等不同时期的代表作。同年，发行专辑《Everyone Is No.1》 [156] 。刘德华刘德华刘德华刘德华刘德华刘德华刘德华刘德华刘德华2008年1月，获得第30届十大中文金曲全国最佳男歌手奖、最优秀男歌手大奖、优秀流行歌手大奖 [157] 。2月，发行演唱会专辑《Wonderful World 香港演唱会2007》 [158] 。2009年2月，推出唱片《希望·爱》，专辑收录了励志作品《一晚长大》、情歌《未到伤心处》等作品。7月，发行粤语精选集《长途伴侣》 [159] 。同年，在广州、长沙等地举行“Wonderful World 中国巡回演唱会” [160] 。8月，为浙江卫视中国蓝打造并演唱台歌《海阔天空一路是蓝》 [161] 。同年，获得第31届十大中文金曲优秀流行歌手大奖 [162] 。2010年10月，刘德华在入行30周年之际，推出了以翻唱其他歌手歌曲为主的怀旧专辑《忘不了的》 [163] 。12月20日起，在香港红馆举行20场“Unforgettable Concert跨年演唱会”，并演唱了《谢谢你的爱》、《中国人》等代表作 [164] 。刘德华刘德华(3张)2011年，发行原声带专辑《悟》。同年，在上海、郑州等地举行Unforgettable中国巡回演唱会 [165] 。2012年，发行精选专辑《我们的刘德华》。2013年，在北京、上海等地举行“Always刘德华中国巡回演唱会” [166] 。2015年2月18日，刘德华第五次参加中央电视台春节联欢晚会，并演唱歌曲《回家的路》 [167] 。2016年，由刘德华填词并演唱的歌曲《原谅我》正式发行，这首歌曲是动作片《我的特工爷爷》的主题曲 [168] 。同年，演唱喜剧动作片《王牌逗王牌》的主题曲《笑一笑》，并为这首歌曲创作了歌词 [169] 。2017年，作词并演唱歌曲《慢慢习惯》。2020年2月，刘德华填词创作粤语歌曲《我知道》 [170] 。5月11日，参与由人民日报客户端、国家人文历史等联合发起的“致敬白衣天使”线上音乐会 [171] 。6月25日，参与中央广播电视总台端午特别节目《端午道安康》，与周笔畅演唱《我知道》 [172] 。10月27日，刘德华发行了单曲《继续美丽》，这首歌曲由刘德华亲自作词 [173] 。11月13日，刘德华演唱的电影《热血合唱团》片尾曲《谁能明白我》上线 [174] 。12月15日，刘德华发行了专辑《演·唱》，该专辑是刘德华的第一张数字专辑，其中所有原创作品均由刘德华亲自作词 [175] 。2021年2月1日，刘德华与肖央为电影《人潮汹涌》演唱的推广曲《新的一年》发布 [176] 。2月11日，参加中央广播电视总台春节联欢晚会，以云录制的方式与关晓彤、王一博表演创意节目《牛起来》 [128] 。5月6日，演唱电影《总是有爱在隔离》的主题曲《如果心里是爱》 [250] 。7月30日，发行出道40周年纪念单曲《奉陪到底》 [269] 。11月4日，发行为电影《铁道英雄》演唱的片尾主题曲《又弹起心爱的土琵琶》 [296] 。2022年1月7日，刘德华与易烊千玺演唱的电影《奇迹》宣传主题曲《还是笨小孩》正式上线。 [302-303] 2月，加盟献唱香港无线电视台推出抗疫歌曲《狮子山下同心抗疫》 [307] 。&lt;a href="#life_return"&gt;&lt;h1 id="life"&gt;个人生活&lt;/h1&gt;&lt;/a&gt;家庭刘德华的父亲刘礼在启德机场做过消防员的工作。20世纪60年代，刘礼开了一间小吃杂货店以赚钱维持家用。刘德华在家中还有三位姐姐，一位妹妹以及一位弟弟（刘德盛）。刘德华获香港树仁大学颁予荣誉文学博士刘德华获香港树仁大学颁予荣誉文学博士(7张)感情1986年，刘德华随香港明星足球队赴吉隆坡时，结识了朱丽倩。2008年6月23日，刘德华与朱丽倩在美国拉斯维加斯注册结婚 [177] 。2012年5月9日，刘德华的妻子朱丽倩生下一个女儿 [178-179] 。学历2006年7月，香港演艺学院第20届毕业典礼上，刘德华获颁香港演艺学院荣誉院士 [181] 。2017年12月14日，刘德华获香港树仁大学颁予荣誉文学博士 [180] 。&lt;a href="#works_return"&gt;&lt;h1 id="works"&gt;主要作品&lt;/h1&gt;&lt;/a&gt;参演电影 流浪地球2[295] 2023-1-22导演郭帆 主演吴京 红毯先生2023饰演刘伟驰 导演宁浩 主演刘德华 危机航线2022饰演高皓军 导演彭顺 主演张子枫 人潮汹涌2021-2-12饰演周全 导演饶晓志 主演肖央、万茜 唐人街探案32021-2-12饰演Q（客串） 导演陈思诚 主演王宝强、刘昊然 战疫天使[182] 2021导演邱礼涛 主演刘德华 金手指[183] 2021导演庄文强 主演梁朝伟、任达华 拆弹专家22020-12-24饰演潘乘风 导演邱礼涛 主演刘青云、倪妮 热血合唱团2020-11-13饰演严梓朗 导演关信辉 主演李丽珍 莫斯科大劫案2020饰演—— 导演—— 主演葛优、张涵予 香港地2020饰演—— 导演—— 主演—— 花椒之味2019-09-12饰演郭天恩 导演麦曦茵 主演郑秀文、赖雅妍、李晓峰 扫毒2：天地对决2019-07-05饰演余顺天 导演邱礼涛 主演古天乐、苗侨伟、林嘉欣 追龙2017-09-30饰演雷诺 导演刘伟强 主演甄子丹、郑则仕、胡然 侠盗联盟2017-08-11饰演张丹 导演冯德伦 主演张静初、舒淇、杨佑宁 拆弹专家2017-4-28饰演章在山 导演邱礼涛 主演姜武、小宋佳、黄宗泽 铁道飞虎2016-12-23饰演特别出演 导演丁晟 主演成龙、黄子韬、王凯 长城2016-12-18饰演王军师 导演张艺谋 主演马特·达蒙、景甜、张涵予 王牌逗王牌2016-10-01饰演宝爷 导演王晶 主演黄晓明、王祖蓝、沈腾 我的特工爷爷2016-04-01饰演李政玖 导演洪金宝 主演洪金宝、朱雨辰、李勤勤 澳门风云32016-02-08饰演刀仔 导演王晶 主演周润发、张家辉、刘嘉玲、李宇春 我的少女时代[191] 2015-11-19饰演刘德华（客串） 导演陈玉珊 主演宋芸桦、王大陆 解救吾先生2015-09-30饰演吾先生 导演丁晟 主演刘烨、王千源、吴若普 失孤2015-03-21饰演雷泽宽 导演彭三源 主演井柏然、梁家辉 风暴2013-12-12饰演吕明哲 导演袁锦麟 主演姚晨、林家栋 盲探2013-07-04饰演庄士敦 导演杜琪峰 主演郑秀文&lt;/body&gt;&lt;/html&gt; 9. 注释和特殊字符1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 我想喝咖啡 --&gt; 讲 &amp;nbsp;&amp;nbsp;&amp;nbsp; 究 &lt;br&gt; &amp;lt;p&amp;gt;是一个段落标签&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>开发</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>前端</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim的使用方法&相关配置]]></title>
    <url>%2F2022%2F03%2F24%2Fvim%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[vim的使用方法与相关配置插件的使用（后面会用到，可以先跳过不看）vim-plug插件网址：https://github.com/junegunn/vim-plug里面详细介绍了各个平台的安装的方法这里以mac系统为例子: 安装(mac终端上安装) 12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 我们的第一个插件-startify网址：https://github.com/mhinz/vim-startify 打开vimrc，终端 ~ 目录下输入：新建.vimrc配置文件 1vim .vimrc 参数说明： call plug#begin(‘~/.vim/plugged’) //插件开始 Plug ‘mhinz/vim-startify’ //以后的安装插件方式，基本就是把github链接的最后两个路径输入即可 call plug#end() //插件结束在vimrc配置文件中，输入： 12345call plug#begin(&apos;~/.vim/plugged&apos;)Plug &apos;mhinz/vim-startify&apos;call plug#end() 进入command模式： :w :source .vimrc :PlugInstall :wq 之后在终端输入： 1vim 然后就可以看到这个界面了： 如果出现打不开的情况，startify: Can&#39;t read viminfo file. Read :help startify-faq-02在终端下执行： chmod 777 .viminfo vim .viminfo :wq 即可解决 如何搜寻自己需要的插件 在 github 上搜索 网址：https://vimawesome.com 清除插件 .vimrc的command下执行： :PlugClean .vimrc文件的配置作用：让配置持久化，不用每次进入vim都要打开显示行数等的操作 在终端执行以下两个命令： cd ~ vim .vimrc .vimrc一些常用的设置 12345678910111213141516set numbersyntax on" 高亮搜索set hlsearch" 设置折叠格式set foldmethod=indent" 使用jj 进入normal模式inoremap jj &lt;Esc&gt;`^" 一些方便的映射let mapleader=','let g:mapleader=','" 使用 leader + w 直接保存inoremap &lt;leader&gt;w &lt;Esc&gt;:w&lt;cr&gt;nnoremap &lt;leader&gt;w :w&lt;cr&gt; 以下内容可以选择自己需要的补充进来： 12345678910111213141516171819202122232425262728293031323334353637383940set nocompatible &quot; 关闭 vi 兼容模式syntax on &quot; 自动语法高亮colorscheme molokai &quot; 设定配色方案set number &quot; 显示行号set cursorline &quot; 突出显示当前行set ruler &quot; 打开状态栏标尺set shiftwidth=4 &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4set softtabstop=4 &quot; 使得按退格键时可以一次删掉 4 个空格set tabstop=4 &quot; 设定 tab 长度为 4set nobackup &quot; 覆盖文件时不备份set autochdir &quot; 自动切换当前目录为当前文件所在的目录filetype plugin indent on &quot; 开启插件set backupcopy=yes &quot; 设置备份时的行为为覆盖set ignorecase smartcase &quot; 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感set nowrapscan &quot; 禁止在搜索到文件两端时重新搜索set incsearch &quot; 输入搜索内容时就显示搜索结果set hlsearch &quot; 搜索时高亮显示被找到的文本set noerrorbells &quot; 关闭错误信息响铃set novisualbell &quot; 关闭使用可视响铃代替呼叫set t_vb= &quot; 置空错误铃声的终端代码&quot; set showmatch &quot; 插入括号时，短暂地跳转到匹配的对应括号&quot; set matchtime=2 &quot; 短暂跳转到匹配括号的时间set magic &quot; 设置魔术set hidden &quot; 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存set guioptions-=T &quot; 隐藏工具栏set guioptions-=m &quot; 隐藏菜单栏set smartindent &quot; 开启新行时使用智能自动缩进set backspace=indent,eol,start&quot; 不设定在插入状态无法用退格键和 Delete 键删除回车符set cmdheight=1 &quot; 设定命令行的行数为 1set laststatus=2 &quot; 显示状态栏 (默认值为 1, 无法显示状态栏)set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\ &quot; 设置在状态行显示的信息set foldenable &quot; 开始折叠set foldmethod=syntax &quot; 设置语法折叠set foldcolumn=0 &quot; 设置折叠区域的宽度setlocal foldlevel=1 &quot; 设置折叠层数为&quot; set foldclose=all &quot; 设置为自动关闭折叠 &quot; nnoremap &lt;space&gt; @=((foldclosed(line(&apos;.&apos;)) &lt; 0) ? &apos;zc&apos; : &apos;zo&apos;)&lt;CR&gt;&quot; 用空格键来开关折叠 vim的四种模式 normal模式（进入vim后的默认模式） insert模式 command模式 visual模式 如何进入command模式normal模式下按下: 如何进入insert模式：小写： i : 在当前位置的前一个空隙插入 a： 在当前位置的后一个空隙插入 o： 在当前行的下一行插入 gi：快速进入insert模式并跳转到最后一次编辑的地方 大写： I ： 在行首插入 A： 在行尾插入 O：在当前行的上一行插入 如何进入visual模式： v: 区域选取 V：行选取 ctrl + v：块选取 退出insert/visual模式： 左上角的 ESC ctrl + [ 光标的移动基本移动 h：左移 j：右移 k：下移 l：上移 word移动 w：下一个word的开头 e：下一个word的结尾 W：下一个WORD的开头 E：下一个WORD的结尾 b：上一个word的开头 B：上一个WORD的开头 注意：WORD指的是以空格为单位进行移动 行间搜索移动在normal模式下： f + 字符 分号/逗号跳转到下一个/上一个，大写的F表示反过来搜索前面的字符 水平移动 0：移动到行首 $：移动到行尾 页面的移动 gg/G：移动到文件的开头/结尾 H/M/L：跳转到屏幕的开头(Head)/中间(Middle)/结尾(Lower) Ctrl + o：快速返回 Ctrl + u:向上翻页 Ctrl + f:向下翻页 zz：把屏幕置为中间 插件：快速移动光标 不懂如何使用插件的童鞋直接跳转到本文章的插件位置，有详细使用过程。 网址：https://github.com/easymotion/vim-easymotion 映射(快捷键 ss)： nmap ss (easymotion-s2) 复制粘贴normal模式下： y和p 进行复制 d和p 进行剪贴 yiw 复制一个单词 yy 复制一行 提示：可以进入visual模式选中要操作的区域进行复制或者剪贴的操作 insert模式下：假如粘贴代码出现缩进混乱的情况解决方案： 出现这种情况一般是因为设置了autoindent步骤： :set paste 粘贴 :set nopaste 提示：是不是感觉很麻烦？其实可以用映射来处理 寄存器其实，复制与剪切下来的内容，都被临时的放在了“无名寄存器”中我们可以利用寄存器进行复制粘贴的操作 示例： 把内容保存到寄存器： “ayiw 复制一个单词到寄存器a中 “bdd 删除当前行到寄存器b中 查看寄存器： reg + 寄存器名称 粘贴： “ap 粘贴寄存器a中的内容 “bp 粘贴寄存器b中的内容 如何将vim里的内容复制到系统剪贴板： 首先要确保系统中有 clipboard（我的vim里没有，不知道如何安装） :echo has(‘clipboard’) 结果为“1”，表示存在 一般使用v/V选择内容 “+y 表示复制到了系统剪贴板 把其他位置的内容复制到vim中： 首先要确保系统中有 clipboard :set clipboard=unnamed 直接按下p进行粘贴 删除insert模式下(linux命令行下通用)： ctrl + h：删除上一个字符 ctrl + w：删除上一个单词 ctrl + u：删除当前行光标前的所有内容 normal模式下： dd：删除当前行 x/X：删除后/前一个字符 dw：删除后一个word dW：删除后一个WORD db：删除前一个word dB：删除前一个WORD daw：删除一个单词（包括空格） diw：删除一个单词（不包括空格） dip：删除一个段落 特殊操作：12def test(): print("hello world") 移动光标到要修改的位置： viw：选中一个单词 vi + “ //选中双引号中的内容 ci + “ //删除双引号中的内容并进入插入模式 局部删除： 如果想删除（hello world）括号里面的所有内容： dt) //意思是删除，直到遇到这个括号 如果想删除光标后面的所有内容： VGd 如果想删除当前行的光标前面所有内容： d0 如果想删除当前行的光标后面所有内容： d$ 其实所有删除的命令都可以结合数字来重复执行例如： 4dd：删除下面4行 5x：删除后面5个字符 查询字符串的查询：normal 模式下: / + word：前向搜索 ? + word：后向搜索 使用n/N跳转到下一个/上一个 插件：文件的查询文件管理器网址：https://github.com/scrooloose/nerdtree快捷键：map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt; 模糊搜索器（ctrlp）网址：https://github.com/ctrlpvim/ctrlp.vim快捷键：&lt;C-p&gt; 最好提前将目录移动至根目录下，方便全局搜索 更加强大的模糊搜索工具:fzf.vim网址：https://github.com/junegunn/fzf.vim 撞上插件以后会发现Ag无法使用解决办法： mac下需要安装(直接在终端执行下面两个语句)： 123/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"brew install the_silver_searcher 然后Ag就可以使用了 centos下需要安装：在 https://github.com/ggreer/the_silver_searcher/releases 下随便找一个，拷贝连接 12345wget https://github.com/ggreer/the_silver_searcher/archive/2.2.0.tar.gztar -xf 2.2.0.tar.gzcd the_silver_searcher-2.2.0sh build.shmake install 然后进入vim执行Ag命令时有可能提示要更新，输入 y 即可，之后Ag就可以使用了语法： :Ag 回车 输入字符串 （提示：最好是提前切换好目录，不然文件太多） :Files 回车 输入文件名称 （例子：Files /hello.py ，表示从根目录下，搜索名为hello.py的文件，如果输入一个目录名字的话，会把该目录下的所有文件展示出来） 替换normal模式下的局部替换： r + 字符：替换为输入的字符 s：删除当前字符并进入插入模式 R：从左到右连续替换字符 S：删除当前行并进入插入模式 caw：删除当前单词,并进入插入模式 c + 命令有很多，可以自己研究一下：例子： t和f两个字母的含义： f:find t:till 经过我的测试可以和 v配合使用： v + f + 字符：选中后面内容直到找到那个字符(也删选中那个字符)为止 v + t + &quot;：选中后面的内容直到找到 “ （不选中”）为止 c + f + 字符：删除后面内容直到找到那个字符(也删除那个字符)为止，并进入插入模式 c + t + &quot;：删除后面的内容直到找到 “ （不删除”）为止，并进入插入模式 搜索替换格式： [range] s /{pattern}/{string}/[flags] range 表示范围 比如 10,20 表示10-20行，%表示全部 pattern 为要替换的模式，string 为替换后文本 g（global）：表示全局范围内执行 n（number）：报告匹配到的次数而不进行替换，可以用来查询匹配次数 例子： :% s/word1/word2/g 正则表达式的应用： 12def do_quack(ducker): ducker.quack() 这种情况下只想替换函数里面的quack，而不替换函数名称包含quack的do_quack话，可以这样做： :% s/\&lt;quack\&gt;/word/g 插件vim-surround（成对替换）快速替换，添加，删除 单引号，双引号等网址：https://github.com/tpope/vim-surround 语法： ds 删除 cs 替换 ys 添加 例子： print(“hello world”) #ds &quot; print(“hello world”) #cs &quot; &#39; print(hello world) 其中有很多空格的话用这个 ys vf) &quot;这一种光标要移动到句子开头 只有一个单词的话用这个 ys iw &quot; 多文件批量替换网址：https://github.com/brooth/far.vim 语法： :Far {被替换的词} {要替换成的词} 路径 注意，只能替换输入的路径中的文件内容，比如输入 / ，并不是替换根目录下的全部包括其下所有目录中的文件，而是只替换根目录下的文件内容*例子： vim /tmp/hello.py print(“hello world”) :Far hello hi /tmp/*.py 或者 :Far hello hi /tmp/ :Fardo //确认替换 多文件操作首先提一个概念-Buffer： Buffer 是指打开的一个文件的内存缓冲区 窗口是buffer可视化的分割区域 tab 可以组织窗口为一个工作区 在文件中的修改都是针对内存中的缓冲区，并不会直接保存到文件 直到我们执行 :w 的时候才会把修改内容写入到文件里 如何切换Buffer： :ls //查看缓冲区 :b n //跳转到第n个缓冲区 :bpre //跳转到上一个缓冲区 :bnext //跳转到下一个缓冲区 :bfirst //跳转到第一个缓冲区 :blast //跳转到最后一个缓冲区 :b buffer_name + tab补全 如何在一个buffer中打开其他的文件： :e 文件名 窗口：一个缓冲区可以分割成多个窗口，每个窗口也可以打开不同缓冲区 &lt;Ctrl + w&gt;s 水平分割 //或者sp &lt;Ctrl + w&gt;v 垂直分割 //或者vs 切换窗口： &lt;Ctrl + w&gt;w //循环切换窗口 &lt;Ctrl + w&gt;h/j/k/l //左/下/上/右切换窗口 移动窗口： &lt;Ctrl + w&gt;H/L //左右移动窗口 标签页 :tabe + filename //在新的标签页中打开文件 :T //把当前窗口移动到一个新标签页 :tabc //关闭当前标签页及其中的所有窗口 :tabo //只保留活动标签页，关闭其他所有标签页 gt //切换标签页 “宏”的使用方法宏就像是拍电影😂 q（开始） + 寄存器名称 + {操作} + q（退出） 例子：给所有的行首尾加上双引号： 123456789101112www.baidu.comwww.baidu.comwww.baidu.comwww.baidu.comwww.baidu.comwww.baidu.comwww.baidu.comwww.baidu.comwww.baidu.comwww.baidu.comwww.baidu.comwww.baidu.com 录制过程： qaI&quot;&lt;Esc&gt;A&quot;&lt;Esc&gt;q 录制完成后输入 @a 即可给光标所在行执行相同的操作 问题：这样一行一行的重复操作很麻烦，怎么办呢？ 方法： VG 把光标下的所有行选中 进入command模式 :normal @a 即可给所有行执行相同的操作屌不屌🐂 补全ctrl + n/p 补全单词ctrl + xf 补全文件名 补充：插入当前文件名 :r! echo %插入当前文件完整路径 :r! echo %:p 映射递归映射（极度不推荐，有可能会出现map连锁）进入command模式下： :map - x //按下 - 等于 x 来删除字符 :map viw //按下空格选中单词 :map dd //按下 ctrl + d 来删除一行 map默认下是normal下的映射 nmap //normal模式下的map vmap //visual模式下的map imap //insert模式下的map 之所以不推荐使用递归的map，是因为以下这种情况map - ddmap \ - 非递归映射（用这个即可） nnoremap inoremap vnoremap vim的配色和美化配色方法： :colorscheme 显示当前的主题配色，默认是default :colorscheme 显示所有的配色 :colorscheme + 名称 更换配色 插件美化状态栏美化插件：网址：https://github.com/vim-airline/vim-airline 代码缩进线网址：https://github.com/yggdroot/indentline]]></content>
      <categories>
        <category>Linux</category>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sed的使用方法]]></title>
    <url>%2F2022%2F02%2F03%2Fsed%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[sed的使用方法sed文本处理：正则选定文本 -&gt; sed进行处理 sed处理后并不会改变其内容 格式命令行格式1sed [options] 'command' file(s) 主要参数： options: -e,-n command: 行定位（正则）+ sed命令（操作） 示例： 123sed -n '/root/p'sed -e '10,20d' -e 's/false/true/g' 脚本格式1sed -f scriptfile file(s) 基本操作命令注意：增删改查等操作并不会真的修改文件本身，只是对输出进行修改而已 p : 打印相关的行 a : 新增行并输出（与vim的命令类似） i : 插入行（与vim的命令类似） c : 代替行（与vim的命令类似） d : 删除行（与vim的命令类似） s : 替换（核心参数） | g : 全局 p对passwd文件进行打印 1sed 'p' passwd 但是你会发现这样直接打印出的结果所有行会被输出两次 应该加上-n参数 1sed -n 'p' passwd a（后）在第5行后添加分隔符 1nl passwd | sed '5a=========================' 在第1-4行后添加分隔符 1nl passwd | sed '1,4a=========================' i（前）在第5行前添加分隔符 1nl passwd | sed '5i=========================' 在第1-4行前添加分隔符 1nl passwd | sed '1,4i=========================' c对第10行进行替换 1nl passwd | sed '10c hello' 对第1-10行进行替换 1nl passwd | sed '1,10c hello' 结果： 12345678910111213hello 11 games:x:12:100:games:/usr/games:/sbin/nologin 12 ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin 13 nobody:x:99:99:Nobody:/:/sbin/nologin 14 systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin 15 dbus:x:81:81:System message bus:/:/sbin/nologin 16 polkitd:x:999:997:User for polkitd:/:/sbin/nologin 17 abrt:x:173:173::/etc/abrt:/sbin/nologin 18 tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin 19 postfix:x:89:89::/var/spool/postfix:/sbin/nologin 20 chrony:x:998:996::/var/lib/chrony:/sbin/nologin 21 sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin 22 mysql:x:27:27:MySQL Server:/var/lib/mysql:/bin/bash 你会发现并不是一行行的进行替换，而是整体的替换为一个 d删除第10行 1nl passwd | sed '10d' ###s 将passwd文件每一行中的nologin替换为login 1sed 's/nologin/login/' passwd 注意：不要忽略上面示例命令中的每一个/ 将passwd文件中的每一个:替换为% 1sed 's/:/%/' passwd 结果为： 12345678910111213141516171819202122root%x:0:0:root:/root:/bin/bashbin%x:1:1:bin:/bin:/sbin/nologindaemon%x:2:2:daemon:/sbin:/sbin/nologinadm%x:3:4:adm:/var/adm:/sbin/nologinlp%x:4:7:lp:/var/spool/lpd:/sbin/nologinsync%x:5:0:sync:/sbin:/bin/syncshutdown%x:6:0:shutdown:/sbin:/sbin/shutdownhalt%x:7:0:halt:/sbin:/sbin/haltmail%x:8:12:mail:/var/spool/mail:/sbin/nologinoperator%x:11:0:operator:/root:/sbin/nologingames%x:12:100:games:/usr/games:/sbin/nologinftp%x:14:50:FTP User:/var/ftp:/sbin/nologinnobody%x:99:99:Nobody:/:/sbin/nologinsystemd-network%x:192:192:systemd Network Management:/:/sbin/nologindbus%x:81:81:System message bus:/:/sbin/nologinpolkitd%x:999:997:User for polkitd:/:/sbin/nologinabrt%x:173:173::/etc/abrt:/sbin/nologintss%x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologinpostfix%x:89:89::/var/spool/postfix:/sbin/nologinchrony%x:998:996::/var/lib/chrony:/sbin/nologinsshd%x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinmysql%x:27:27:MySQL Server:/var/lib/mysql:/bin/bash 每一行只替换了开头第一个冒号，这并不是我们想要得到的最后结果怎么解决？需要进行全局的替换操作 1sed 's/:/%/g' passwd 结果为： 12345678910111213141516171819202122root%x%0%0%root%/root%/bin/bashbin%x%1%1%bin%/bin%/sbin/nologindaemon%x%2%2%daemon%/sbin%/sbin/nologinadm%x%3%4%adm%/var/adm%/sbin/nologinlp%x%4%7%lp%/var/spool/lpd%/sbin/nologinsync%x%5%0%sync%/sbin%/bin/syncshutdown%x%6%0%shutdown%/sbin%/sbin/shutdownhalt%x%7%0%halt%/sbin%/sbin/haltmail%x%8%12%mail%/var/spool/mail%/sbin/nologinoperator%x%11%0%operator%/root%/sbin/nologingames%x%12%100%games%/usr/games%/sbin/nologinftp%x%14%50%FTP User%/var/ftp%/sbin/nologinnobody%x%99%99%Nobody%/%/sbin/nologinsystemd-network%x%192%192%systemd Network Management%/%/sbin/nologindbus%x%81%81%System message bus%/%/sbin/nologinpolkitd%x%999%997%User for polkitd%/%/sbin/nologinabrt%x%173%173%%/etc/abrt%/sbin/nologintss%x%59%59%Account used by the trousers package to sandbox the tcsd daemon%/dev/null%/sbin/nologinpostfix%x%89%89%%/var/spool/postfix%/sbin/nologinchrony%x%998%996%%/var/lib/chrony%/sbin/nologinsshd%x%74%74%Privilege-separated SSH%/var/empty/sshd%/sbin/nologinmysql%x%27%27%MySQL Server%/var/lib/mysql%/bin/bash ok,这样就解决了（形式跟vim的替换神似啊朋友们🤯） 行定位定位一行： x（行号） /pattern/（正则） x（行号）示例： 1sed -n '10p' passwd 如何确认是不是第十行呢？可以这样做： 1nl passwd | sed -n '10p' /pattern/（正则）如何打印包含特定字符有关的行呢？比如你想在passwd文件中找到有root的行 1sed -n '/root/p' passwd 定位n行： x,y（行号） /pattern/,/root/ x,y!（取反） first~step（first表示从第几行开始，step表示间隔几行输出） x,y（行号）假如你想打印第10-20行 1nl passwd | sed -n '10,20p' 结果如下： 123456789101110 operator:x:11:0:operator:/root:/sbin/nologin11 games:x:12:100:games:/usr/games:/sbin/nologin12 ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin13 nobody:x:99:99:Nobody:/:/sbin/nologin14 systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin15 dbus:x:81:81:System message bus:/:/sbin/nologin16 polkitd:x:999:997:User for polkitd:/:/sbin/nologin17 abrt:x:173:173::/etc/abrt:/sbin/nologin18 tss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin19 postfix:x:89:89::/var/spool/postfix:/sbin/nologin20 chrony:x:998:996::/var/lib/chrony:/sbin/nologin /pattern/,/root/如果想要通过正则表达式的方式输出第10-20行可以这样做： 1nl passwd | sed -n '/operator/,/chrony/p' 你会发现，结果跟上面的命令结果一样OK x,y!（取反）其实也可以通过取反的方式输出行 比如你不想输出第十行可以这样写： 1nl passwd | sed -n '10!p' 或者说你不想输出第10-20行可以这样写： 1nl passwd | sed -n '10,20!p' first~step间隔指定行数进行输出比如从第一行开始每隔一行进行输出 1nl passwd | sed -n '1~2p' 练习（1）案例一：增加文件内容在qq.txt文件中加入相应文本：Port 52113PermitRootLogin noPermitEmptyPasswords no 1sed '$a port52113 \npermitrootlogin no' qq.txt 假如说加入的这两行没有跟文本对齐可以这样做： 1sed '$a \ port52113 \n permitrootlogin no' qq.txt 这样就在两行的前面各加上了四个空格其中$a后面的\是转义字符，是为了与语句的空格区别开,\n表示换行 案例二：文本处理删除文本中的空行 在qq.txt文件中随便加上几个空行，保存退出 1sed '/^$/d' qq.txt 案例三：服务器日志处理1cat /var/log/yum.log 找出install信息 1sed -n '/install/p' /var/log/yum.log 案例四：数据筛选获取网卡的ip信息 首先看一下网卡的信息 1ifconfig 结果为： 123456789101112131415161718ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.43.254 netmask 255.255.255.0 broadcast 192.168.43.255 inet6 2409:8910:608:bee0:43c2:af5d:e823:ff1b prefixlen 64 scopeid 0x0&lt;global&gt; inet6 fe80::d127:5715:bfe1:fad8 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:d2:af:1d txqueuelen 1000 (Ethernet) RX packets 564525 bytes 625035188 (596.0 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 280887 bytes 24583679 (23.4 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1 (Local Loopback) RX packets 44 bytes 3964 (3.8 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 44 bytes 3964 (3.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 然后利用替换把不需要的部分替换为空 1ifconfig ens33 | sed -n '/inet /p' | sed 's/inet //' | sed 's/ net.*//' 高级操作命令 {} : 允许同时使用多个sed命令，用;分隔 n : 读取下一个输入行（用下一个命令处理） &amp; : 具体作用看示例 () : 与替换操作结合使用效果更佳呦 r : 复制指定文件插入到匹配行 w : 复制匹配行拷贝指定文件里 q : 退出sed {}将第10-20行删除并且把所有nologin替换为login 1nl passwd | sed '&#123;10,20d;s/nologin/login/g&#125;' n其实n的用处跟first~step类似，只不过比它高级（装逼）😏 示例： 输出偶数行： 12nl passwd | sed -n '&#123;n;p&#125;'nl passwd | sed -n '2~2p' 输出奇数行： 12nl passwd | sed -n '&#123;p;n&#125;'nl passwd | sed -n '1~2p' 按照1，4，7，10进行输出 12nl passwd | sed -n '&#123;p;n;n&#125;'nl passwd | sed -n '1~3p' 按照3，6，9，12进行输出 12nl passwd | sed -n 'n;n;p'nl passwd | sed -n '3~3p' 按照2，5，8，11进行输出 12nl passwd | sed -n 'n;p;n'nl passwd | sed -n '2~3p' &amp;将passwd文件中的用户名称后面加上一些空格 1nl passwd | sed 's/[a-zA-Z_-]\+/&amp; /' 结果为： 123456789101112131415161718192021221 root :x:0:0:root:/root:/bin/bash 2 bin :x:1:1:bin:/bin:/sbin/nologin 3 daemon :x:2:2:daemon:/sbin:/sbin/nologin 4 adm :x:3:4:adm:/var/adm:/sbin/nologin 5 lp :x:4:7:lp:/var/spool/lpd:/sbin/nologin 6 sync :x:5:0:sync:/sbin:/bin/sync 7 shutdown :x:6:0:shutdown:/sbin:/sbin/shutdown 8 halt :x:7:0:halt:/sbin:/sbin/halt 9 mail :x:8:12:mail:/var/spool/mail:/sbin/nologin 10 operator :x:11:0:operator:/root:/sbin/nologin 11 games :x:12:100:games:/usr/games:/sbin/nologin 12 ftp :x:14:50:FTP User:/var/ftp:/sbin/nologin 13 nobody :x:99:99:Nobody:/:/sbin/nologin 14 systemd-network :x:192:192:systemd Network Management:/:/sbin/nologin 15 dbus :x:81:81:System message bus:/:/sbin/nologin 16 polkitd :x:999:997:User for polkitd:/:/sbin/nologin 17 abrt :x:173:173::/etc/abrt:/sbin/nologin 18 tss :x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin 19 postfix :x:89:89::/var/spool/postfix:/sbin/nologin 20 chrony :x:998:996::/var/lib/chrony:/sbin/nologin 21 sshd :x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin 22 mysql :x:27:27:MySQL Server:/var/lib/mysql:/bin/bash 案例一：大小写转换 将用户名的首字母转换为大写/小写 知识点：元字符\u\I\U\L : 转换为大写/小写 1nl passwd | sed 's/[a-z_-]\+/\u&amp;/' passwd 案例二：大小写转换 将文件夹下的.txt文件名转换为大写 首先看一下我的当前目录下有什么.txt文件 1ls *.txt 结果为： 1qq.txt test.txt 那么接下来进行操作吧 1ls *.txt | sed 's/\w\+/\U&amp;/' 结果为： 12QQ.txtTEST.txt 也许你会奇怪为什么后面的txt没有被大写其实是因为\w并不包括.，所以后面的内容便不再进行替换 ()与练习（1）中的案例四一样，获取网卡的ip只不过方式有一些不同究竟不同在哪里请看例子(其实是我也迷迷糊糊，说不明白)… 1ifconfig ens33 | sed -n '/inet /p' | sed 's/inet \([0-9.]\+\).*$/\1/' 大概来说一下吧，我的理解是被()括起来的部分会被保留，其余的会被替换为空白此处只有一对()，所以后面要替换的位置只有一个\1假如命令中有两处被括号括起来，也就是说有两个地方想要被保留下来，那么后面要替换的位置就要这样写\1\2究竟如何，我也不知道，先这样吧。 看一个案例吧… 案例：获取passwd文件信息 获取用户的名字，id，和组id 1sed 's/^\([a-z_-]\+\):x:\([0-9]\+\):\([0-9]\+\).*$/USER:\1 \t ID:\2 \t UID:\3/' passwd r在开始解析r的使用方法之前，首先创建两个文件 12echo -e '3253152514\n12425352\n124135532355' &gt; 123.txtecho -e 'sdafaefasf\nfsafsffef\nsffdaawwa' &gt; abc.txt 目标：将123.txt中的内容放入到abc.txt的内容的第一行后进行输出（不会改变原文件的内容） 1sed '1r 123.txt' abc.txt w目标1：将abc.txt中的第一行文件改写到123.txt文件中 1sed '1w 123.txt' abc.txt 目标2:将abc.txt中的全部内容文件改写到123.txt文件中 1sed 'w 123.txt' abc.txt 你有没有发现w的写入操作是将被改写的文件内容全部覆盖？ q目标：passwd文件中找到第一个nologin就停止输出 1nl passwd | sed '/nologin/q']]></content>
      <categories>
        <category>Linux</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux - top命令详解]]></title>
    <url>%2F2021%2F10%2F31%2FLinux-top%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[top命令介绍top 命令是 Linux 下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于 Windows 的任务管理器。 top用于动态监控进程所占系统资源，每隔3秒变一次。这个命令的特点是把占用系统资源（CPU，内存，磁盘IO等）最高的进程放到最前面。top命令打印出了很多信息，包括系统负载（loadaverage）、进程数（Tasks）、cpu使用情况、内存使用情况以及交换分区使用情况。 命令内容详解 第一行: 1234top - 04:25:26 当前系统时间up 3 min, 系统已经运行的时间（不间歇的运行）1 user, 当前登录系统的用户数load average: 0.01, 0.03, 0.00 平均负载，三个数分别表示1分钟、5分钟、15分钟的平均负载数 load average 表示时间段内活动的进程数，这些值越大就说明你的服务器压力越大。一般情况下这个值只要不超过服务器的cpu数量就没有关系。如果长时间超出了cpu数量那就要关注一下了。 第二行: 123456Tasks: 任务97 total, 共有进程数1 running, 正在运行的进程数96 sleeping, 休眠状态下的进程数0 stopped, 停止状态的进程数0 zombie 僵尸进程数 第三行: 123456789Cpu(s): cpu状态0.0%us, 用户占用的cpu时间百分比0.0%sy, 系统占用的cpu时间百分比0.0%ni, 改变优先级的进程占用cpu时间百分比99.8%id, cpu处于空闲状态的时间百分比0.0%wa, I/O等待所占用的cpu时间百分比0.2%hi, 硬中断（Hardware IRQ）占用CPU的百分比0.0%si, 软中断（Software Interrupts）占用CPU的百分比0.0%st 被偷走的cpu所占百分比（一般都为0，不用关注） 第四行: 12345Mem: 内存状态1030416k total, 物理内存总量 79928k used, 被使用的内存950488k free, 空闲的内存10308k buffers 缓冲大小（即将写入磁盘的） 第五行: 12345Swap: 交换分区2047996k total, 交换区总量 0k used, 使用的大小2047996k free, 空闲的大小36296k cached 缓存大小（从磁盘中读取的） 第六行(空) 第七行: 123456789101112PID 进程idUSER 进程所属的用户PR 进程优先级NI 进程优先值（nice值）VIRT 进程使用的虚拟内存总量，单位为kbRES 进程使用的、未被换出的物理内存大小，单位kbSHR 共享内存S 进程状态%CPU 上次更新到现在的CPU时间占用百分比%MEM 进程使用的物理内存百分比TIME+ 进程使用的CPU时间总计，单位1/100秒COMMAND 进程名称（命令名/命令行） 其中，PR为进程的实时优先级（跟内核有关），范围0-99，数字越小优先级越低； nice值的范围为 -20-19 ，这个值越小，那么对应的进程优先级越高，在top里，PR-NI=20， 默认启动一个进程，nice是0； S进程状态：D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程。 在日常的运维中关注的较多的项是 ：%CPU, %MEM, COMMAND 这三个，需要多注意。 在top状态下，按键盘数字“1”，可监控每个逻辑CPU的状况： 在 top 状态下，按 “shift + m”, 可以按照内存使用大小排序 top -bn1 它表示非动态打印系统资源使用情况，即一次性全部把所有信息输出出来而非动态显示，可以用在shell脚本中top -c 最右侧的命令可以显示更详细的信息]]></content>
      <categories>
        <category>Linux</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker学习笔记-进阶篇]]></title>
    <url>%2F2021%2F09%2F21%2FDocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Docker 镜像镜像是什么镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 UnionFS（联合文件系统） UnionFS（联合文件系统） Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 特性 一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 Docker镜像加载原理docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？🤔🤔🤔 对于一个精简的OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。 分层的镜像以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载为什么 Docker 镜像要采用这种分层结构呢? 最大的一个好处就是 - 共享资源 比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。 哇塞,好牛笔的设计啊! 🙂😀😄😁😂🤣… 镜像特点Docker镜像都是只读的 当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作容器层，容器层之下的都叫镜像层。 镜像commit操作补充docker commit 提交容器副本使之成为一个新的镜像 格式:docker commit -m=“提交的描述信息” -a=“作者” 容器ID(或者容器的名字) 要创建的目标镜像名:[标签名tags] 案例演示 从Hub上下载tomcat镜像到本地并成功运行 12345docker run -it -p 8080:8080 --name="tomcat_test" tomcat /bin/bash#-p 主机端口:docker容器端口#-P 随机分配端口#i:交互#t:终端 故意删除上一步镜像生产tomcat容器的文档 1234567891011#进入tomcat运行容器中docker exec -it tomcat_test /bin/bash#查看当前目录下的所有文件ls#删除docs文档rm -rf docs#退出exit 也即当前的tomcat运行实例是一个没有文档内容的容器， 以它为模板commit一个没有doc的tomcat新镜像del_docs_tomcat 1docker commit -a="shang-code" -m="delete docs tomcat" tomcat_test del_docs_tomcat:1.2 启动我们的新镜像并和原来的对比 1docker run -p 8888:8080 del_docs_tomcat /bin/bash 在本地浏览器中输入当前机器的ip:端口号 新的del_docs_tomcat，它没有docs原来的tomcat，它有docs 数据卷直接命令添加 格式: docker run -it -v /宿主机目录:/容器内目录 镜像名 例子: docker run -it -v /宿主机目录:/容器内目录 centos /bin/bash 查看数据卷是否挂载成功: docker inspect 容器ID 容器和宿主机之间数据共享容器停止退出后，主机修改映射的目录中的内容后,再次开启该容器,对应的目录也会发生变化两者之间是同步的 命令(带权限)docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名 ro: read only(只读模式) 意思就是说,容器只能读取本地的映射目录,而不能修改它了 感兴趣的童鞋自己尝试一下吧,挺有意思的୧(๑•̀◡•́๑)૭ 数据卷容器共享同一个或几个卷目录 数据卷容器是什么命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为数据卷容器 容器间传递共享(–volumes-from) 案例 利用 Dockerfile 新建一个镜像 1234567891011121314151617181920#1.1 新建一个目录mkdir centos#1.2 切换到该目录内cd centos#1.3 编写一个Dockerfile文件vim Dockerfile FROM centos VOLUME ["dataVolumeContainer1","dataVolumeContainer2"] CMD echo "--------------success---------------" CMD ["/bin/bash"]#1.4 建立build镜像docker build -t centos_volume .#1.5 运行这个新建的镜像#按下 ctrl+q+p不停止容器退出docker run -it --name=centos_volume centos_volumels 利用 –volimes-from 随便运行两个容器,都继承上面👆这个容器 1234#都是按下 ctrl+q+p不停止容器退出docker run -it --name=centos_volume1 --volumes-from=centos_volume centos_volumedocker run -it --name=centos_volume2 --volumes-from=centos_volume centos_volume 查看三个容器是否都在运行 1docker ps freeStyle 随便(增/删/改)哪一个容器中dataVolumeContainer目录里面的内容,你会发现目录中的内容都是随时同步的,而且并不会因为某一个容器的删除或停止而产生数据丢失 结论：容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker学习笔记-基础篇]]></title>
    <url>%2F2021%2F09%2F21%2FDocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[docker是什么为什么会有docker出现一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 之前在服务器配置一个应用的运行环境，要安装各种软件，就拿尚硅谷电商项目的环境来说吧，Java/Tomcat/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。 传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。 docker理念Docker是基于Go语言实现的云开源项目。 Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作 总结:解决了运行环境和配置问题软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。 docker能干什么以前的虚拟化技术虚拟机（virtual machine）就是带环境安装的一种解决方案。 它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。 虚拟机的缺点： 资源占用多 冗余步骤多 启动慢 容器虚拟化技术由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。比较了 Docker 和传统虚拟化方式的不同之处： 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。 开发/运维（DevOps）一次构建、随处运行 更快速的应用交付和部署:传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。 更便捷的升级和扩缩容:随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。 更简单的系统运维:应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。 更高效的计算资源利用:Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。 Docker的基本组成 镜像（image） Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 容器（container） Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。 它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 仓库（repository） 仓库（Repository）是集中存放镜像文件的场所。 仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 最大的公开仓库是 Docker Hub(https://hub.docker.com/)， 存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等 小总结需要正确的理解仓储/镜像/容器这几个概念: Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 文件生成的容器实例，本身也是一个文件，称为镜像文件。 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器 至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。 CentOS7安装Docker官方文档:https://docs.docker.com/install/linux/docker-ce/centos/ 安装步骤: 确定你是CentOS7及以上版本1cat /etc/redhat-release 卸载旧版本(没有安装过的童鞋请跳过此步骤)12345678sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine 必要设置12345678910111213sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.reposudo yum-config-manager --enable docker-ce-nightlysudo yum-config-manager --enable docker-ce-testsudo yum-config-manager --disable docker-ce-nightly 安装docker-ce1sudo yum -y install docker-ce docker-ce-cli containerd.io 静静等待一段时间… 启动docker12systemctl start dockersystemctl enable docker 查看docker12docker versiondocker info 设置镜像加速阿里云网址:https://www.aliyun.com 使用支付宝或者淘宝扫码登录后,在搜索栏中搜索镜像服务,即可列出参考选项容器镜像服务,点击进去,点击管理控制台 在左边一栏的最下边点击镜像加速器,找到centos,复制里面的所有命令,粘贴到终端运行即可 运行hello-world12docker pull hello-worlddocker run hello-world 底层原理 Docker是怎么工作的 Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。 为什么Docker比较比VM快 (1)docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 (2)docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。 镜像命令查看本地镜像123#列出本地主机上的镜像#格式:docker images [OPTIONS]docker images 各个选项说明:REPOSITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像 OPTIONS说明： -a :列出本地所有的镜像（含中间映像层） -q :只显示镜像ID。 –digests :显示镜像的摘要信息 –no-trunc :显示完整的镜像信息 搜索镜像1234#从官网仓库中搜索镜像#格式:docker search [OPTIONS] 镜像名字#docker search centos 网站:https://hub.docker.com OPTIONS说明： –no-trunc : 显示完整的镜像描述 -s : 列出收藏数不小于指定值的镜像。 –automated : 只列出 automated build类型的镜像； 下载镜像123#拉取镜像到本地#格式:docker pull 镜像名称docker pull centos 删除镜像12345678#格式:docker rmi 某个XXX镜像名字ID#删除镜像:#删除单个 docker rmi -f 镜像ID#删除多个 docker rmi -f 镜像名1:TAG 镜像名2:TAG #删除全部 docker rmi -f $(docker images -qa) 容器命令有镜像才能创建容器，这是根本前提(下载一个CentOS镜像演示) 1docker pull centos 新建并启动容器docker run [OPTIONS] IMAGE [COMMAND] [ARG…] OPTIONS说明（常用）：有些是一个减号，有些是两个减号 –name=”容器新名字”: 为容器指定一个名称； -d: 后台运行容器，并返回容器ID，也即启动守护式容器； -i：以交互模式运行容器，通常与 -t 同时使用； -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用； -P: 随机端口映射； -p: 指定端口映射，有以下四种格式 ip:hostPort:containerPort ip::containerPort hostPort:containerPort containerPort 启动交互式容器12#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。docker run -it centos /bin/bash 列出当前所有正在运行的容器docker ps [OPTIONS] OPTIONS说明（常用）： -a :列出当前所有正在运行的容器+历史上运行过的 -l :显示最近创建的容器。 -n：显示最近n个创建的容器。 -q :静默模式，只显示容器编号。 –no-trunc :不截断输出。 退出容器两种退出方式 exit 容器停止退出 ctrl+P+Q 容器不停止退出 启动容器1docker start 容器ID或者容器名 重启容器1docker restart 容器ID或者容器名 停止容器1docker stop 容器ID或者容器名 强制停止容器1docker kill 容器ID或者容器名 删除已停止的容器12345docker rm 容器ID#一次性删除多个容器:docker rm $(docker ps -a -q) #删除停止的容器docker rm -f $(docker ps -a -q) #删除所有的容器(强力删除)docker ps -a -q | xargs docker rm 启动守护式容器123#格式docker run -d 容器名#使用镜像centos:latest以后台模式启动一个容器docker run -d centos 问题：docker ps -a 进行查看, 会发现容器刚刚运行的容器已经退出why?很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。 这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。 解决办法: 1docker run -d centos /bin/bash -c "while true;do echo hello docker;sleep 2;done" 查看容器日志12#格式:docker logs [OPTIONS] 容器IDdocker logs -f -t --tail dsf24dsdf242 OPTIONS选项: -t 是加入时间戳 -f 跟随最新的日志打印 –tail 数字 显示最后多少条 查看容器内运行的进程1docker top 容器ID 查看容器内部细节1docker inspect 容器ID 进入正在运行的容器并以命令行交互1docker exec -it 容器ID bashShell 重新进入 1docker attach 容器ID 上述两个区别: attach 直接进入容器启动命令的终端，不会启动新的进程 exec 是在容器中打开新的终端，并且可以启动新的进程 从容器内拷贝文件到主机上1docker cp 容器ID:容器内路径 目的主机路径 小结常用命令 12345678910111213141516171819202122232425262728293031323334353637attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像commit Create a new image from a container changes # 提交当前容器为新的镜像cp Copy files/folders from the containers filesystem to the host path #从容器中拷贝指定文件或者目录到宿主机中create Create a new container # 创建一个新的容器，同 run，但不启动容器diff Inspect changes on a container&apos;s filesystem # 查看 docker 容器变化events Get real time events from the server # 从 docker 服务获取容器实时事件exec Run a command in an existing container # 在已存在的容器上运行命令export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ]history Show the history of an image # 展示一个镜像形成历史images List images # 列出系统当前镜像import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info Display system-wide information # 显示系统相关信息inspect Return low-level information on a container # 查看容器详细信息kill Kill a running container # kill 指定 docker 容器load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器logout Log out from a Docker registry server # 从当前 Docker registry 退出logs Fetch the logs of a container # 输出当前容器日志信息port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口pause Pause all processes within a container # 暂停容器ps List containers # 列出容器列表pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器restart Restart a running container # 重启运行的容器rm Remove one or more containers # 移除一个或者多个容器rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run Run a command in a new container # 创建一个新的容器并运行一个命令save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load]search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像start Start a stopped containers # 启动容器stop Stop a running containers # 停止容器tag Tag an image into a repository # 给源中镜像打标签top Lookup the running processes of a container # 查看容器中运行的进程信息unpause Unpause a paused container # 取消暂停容器version Show the docker version information # 查看 docker 版本号wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix部署与使用记录]]></title>
    <url>%2F2021%2F01%2F18%2Fzabbix%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Zabbix 介绍Zabbix 由 Alexei Vladishev 创建，目前由其成立的公司—— Zabbix SIA 积极的持续开发更新维护， 并为用户提供技术支持服务。 Zabbix 是一个企业级分布式开源监控解决方案。 Zabbix 软件能够监控众多网络参数和服务器的健康度、完整性。Zabbix 使用灵活的告警机制，允许用户为几乎任何事件配置基于邮件的告警。这样用户可以快速响应服务器问题。Zabbix 基于存储的数据提供出色的报表和数据可视化功能。这些功能使得 Zabbix 成为容量规划的理想选择。 Zabbix 支持主动轮询（polling）和被动捕获（trapping）。Zabbix所有的报表、统计数据和配置参数都可以通过基于 Web 的前端页面进行访问。基于 Web 的前端页面确保您可以在任何地方访问您监控的网络状态和服务器健康状况。适当的配置后，Zabbix 可以在监控 IT 基础设施方面发挥重要作用。无论是对于有少量服务器的小型组织，还是拥有大量服务器的大企业而言，同样适用。 Zabbix 是免费的。Zabbix 是根据 GPL 通用公共许可证的第二版编写和发布的。这意味着产品源代码是免费发布的，可供公共使用。 Zabbix 功能Zabbix 是一个高度成熟完善的网络监控解决方案，一个的软件包中包含了多种功能。 数据采集 可用性和性能检查； 支持 SNMP（包括主动轮询和被动捕获）、IPMI、JMX、VMware 监控； 自定义检查； 按照自定义的时间间隔采集需要的数据； 通过 Server/Proxy 和 Agents 来执行数据采集。 灵活的阈值定义 您可以参考后端数据库定义非常灵活的告警阈值，即触发器高度可配置化的告警 可以根据递增计划、接收者、媒介类型自定义发送告警通知； 使用宏变量可以使告警通知变得更加高效有用； 自动操作包含远程执行命令。 实施图形 使用内置图形功能可以将监控项实时绘制成图形。 Web 监控功能 Zabbix可以追踪模拟鼠标在 Web 网站上的点击操作，来检查 Web 网站的功能和响应时间。 丰富的可视化选项 可以组合多个监控项到单个视图中，创建自定义图表； 网络拓扑图； 以仪表盘样式展示自定义聚合图形和幻灯片演示； 报表； 监控资源的更高层次展示视图（业务视图）。 历史数据存储 存储在数据库中的数据； 历史配置； 内置数据管理机制（housekeeping）。 配置简单 将被监控设备添加为主机； 主机一旦添加到数据库中，就会采集数据用于监控； 将模板用于监控设备。 使用模板 模板中分组检查； 模板可以关联模板，继承已关联模板的属性。 网络发现 自动发现网络设备； Zabbix Agent 发现设备后自动注册； 自动发现文件系统、网络接口和 SNMP OIDs 值。 快捷的 Web 界面 基于 PHP 的 Web 前端； 可以从任何地方访问； 您可以定制自己的操作方式； 您可以通过审计日志来查看你的操作。 Zabbix API Zabbix API 为 Zabbix 提供可编程接口，用于批量操作、第三方软件集成和其他用途。 权限管理系统 安全的用户身份验证； 指定的用户只能查看指定的权限范围内的视图。 强大且易于扩展的 Zabbix Agent 部署于被监控对象上； 支持 Linux 和 Windows ； 二进制守护进程 为了更好的性能和更少的内存占用，采用 C 语言编写； 便于移植。 适合更复杂的环境 使用 Zabbix Proxy 代理，可以轻松实现分布式远程监控。 Zabbix 概述架构Zabbix 由几个主要的功能组件组成，其功能介绍如下所示。 ServerZabbix server 是 Zabbix软件的核心组件，agent 向其报告可用性、系统完整性信息和统计信息。server也是存储所有配置信息、统计信息和操作信息的核心存储库。 数据库所有配置信息以及 Zabbix 采集到的数据都被存储在数据库中。 Web 界面为了从任何地方和任何平台轻松访问 Zabbix ，我们提供了基于 web 的界面。该界面是 Zabbix server 的一部分，通常（但不一定）和 Zabbix server 运行在同一台物理机器上。 ProxyZabbix proxy 可以代替 Zabbix server采集性能和可用性数据。Zabbix proxy在Zabbix的部署是可选部分；但是proxy的部署可以很好的分担单个Zabbix server的负载。 AgentZabbix agent 部署在被监控目标上，用于主动监控本地资源和应用程序，并将收集的数据发送给 Zabbix server。 数据流另外，回过头来整体的了解下 Zabbix 内部的数据流对Zabbix的使用也很重要。首先，为了创建一个采集数据的监控项，您就必须先创建主机。其次，在任务的另外一端，必须要有监控项才能创建触发器（trigger），必须要有触发器来创建动作（action）。因此，如果您想要收到类似“X个server上CPU负载过高”这样的告警，您必须首先为 Server X 创建一个主机条目，其次创建一个用于监控其 CPU的监控项，最后创建一个触发器，用来触发 CPU负载过高这个动作，并将其发送到您的邮箱里。虽然这些步骤看起来很繁琐，但是使用模板的话，实际操作非常简单。也正是由于这种设计，使得 Zabbix 的配置变得更加灵活易用。 zabbix名词解释主机 (host) 一台你想监控的网络设备，用IP或域名表示 主机组 (host group) 主机的逻辑组；它包含主机和模板。一个主机组里的主机和模板之间并没有任何直接的关联。通常在给不同用户组的主机分配权限时候使用主机组。 监控项 (item) 你想要接收的主机的特定数据，一个度量数据。 触发器 (trigger) 一个被用于定义问题阈值和“评估”监控项接收到的数据的逻辑表达式 当接收到的数据高于阈值时，触发器从“OK”变成“Problem”状态。当接收到的数据低于阈值时，触发器保留/返回一个“OK”的状态。 事件 (event) 单次发生的需要注意的事情，例如触发器状态改变或发现有监控代理自动注册 异常 (problem) 一个处在“异常”状态的触发器 动作 (action) 一个对事件做出反应的预定义的操作。 一个动作由操作(例如发出通知)和条件(当时操作正在发生)组成 升级 (escalation) 一个在动作内执行操作的自定义场景; 发送通知/执行远程命令的序列 媒介(media) 发送告警通知的手段；告警通知的途径 通知 (notification) 利用已选择的媒体途径把跟事件相关的信息发送给用户 远程命令 (remote command) 一个预定义好的，满足一些条件的情况下，可以在被监控主机上自动执行的命令 模版 (template) 一组可以被应用到一个或多个主机上的实体（监控项，触发器，图形，聚合图形，应用，LLD，Web场景）的集合 模版的任务就是加快对主机监控任务的实施；也可以使监控任务的批量修改更简单。模版是直接关联到每台单独的主机上。 应用 (application) 一组监控项组成的逻辑分组 web 场景 (web scenario) 利用一个或多个HTTP请求来检查网站的可用性 前端 (frontend) Zabbix提供的web界面 Zabbix API Zabbix API允许你使用JSON RPC协议 (是一个无状态且轻量级的远程过程调用（RPC）传送协议，其传递内容透过 JSON 为主) 来创建、更新和获取Zabbix对象（如主机、监控项、图形和其他）信息或者执行任何其他的自定义的任务 Zabbix server Zabbix软件实现监控的核心程序，主要功能是与Zabbix proxies和Agents进行交互、触发器计算、发送告警通知；并将数据集中保存等 Zabbix agent 一个部署在监控对象上的，能够主动监控本地资源和应用的程序 Zabbix agent部署在监控的目标上，主动监测本地的资源和应用(硬件驱动，内存，处理器统计等)。 Zabbix agent收集本地的操作信息并将数据报告给Zabbix server用于进一步处理。一旦出现异常 (比如硬盘空间已满或者有崩溃的服务进程), Zabbix server会主动警告管理员指定机器上的异常。. Zabbix agents 的极端高效缘于它可以利用本地系统调用来完成统计数据的收集。 被动（passive）和主动（active）检查 Zabbix agents可以执行被动和主动两种检查方式。 在passive check 模式中agent应答数据请求，Zabbix server（或者proxy）询问agent数据,如CPU 的负载情况，然后Zabbix agent回送结果。 Active checks 处理过程将相对复杂。 Agent必须首先从Zabbix sever索取监控项列表以进行独立处理，然后周期性地发送新的值给server。 执行被动或主动检查是通过选择相应的监测项目类型来配置的。item type. Zabbix agent处理监控项类型有’Zabbix agent’和’Zabbix agent (active)’。 Zabbix proxy 一个帮助Zabbix Server收集数据，分担Zabbix Server的负载的程序 Zabbix Proxy是一个可以从一个或多个受监控设备收集监控数据，并将信息发送到Zabbix sever的进程，基本上是代表sever工作的。 所有收集的数据都在本地进行缓存，然后传送到proxy所属的Zabbix sever。 部署Proxy是可选的，但是可能非常有益于分散单个Zabbix sever的负载。 如果只有proxy收集数据，sever上的进程就会减少CPU消耗和磁盘I / O负载。 Zabbix proxy是完成远程区域、分支机构、没有本地管理员的网络的集中监控的理想解决方案。 Zabbix proxy需要使用独立的数据库。 Zabbix的部署服务器规划: IP 主机名 192.168.100.161 zabbix-server 192.168.100.163 zabbix-agent 环境准备基础配置在server/agent两台服务器上进行配置 配置域名解析123echo "192.168.100.161" zabbix-server &gt;&gt; /etc/hostsecho "192.168.100.162" zabbix-proxy &gt;&gt; /etc/hostsecho "192.168.100.163" zabbix-agent &gt;&gt; /etc/hosts 配置repo源1234567891011121314151617$ cat &gt; /etc/yum.repos.d/zabbix.repo&lt;&lt;EOF[zabbix]name=Zabbixbaseurl=https://mirrors.huaweicloud.com/zabbix/zabbix/4.4/rhel/7/x86_64/enabled=1gpgcheck=0EOF# mysql用于server与proxy$ cat &gt; /etc/yum.repos.d/mysql57.repo &lt;&lt;EOF[mysql-5.7-community]name=MySQL 5.7 Community Serverbaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-5.7-community-el7-x86_64/enabled=1gpgcheck=1gpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysqlEOF 清理repo源环境并重新建立12$ yum clean all$ yum repolist 安装必要软件在server/proxy/agent上进行配置 安装fping12$ yum -y install epel-release$ yum -y install fping 在server与proxy上进行配置 安装mysql1234567891011$ yum -y install mysql-server $ systemctl start mysqld# 查看root账户的默认密码 =&gt; wIu8_wS_nXpf$ cat /var/log/mysqld.log | grep password2021-01-18T12:36:00.240888Z 1 [Note] A temporary password is generated for root@localhost: wIu8_wS_nXpf2021-01-18T12:36:20.507908Z 2 [Note] Access denied for user 'root'@'localhost' (using password: NO)# 登录mysql并修改默认root账户的密码$ mysql -uroot -pwIu8_wS_nXpfmysql&gt; alter user 'root'@'localhost' identified by 'Syz123!@#';Query OK, 0 rows affected (0.00 sec) server端配置安装zabbix以及必要环境组件12$ yum -y install zabbix-server-mysql zabbix-web-mysql $ yum -y install httpd php php-gd php-mysql 数据库授权123456789101112[root@zabbix-server ~]# mysql -uroot -p'Syz123!@#'mysql&gt; create database zabbix character set utf8 collate utf8_bin;Query OK, 1 row affected (0.00 sec)mysql&gt; grant all on zabbix.* to admin@'%' identified by 'Syz123!@#';Query OK, 0 rows affected, 1 warning (0.01 sec)mysql&gt; grant all on zabbix.* to admin@'localhost' identified by 'Syz123!@#';Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; exitBye 导入zabbix的表12$ cd /usr/share/doc/zabbix-server-mysql-4.4.10/$ zcat create.sql.gz | mysql -uroot -p'Syz123!@#' zabbix 配置zabbix文件123456$ cat /etc/zabbix/zabbix_server.conf | grep ^DBDBHost=localhostDBName=zabbixDBUser=adminDBPassword=Syz123!@#DBSocket=/var/lib/mysql/mysql.sock 修改时区12$ vim /etc/httpd/conf.d/zabbix.confphp_value date.timezone Asia/shanghai 重启服务12345$ systemctl restart zabbix-server$ systemctl restart httpd$ netstat -anltp | grep zabbixtcp 0 0 0.0.0.0:10051 0.0.0.0:* LISTEN 12490/zabbix_server tcp6 0 0 :::10051 :::* LISTEN 12490/zabbix_server 如果zabbix没有起来,那么查看日志进行问题排查 1$ cat /var/log/zabbix/zabbix_server.log 浏览器访问http://192.168.100.161/zabbix 用户:Admin密码:zabbix 设置中文 agent端配置安装zabbix-agent 1$ yum -y install zabbix-agent 修改配置文件 12345$ vim /etc/zabbix/zabbix_agentd.confServer=192.168.100.161ServerActive=192.168.100.161Hostname=zabbix-agentUnsafeUserParameters=1 # 是否限制用户自定义keys使用特殊字符 启动zabbix-agent服务 1234$ systemctl restart zabbix-agent$ netstat -antp | grep zabbixtcp 0 0 0.0.0.0:10050 0.0.0.0:* LISTEN 11809/zabbix_agentd tcp6 0 0 :::10050 :::* LISTEN 11809/zabbix_agentd Zabbix本地与远程监测修改字体在zabbix-server端进行配置 首先要有字体文件 链接: https://pan.baidu.com/s/1nRqCDa9vie1yOR67uVr0iw 密码: pql7 将字体放在 /usr/share/zabbix/assets/fonts 目录下 给字体权限 12345678910$ chmod 777 /usr/share/zabbix/assets/fonts/simkai.ttf $ vim /usr/share/zabbix/include/defines.inc.php# zabbix4.2版本之后默认访问根路径为/usr/share/zabbix/，所以字体目录改为了assets/fonts下define('ZBX_FONTPATH', realpath('assets/fonts'))define('ZBX_GRAPH_FONT_NAME','simkai');define('ZBX_FONT_NAME', 'simkai');# 重启服务$ systemctl restart zabbix-server 监控(server端)本地服务器在zabbix-server端进行配置 安装配置zabbix-agent12345678910$ yum -y install zabbix-agent# 配置agent文件$ vim /etc/zabbix/zabbix_agentd.confServer=192.168.100.161ServerActive=192.168.100.161Hostname=zabbix-serverUnsafeUserParameters=1$ systemctl restart zabbix-agent 配置zabbix页面配置 =&gt; 主机 =&gt; Zabbix Server =&gt; 修改’agent代理程序的接口’为服务器的ip =&gt; 更新 点击”更新” 大约过两分钟后,即可看到下面的效果: 监测远程服务器在zabbix-agent上进行配置 安装配置zabbix-agent首先在远程主机上安装 zabbix-agentx 1$ yum -y install zabbix-agent 修改配置文件 12345$ vim /etc/zabbix/zabbix_agentd.confServer=192.168.100.161 # server端ServerActive=192.168.100.161 # server端Hostname=zabbix-agent # agent端UnsafeUserParameters=1 重启zabbix-agent服务 1$ systemctl restart zabbix-agent 配置zabbix页面配置 =&gt; 主机群组 =&gt; 创建主机群组(右上角) =&gt; webservers =&gt; 添加 点击”添加” 配置 =&gt; 主机 =&gt; 创建主机(右上角) =&gt; 主机名称,群组(webservers),agent代理程序的接口(192.168.100.163) =&gt; 添加 监测 =&gt; 图形 =&gt; 选择(群组,主机,图形) =&gt; 观察 Zabbiz自定义item删除zabbix-agent 重新创建zabbix-agent 直接点击下面的”添加” 应用集点击”应用集” 添加应用集 =&gt; web 点击”添加” 监控项点击’监控项’ 添加监控项 =&gt; 名称:agent_net_info_in,键值:net.if.in[ens33],单位:bps,应用集:web 添加监控项 =&gt; 名称:agent_net_info_out,键值:net.if.out[ens33],单位:bps,应用集:web 触发器点击’触发器’ 添加触发器 =&gt; 名称:zabbix-agent_cpu_trigger_in 严重性:灾难 问题表现形式:{zabbix-agent:net.if.in[ens33].last()}&gt;=1.5G 恢复表达式:{zabbix-agent:net.if.in[ens33].last()}&lt;1.5G =&gt; 更新 添加触发器 =&gt; 名称:zabbix-agent_cpu_trigger_out 严重性:灾难 问题表现形式:{zabbix-agent:net.if.out[ens33].last()}&gt;=1G 恢复表达式:{zabbix-agent:net.if.out[ens33].last()}&lt;1G =&gt; 更新 图形点击’图形’ 创建图形 =&gt; 名称:zabbix-agent_net_graph 监控项-&gt;添加(zabbix-agent_net_info_in,zabbix-agent_net_info_out) =&gt; 添加 观察图形 Zabbix的动作和报警 建立顺序: 报警媒介 =&gt; 报警对象 =&gt; 条件(触发器) =&gt; 报警 本地报警创建报警媒介类型管理 =&gt; 报警媒介类型 =&gt; 创建媒介类型 =&gt; 名称:测试媒介,SMTP服务器:localhost,SMTP HELO:localhost,SMTP电邮:zabbix@localhost.com =&gt; 添加 添加用户群组管理 =&gt; 用户群组 =&gt; 创建用户群组 =&gt; 组名:shang 添加用户管理 =&gt; 用户 =&gt; 创建用户 =&gt; 别名,群组,密码 =&gt; 报警媒介 =&gt; 添加 =&gt; 类型:测试媒介 收件人:syz@localhost.localdomain =&gt; 权限 =&gt; 用户类型 =&gt; 超级管理员 =&gt; 添加 创建动作配置 =&gt; 动作 =&gt; 创建动作 =&gt; 动作 =&gt; 名称,新的触发条件:触发器-&gt;选择-&gt;添加 =&gt; 操作 =&gt; 新的:选择用户 =&gt; 恢复操作 =&gt;新的 =&gt; 更新操作 =&gt; 新的 =&gt; 添加 1234# 在server端进行操作$ useradd syz# 下载必要的软件$ yum -y install wget mailx 手动去触发触发器 例如,使用如下命令升高网络的流量 1wget http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-Everything-2009.iso 查看是否给本地用户 syz 发送了邮件 12$ su - syz$ mail 邮件报警配置邮件在server端进行配置 1234$ vim /etc/mail.rcset from=syz15822409222@126.com smtp=smtp.126.comset smtp-auth-user=syz15822409222 smtp-auth-password=MYGVECUQOJSXSLTVset smtp-auth=login 测试邮件 1234$ mail -s ceshi syz15822409222@126.comhello world.EOT 配置zabbix添加报警媒介管理 =&gt; 报警媒介类型 =&gt; 创建媒体类型 =&gt; 名称:sendmail类型:脚本脚本名称:sendmail.sh脚本参数:{ALERT.SENDTO}{ALERT.SUBJECT}{ALERT.MESSAGE} =&gt; 添加 添加用户管理 =&gt; 用户 =&gt; 创建用户 =&gt; 别名,群组,密码 =&gt; 报警媒介 =&gt; 点击添加 =&gt;类型:sendmail收件人:syz15822409222@126.com=&gt; 添加 =&gt; 权限 =&gt; 用户类型:超级管理员 创建脚本创建目录与脚本1234567891011$ mkdir /usr/share/zabbix/alertscripts$ vim /usr/share/zabbix/alertscripts/sendmail.sh##################################################################!/bin/bashecho $1 &gt;&gt; /tmp/text.txtecho $2 &gt;&gt; /tmp/text.txtecho $3 &gt;&gt; /tmp/text.txtmessages=`echo $3 | tr '\r\n' '\n'`subject=`echo $2 | tr '\r\n' '\n'`echo "$&#123;messages&#125;" | mail -s "$&#123;subject&#125;" $1 &gt;&gt;/tmp/mailx.log 2&gt;&amp;1################################################################# 赋予权限123$ chown -R zabbix.zabbix /usr/share/zabbix/alertscripts/$ chmod a+x /usr/share/zabbix/alertscripts/sendmail.sh$ chmod 777 /tmp/text.txt /tmp/mailx.log 修改zabbix脚本路径12$ vim /etc/zabbix/zabbix_server.confAlertScriptsPath=/usr/share/zabbix/alertscripts 重启server服务1$ systemctl restart zabbix-server 测试脚本12$ cd /usr/share/zabbix/alertscripts/$ ./sendmail.sh syz15822409222@126.com 1111 2222 添加动作配置 =&gt; 动作 =&gt; 创建动作 =&gt; 名称:send to mail,条件:自己选触发器即可 =&gt; 操作:消息内容-&gt;告警主机: {HOST.NAME}告警IP: {HOST.IP}告警时间: {EVENT.DATE}-{EVENT.TIME}告警等级: {TRIGGER.SEVERITY}告警信息: {TRIGGER.NAME}问题详情: {ITEM.NAME}:{ITEM.VALUE}事件ID: {EVENT.ID} 新的:发送到用户仅送到 点击”添加” =&gt; 恢复操作 =&gt; 消息内容-&gt;OK告警主机: {HOST.NAME}OK告警IP: {HOST.IP}OK告警时间: {EVENT.DATE}-{EVENT.TIME}OK告警等级: {TRIGGER.SEVERITY}OK告警信息: {TRIGGER.NAME}OK问题详情: {ITEM.NAME}:{ITEM.VALUE}OK事件ID: {EVENT.ID}新的:通知所有参与者 点击”添加” =&gt; 添加 测试目前触发器触发的告警无法恢复,所以修改触发器的范围使报警恢复 恢复报警 点击”更新” 触发报警等待报警消失后,再次修改触发器阈值,主动触发告警,具体步骤不再赘述,详情见上面的”恢复报警”步骤 修改后,等待触发报警,等待邮件的发送 本地邮件群发 注意: 一个 zabbix 用户只能对应一个 linux 用户 zabbix用户1 &lt;=&gt; robinzabbix用户2 &lt;=&gt; zorrozabbix用户3 &lt;=&gt; tomzabbix用户4 &lt;=&gt; jerry 首先解释一下,在配置”动作”中的操作时,需要理解所填数字的含义: 操作细节: 步骤 [ 1 ]-[ 2 ]….等是什么意思 ​ ① ② ① =&gt; 指的是第几步,操作的执行顺序② =&gt; 指的是这个步骤持续到所有步骤的第几步(注意,是所有步骤的第一步开始计算,不是从哪一步开始) [注意]: ② &gt;= ① 举个例子 第一步: robin 1 - 3 &gt;&gt;&gt; 第一步开始执行,邮件发送至第三步第二步: zorro 2 - 2 &gt;&gt;&gt; 第二步开始执行,邮件发送至第二步(因为是从第二步开始,第二步结束,所以等于只发送一次)第三步: tom 3 - 5 &gt;&gt;&gt; 第三步开始执行,邮件发送至第五步第四步: jerry 4 - 5 &gt;&gt;&gt; 第四步开始执行,邮件发送至第五步 其余略… Zabbix模板 点击”添加” 点击该模板 添加应用集在该模板中创建新的”应用集” 添加监控项在该模板中创建新的”监控项” 店家”添加” 添加触发器 添加图形 应用模板 Zabbix的自定义键值语法在agent端定义key时只需要使用UserParameter参数即可 12UserParameter=&lt;key&gt;,&lt;command&gt;;[&lt;command&gt;...]# command只能有一个返回值 并且返回值不能超过512K 例如: UserParameter=mysql.ping.mysqladmin -uroot ping | grep -c alive The agent will return ‘1’,if Mysql server is alive, ‘0’ -otherwise 也就是对于zabbix来说,1为正确 无参数键值agent端配置用户自定义key 1234567[root@zabbix-agent ~]# free total used free shared buff/cache availableMem: 483612 90584 283488 6244 109540 348788Swap: 1048572 162408 886164[root@zabbix-agent ~]# /usr/bin/free|awk '/^Mem:/&#123;print $4&#125;'283340 获取到值后,将该值在/etc/zabbix/zabbix_agentd.conf中进行配置 12[root@zabbix-agent ~]# vim /etc/zabbix/zabbix_agentd.confUserParameter=memory.free,/usr/bin/free|awk '/^Mem:/&#123;print $4&#125;' 重启agent服务 1[root@zabbix-agent ~]# systemctl restart zabbix-agent server端zabbix监控端获取数据 123[root@zabbix-server alertscripts]# yum -y install zabbix-get[root@zabbix-server ~]# zabbix_get -s 192.168.100.163 -k "memory.free"280488 已经可以获取mem数据,添加为模板的Item 有参数键值agent端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@zabbix-agent ~]# /bin/cat /proc/meminfoMemTotal: 483612 kBMemFree: 279756 kBMemAvailable: 352120 kBBuffers: 0 kBCached: 70908 kBSwapCached: 3324 kBActive: 30272 kBInactive: 79716 kBActive(anon): 13608 kBInactive(anon): 31684 kBActive(file): 16664 kBInactive(file): 48032 kBUnevictable: 0 kBMlocked: 0 kBSwapTotal: 1048572 kBSwapFree: 886280 kBDirty: 4 kBWriteback: 0 kBAnonPages: 36316 kBMapped: 12644 kBShmem: 6212 kBSlab: 45560 kBSReclaimable: 20564 kBSUnreclaim: 24996 kBKernelStack: 4256 kBPageTables: 5084 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 1290376 kBCommitted_AS: 785128 kBVmallocTotal: 34359738367 kBVmallocUsed: 176280 kBVmallocChunk: 34359310332 kBHardwareCorrupted: 0 kBAnonHugePages: 0 kBHugePages_Total: 0HugePages_Free: 0HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kBDirectMap4k: 53120 kBDirectMap2M: 471040 kBDirectMap1G: 0 kB[root@zabbix-agent ~]# /bin/cat /proc/meminfo | awk '/^SwapTotal/&#123;print $2&#125;'1048572 在/etc/zabbix/zabbix_agentd.conf中进行配置 123[root@zabbix-agent ~]# vim /etc/zabbix/zabbix_agentd.conf UserParameter=memory.usage[*],/bin/cat /proc/meminfo|awk '/^$1/&#123;print $$2&#125;'[root@zabbix-agent ~]# systemctl restart zabbix-agent server端监控端获取根据传递的参数获取数据(同一个key可以监控多个指标) 12[root@zabbix-server ~]# zabbix_get -s 192.168.100.163 -k memory.usage[MemFree]279940 监控CPU的负载agent端12345[root@zabbix-agent ~]# vim /etc/zabbix/zabbix_agentd.conf UserParameter=load.avg1,/usr/bin/uptime | awk -F ':' '&#123;print $5&#125;' | awk -F ',' '&#123;print $1&#125;'UserParameter=load.avg5,/usr/bin/uptime | awk -F ':' '&#123;print $5&#125;' | awk -F ',' '&#123;print $2&#125;'UserParameter=load.avg15,/usr/bin/uptime | awk -F ':' '&#123;print $5&#125;' | awk -F ',' '&#123;print $3&#125;'[root@zabbix-agent ~]# systemctl restart zabbix-agent server端123456[root@zabbix-server ~]# zabbix_get -s 192.168.100.163 -k load.avg1 0.05[root@zabbix-server ~]# zabbix_get -s 192.168.100.163 -k load.avg5 0.03[root@zabbix-server ~]# zabbix_get -s 192.168.100.163 -k load.avg15 0.05 自动发现server主动发现agent服务器的过程 添加自动发现规则配置 =&gt; 自动发现 =&gt; 创建发现规则 =&gt; 名称:AutoDiscoveryHostIP 范围:192.168.122.101-105 检查:新的-&gt; HTTP Zabbix 客户端-&gt;端口范围:10050,键值:system abbix 客户端-&gt;端口范围:10050,键值:uname 添加自动发现的动作配置 =&gt; 动作 =&gt; 事件源:自动发现(右上角) =&gt; 创建动作 =&gt; 新建虚拟机重新打开一台 192.168.100.0/24 网段的虚拟机 安装zabbix-agent 123456789101112131415161718$ cat &gt; /etc/yum.repos.d/zabbix.repo&lt;&lt;EOF[zabbix]name=Zabbixbaseurl=https://mirrors.huaweicloud.com/zabbix/zabbix/4.4/rhel/7/x86_64/enabled=1gpgcheck=0EOF$ yum -y install zabbix-agent# 修改$ vim /etc/zabbix/zabbix_agentd.confServer=192.168.100.161 # server端ServerActive=192.168.100.161 # server端Hostname=192.168.100.164 # agent端UnsafeUserParameters=1$ systemctl start zabbix-agent 自动注册 自动发现功能主要是用与服务器端自动发现客户端,并且将其设置模板 群组并且监控,实际上服务端在主动扫描需要监控的server 而自动注册时客户端动作,客户端直接联系服务端,请求注册并且监控,实际上服务端在被动接受请求 对于部署多台服务器阶段,自动注册可能是更好的选择,而自动发现则用户后期维护比较合适 新建虚拟机192.168.100.165 安装zabbix-agent 123456789101112131415161718$ cat &gt; /etc/yum.repos.d/zabbix.repo&lt;&lt;EOF[zabbix]name=Zabbixbaseurl=https://mirrors.huaweicloud.com/zabbix/zabbix/4.4/rhel/7/x86_64/enabled=1gpgcheck=0EOF$ yum -y install zabbix-agent# 修改$ vim /etc/zabbix/zabbix_agentd.confServer=192.168.100.161 # server端ServerActive=192.168.100.161 # server端Hostname=192.168.100.165 # agent端UnsafeUserParameters=1$ systemctl start zabbix-agent 只需创建动作即可,[注意]:事件源选择-&gt;自动注册创建的内容与自动发现一样,只不过不需要填入任何条件,在[操作]中填写细节即可 点击”添加” 配置Zabbix - 实现proxy代理功能服务器规划: IP 主机名 192.168.100.161 zabbix-server 192.168.100.162 zabbix-proxy 192.168.100.163 zabbix-agent 基础配置在server/proxy/agent三台服务器上进行配置 配置域名解析123echo "192.168.100.161" zabbix-server &gt;&gt; /etc/hostsecho "192.168.100.162" zabbix-proxy &gt;&gt; /etc/hostsecho "192.168.100.166" zabbix-agent &gt;&gt; /etc/hosts 配置repo源1234567891011121314151617$ cat &gt; /etc/yum.repos.d/zabbix.repo&lt;&lt;EOF[zabbix]name=Zabbixbaseurl=https://mirrors.huaweicloud.com/zabbix/zabbix/4.4/rhel/7/x86_64/enabled=1gpgcheck=0EOF# mysql用于server与proxy$ cat &gt; /etc/yum.repos.d/mysql57.repo &lt;&lt;EOF[mysql-5.7-community]name=MySQL 5.7 Community Serverbaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-5.7-community-el7-x86_64/enabled=1gpgcheck=1gpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysqlEOF 清理repo源环境并重新建立12$ yum clean all$ yum repolist 安装必要软件在server/proxy/agent上进行配置 安装fping12$ yum -y install epel-release$ yum -y install fping mysql在server与proxy上进行安装 安装mysql1234567891011$ yum -y install mysql-server $ systemctl start mysqld# 查看root账户的默认密码 =&gt; wIu8_wS_nXpf$ cat /var/log/mysqld.log | grep password2021-01-18T12:36:00.240888Z 1 [Note] A temporary password is generated for root@localhost: wIu8_wS_nXpf2021-01-18T12:36:20.507908Z 2 [Note] Access denied for user 'root'@'localhost' (using password: NO)# 登录mysql并修改默认root账户的密码$ mysql -uroot -pwIu8_wS_nXpfmysql&gt; alter user 'root'@'localhost' identified by 'Syz123!@#';Query OK, 0 rows affected (0.00 sec) server端配置上面已有,不再赘述 proxy端配置创建数据库并授权123456789$ mysql -uroot -p'Syz123!@#'mysql&gt; create database zabbix_proxy character set 'utf8';Query OK, 1 row affected (0.00 sec)mysql&gt; grant all on zabbix_proxy.* to zbxproxy@localhost identified by 'Syz123!@#';Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; exitBye 安装zabbix-proxy1$ yum install -y zabbix-proxy zabbix-proxy-mysql zabbix-agent 导入表 1zcat /usr/share/doc/zabbix-proxy-mysql-4.4.10/schema.sql.gz | mysql -u zbxproxy -p'Syz123!@#' zabbix_proxy 修改配置文件 12345678$ vim /etc/zabbix/zabbix_proxy.confServer=192.168.100.161Hostname=zabbix-proxyDBHost=localhostDBName=zabbix_proxyDBUser=zbxproxyDBPassword=Syz123!@#DBSocket=/var/lib/mysql/mysql.sock 注意: 上面的 Hostname 名称要记住,一会儿在 zabbix 界面中创建代理时,需要与其保持一致,最好所有名字都取为 zabbix-proxy 启动proxy服务1234$ systemctl restart zabbix-proxy$ netstat -anplt|grep zabbix_proxytcp 0 0 0.0.0.0:10051 0.0.0.0:* LISTEN 2619/zabbix_proxy tcp6 0 0 :::10051 :::* LISTEN 2619/zabbix_proxy agent端配置安装zabbix-agent 1$ yum -y install zabbix-agent 修改配置文件 12345$ vim /etc/zabbix/zabbix_agentd.confServer=192.168.100.162ServerActive=192.168.100.162Hostname=zabbix-agentUnsafeUserParameters=1 # 是否限制用户自定义keys使用特殊字符 启动zabbix-agent服务 1234$ systemctl restart zabbix-agent$ netstat -antp | grep zabbixtcp 0 0 0.0.0.0:10050 0.0.0.0:* LISTEN 11809/zabbix_agentd tcp6 0 0 :::10050 :::* LISTEN 11809/zabbix_agentd 添加代理管理 =&gt; agent 代理程序 =&gt; 创建代理 =&gt; agent 代理程序名称:zabbix-proxy 系统代理程序模式:主动式(由proxy端主动将数据发送给server端) =&gt; 添加 添加自动发现配置 =&gt; 自动发现 =&gt; 创建发现规则 =&gt; 名称:AutoDiscoveryProxyHost由agent代理程序自动发现:zabbix-proxyIP范围:192.168.100.162更新间隔:10检查:ICMP ping =&gt; 添加 添加动作配置 =&gt; 动作 =&gt; 创建动作 =&gt; [动作]名称:AutoDiscoveryProxyHostActionA 自动发现规则 等于 AutoDiscoveryProxyHost 移除B 自动发现状态 等于 上 移除 [操作]添加主机 编辑 移除添加到主机群组: webservers 编辑 移除链接到模板: Template web server 编辑 移除 =&gt; 添加 新建虚拟机进行测试新添加一台ip为192.168.100.166的虚拟机 也许你会奇怪怎么多出来这么多的新主机,其实正常,这是因为zabbix-proxy代理通过自动发现再次把之前的机器添加了进来,造成了重复]]></content>
      <categories>
        <category>监控</category>
        <category>Zabbix</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的使用方法]]></title>
    <url>%2F2020%2F09%2F16%2Fshell%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[shell使用方法学习技巧 认真听课 给所有脚本添加上注释 用写好的脚本进行修改，达到修改后仍可正常执行的效果 根据自己的需求整理思路并创造完整的脚本 什么是 shellShell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。Linux 的 Shell 种类众多，常见的有： Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh） …… shell 在 linux 中称为 linux壳,在壳中间是 linux 的系统内核 简单的来说,shell 是帮助用户与系统内核之间进行沟通的桥梁 举个例子: 我们现在在一个互联网公司中,现在老板让我们和一个国外的客户商谈一个项目,然而呢,我们英语不好,可以说是菜的一批…这个时候我们就需要花重金聘请一位翻译来为我们进行信息的传达,而这个翻译的身份,就相当于我们现在所说的 shell,懂了吧? ok Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 操作系统内核 的服务。 shell分两大类： 1. 图形界面shell（Graphical User Interface shell 即 GUI shell） 应用最为广泛的 Windows Explorer （微软的windows系列操作系统） 1. 命令行式shell（Command Line Interface shell ，即CLI shell） bash / sh / ksh / csh / zsh（Unix/linux 系统） MS-DOS系统 cmd.exe/ 命令提示字符（Windows NT 系统） 传统意义上的shell指的是命令行式的shell，以后如果不特别注明，shell是指命令行式的shell。 Shell基本上是一个命令解释器，类似于DOS下的command。它接收用户命令（如ls等），然后调用相应的应用程序。较为通用的shell有标准的Bourne shell和 C shell 交互式 shell 与 非交互式 shell 1. 交互式模式就是shell等待你的输入，并且执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、签退。当你签退后，shell也终止了。 2. shell也可以运行在另外一种模式：非交互式模式。在这种模式下，shell不与你进行交互，而是读取存放在文件中的命令，并且执行它们。当它读到文件的结尾，shell也就终止了Shell 程序本身的功能是很弱的，比如文件操作、输入输出、进程管理等都得依赖内核。我们运行一个命令，大部分情况下 Shell 都会去调用内核暴露出来的接口，这就是在使用内核，只是这个过程被 Shell 隐藏了起来，它自己在背后默默进行，我们看不到而已。 接口其实就是一个一个的函数，使用内核就是调用这些函数。 如下图,是我从网上摘下来的图片 Shell ScriptShell Script,顾名思义,名为 shell 脚本 查了查网络上的资料找到了鸟哥🐦对于 shell 脚本的定义 鸟哥的专业解释：shell脚本是利用shell的功能所写的一个「程序」。这个程序是使用纯文本文件，将一些shell的语法与命令（包括外部命令）写在里面，搭配正则表达式、管道命令与数据流重定向等功能，以达到我们所想要的处理目的 嗯 , 差不多就是这个意思 那么为什么会产生 shell 脚本呢? 这样,我举个例子吧 假设我现在是一名小公司的运维人员,项目经理下达一项命令,每周日的凌晨 3 点备份公司的某某数据库的数据,并且将备份的数据库的日志文件拷贝一份给老板,于是乎,我们按部就班的每周日都要去一个一个去输入相应的命令这样效率非常低…一者,时间上来讲,我们总不能一直那么大晚上的去工作二者,每周都是相同的命令,做起来非常浪费时间,没有意义那么,有人就想,能不能把命令都集中到一起写入到文件中,使用时直接执行那个文件不就好了吗?于是,shell 脚本经过漫长的演变,成为了现在的模样. 第一个脚本：Hello World vim test.sh 123#!/bin/bashecho "hello world" bash test.sh 执行方式 ./ (需要使用 chmod +x hello.sh 给文件执行权限) bash 命令：echo -e : 输出特殊字符的输出 示例： 1echo -e "\\" -n : 输出指定内容后不换行 \a : 输出警告声音 \n : 换行 \t : 插入tab \ : 插入 \ 符号 \e[nm *\e[om : 用来指定 * 输出时的颜色格式 示例： 1echo -e "\e[31mhello world\e[0m" wxr权限的功能文件下： W：文件可写 X：文件可执行 R：文件可读 目录下： W: 可以建立新目录/删除已存在目录/修改已存在的目录 X: 具有执行的权限，简单地说，就是可以将该目录转换成家目录的能力，比如cd 命令。注意，x权限对于目录是极其重要的，如果没有该目录，表示你不能切换到该目录，更不能对其子目录或者文件进行操作，即使你有“r/w”权限。 R: 可查询此目录下文件名数据，比如ls命令 小贴士: shell: 帮助用户和内核之间进行沟通的桥梁（接口：API） RedHad/CentOS/Ubuntu使用的都是Linux内核 所有开头带点的文件都是隐藏文件 命令history历史命令配置文件只会保存本次登陆之前的历史命令 选项： -w: 把缓存中的历史命令同步到 .bash_history 中 -c: 仅清空缓存中的历史命令（不清空配置文件 .bash_history 的内容） history历史命令的快速调用: 上下光标 !n，重复执行历史命令中的第n个命令 !!，执行上一个命令 ! + 字符，执行最近一次以该字符开头的历史命令 起别名配置文件：.bashrc(单用户生效)/etc/bashrc(所有用户生效) 1source /etc/bashrc //让配置文件中的配置立即生效 格式：alias 别名 = &#39;命令[选项]&#39;（不能使用已经存在的命令作为别名） \ 称为转义符：将该符号后的字符不产生其特殊作用示例：\rm aaa ctrl ctrl + l，快速清屏 ctrl + c，停止运行 ctrl + d，（关闭/退出）登录/窗口 重定向wc: wordcount 输入重定向：&lt;（覆盖式写入）,此重定向有一定的风险 命令：wc &lt; filename 示例： 1wc -l &lt; /etc/passwd(统计系统有多少个用户) 输出重定向：&gt; 命令： echo “***” &gt; filename 输出重定向：&gt;&gt;（追加式写入） 文本合并方式一：cat a.txt b.txt &gt; new.txt方式二：使用vim打开a.txt，:r 路径/b.txt 输出重定向特殊使用方法&amp;&gt;：忽略命令执行结果的错对，将输出写入到指定文件或设备 echo $?(查看上一条命令是否正确，正确输出0，错误输出非0) 逻辑; ：分隔命令(无逻辑关系，命令全部执行)&amp;&amp;：同时成立才执行(前面执行成功后则后面开始执行)||：其中一个成立即可执行（如果某一个命令执行成功了，后面的命令便不再执行） 管道符 |ls -l /etc/ | more(翻页显示，空格翻页) 特殊符号 $：用于调用指定的变量的值，如 echo “$abc” \：转义符 ‘’：引号内的所有符号失去特殊含义 “”：类似于单引号，除了”$”,”`”,”&quot;三个符号外都没有特殊含义，常用于将某命令 ``：反引号,优先执行反引号中的内容 示例： 1echo `date` //取出date命令的执行结果传给echo 知识： date：系统时间 clock：时钟时间 例子： 12usernum=`wc -l &lt; /etc/passwd`echo $usernum 或者 12usernuum=$(wc -l &lt; /etc/passwd)echo $usernum UID范围超级管理员：0系统用户：1-999普通用户：1000-65535 /sbin/nologin:禁止本地、远程登录/bin/bash:可登录 变量的分类 自定义(普通)变量 环境变量 位置参数变量 预定义变量 set作用：用来显示终端有哪些变量（显示所有变量）选项： -u 使用 set -u 命令之后，如果变量不存在，会报错，不会输出空值，避免了一些风险 示例： 12set -urm -rf $a/* unset删除变量 注：特殊符号也可以顺序排列(转换为ASCII码) 普通变量name= zhangsan ❌name=zhang san ❌name=zhangsan ✅name=”zhang san” ✅ 环境变量尽量使用大写字母 声明规范： 1export NAME=zhangsan 如何区分普通变量与环境变量：env：只显示环境变量 普通变量如何变成环境变量：直接（重新）声明即可 例子： 1env | grep 'PATH' 结果： 1PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin 这个环境变量很重要我们执行的命令，都是通过这个变量作为引导来查询到相应的命令位置的比如： [root@localhost ~]# which lsalias ls=’ls –color=auto’/usr/bin/ls which会查询到ls命令的所在位置，而 /usr/bin 就是环境变量PATH中的一个成员如果PATH环境变量删除了，那么我们的所有命令将不可再使用假设test是一个可执行程序 PATH=”$PATH:/tmp/test”这条语句的意思就是添加一个新的命令，名为test 位置参数变量使用例子来说明 vim test.sh 12345#!/bin/bashecho $0echo $1echo $2echo $3 bash test.shbash test.sh 11 22 33 测试1： bash test.sh 1test.sh 系统会默认把脚本的名称作为$0 测试2: bash test.sh 11 22 33 1234test.sh112233 $* : 一次性输出所有变量 $@ : 依次输出变量 $# : 统计变量个数 测试3: vi test.sh 12345#!/bin/bashecho $*echo $@ echo $# bash test.sh 11 22 33 44 12311 22 33 4411 22 33 44 4 命令read-p : 编写提示信息 例子： vi test1.sh 123#!/bin/bashread -p "Please input your userid: " id read -p "Please input your password: " password chmod +x test1.sh./test1.sh 进一步修改： vi test1.sh 123456#!/bin/bashread -p "Please input your userid: " id read -p "Please input your password: " passwordread -p "Please input your want to (+,-,*,/): " fixecho $(($id$fix$password)) chmod +x test1.sh./test1.sh 其实这只是一个骨架，可以想一下如果输入了字母，会出现什么情况？所有还要进一步对输入进行判断,以后待我牛X了再进行补充. 运算在shell中只支持整数型运算 如果想要使用浮点数，解决办法： 命令：bc(一般和管道符配合使用)格式：echo $(echo “1.23*3.45”|bc) 特殊运算符 ++ : 一般用 let n++,意思是n的值每次自增1 += : 一般用 let n+=N,意思是n的值每次自增N – : 一般用 let n– -+ : 一般用 let n-=N 变量相关配置文件加载顺序：/etc/profile —&gt; ~/.bash_profile —&gt; ~/.bashrc —&gt; /etc/bashrc cat /etc/profile 1234if [ $UID -gt 199 ] &amp;&amp; [ "`/usr/bin/id -gn`" = "`/usr/bin/id -un`" ]; then umask 002else umask 022 文件的最大权限：666 umask：002666-002=664 umask：022666-022=644 流程控制if-else单分支格式(注意空格)： 123456if [ 判断条件 ];then 语句1else 语句2fi 多分支格式： 123456789if [ 判断条件1 ]then 语句1elif [ 判断条件2 ]then 语句2else 语句3fi 具体：[-选项 “变量”],然后借助 $? 在验证判断结果 -e：判断文件是否存在-s：判断文件是否存在，并判断是否为非空-f：判断文件是否存在，并判断是否是普通文件-d：判断文件是否存在，并判断是否是目录文件-b：判断文件是否存在，并判断是否是块设备文件-L：判断文件是否存在，并判断是否是软链接文件 -eq：判断是否相等-ne：判断是否不等-gt：判断是否大于-lt：判断是否小于-ge：判断是否大于等于-le：判断是否小于等于 -z：判断字符串是否为空-n：判断字符串是否为非空==：判断两个字符串是否相同!=：判断两个字符串是否不同 -a：逻辑与，多个判断使用-a连接起来，所有条件成立则为真-o：逻辑或，多个判断使用-o连接起来，任意条件成立则为真 for语法一： 1for 变量 in v1 v2 v3... 语法二： 1234for((初始值;循环控制条件;变量变化))do 程序done 例子： vim test2.sh 123456789#!/bin/bashsum=0for((i=1;i&lt;=100;i++))do sum=$(($sum+$i))doneecho $sum chmod +x test2.sh./test2.sh 案例(常用小工具)：利用脚本解压压缩包 压缩包的类型： .zip .tar .tar.gz/.tar.bz2/.tar.xz/.tgz(解压命令：tar -xf filename) .gz .bz2 假设都是同一种类型 vim yasuo.sh 12345678910#!/bin/bashread -p "scripts file path" pathcd $pathfor i in `ls`do tar -xf $idone 不是同一种类型 vim yasuo1.sh 123456789101112131415#!/bin/bashread -p "scripts file path" pathcd $pathfor i in `ls`do if [[ "$i" =~ ".zip" ]];then unzip $i elif [[ "$i" =~ ".tar" ]];then tar -xf $i else echo "this type is unknow"done while格式一： 1234while [ 条件判断式 ]do 程序done 格式二： 1234while truedo 程序done 退出功能 exit：退出脚本 exit[值]：退出时如果定义好了返回值，那么我们可以通过 $? 来查看 break：退出循环 continue：直接开始下一次的循环 示例： for i in 1 2 3 4 5 6 7 8 9do if [ “$i” -eq “4” ] then break else echo “$i” fidone 随机数： echo $RANDOMecho $(($RANDOM%100)) 示例： 1234567891011121314151617#!/bin/bashnum1=`echo $(($RANDOM%100))`while truedo read -p "Please input a number[1-100]: " num2 if [ "$num2" -gt "$num1" ] then echo "you win" elif [ "$num2" -lt "$num1" ] then echo "you false" else echo "you guess" fidone]]></content>
      <categories>
        <category>Linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2020%2F09%2F01%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式目标：查找/取出/匹配 符合条件的某个字符或字符串 正则表达式学习方法：单个字符表示&gt;&gt;&gt;字符串表示&gt;&gt;&gt;表达式 正则单字符的表示方法首先，把/etc/passwd复制到家目录下 1cp /etc/passwd ~/. 特定字符某个具体的字符，如：’1’,’a’ 示例： 1grep '1' passwd 范围内字符 数字字符 小写字符 大写字符 大小写字符 符号 反向字符 单个字符 [] 数字字符[0-9],[123] (注意：只是范围内的一个字符) 示例： 1grep '[0-9]' passwd 小写字符[a-z] 示例： 1grep '[a-z]' passwd 大写字符[A-Z] 示例： 1grep '[A-Z]' passwd 大小写字符[a-zA-Z] 示例： 1grep '[a-zA-Z]' passwd 符号[,:_] 示例： 1grep '[,:_]' passwd 反向字符[^0-9] 示例： 1grep '[^0-5]' passwd 任意字符 一个点：’.’ (代表任何一个字符) 注意*：’[.]’ 与 ‘.‘ 的效果是一样的 边界字符 头字符 尾字符 头尾字符^:^root (注意与[^]的区别)示例： 1grep '^root' passwd $:false$示例： 1grep 'false$' passwd 空行的表示：^$ 首先在家目录下创建一个a.txt文件 1touch a.txt 输入以下内容： 1234567hello worldmy name is 寿司卷codeI am very happy to meet youHow are you? 示例： 1grep '^$' a.txt 元字符\w:匹配任何字类字符，包括下划线（[A-Za-z0-9_]）示例： 1grep '\w' a.txt \W:匹配任何非字类字符（[^A-Za-z0-9_]）示例： 1grep '\W' a.txt \b:代表单词的分隔示例： 1grep '\bx\b' passwd 字符表达式的字符组合字符串‘root’ ‘1000’ ‘a..c’‘[A-Z][a-z]’：大写字母与小写字母的组合示例： 1grep '[A-Z][a-z]' passwd ‘[0-9][0-9]’：数字与数字的组合示例： 1grep '[0-9][0-9]' passwd 这里会有一个问题：会匹配到两位以及两位数以上的数据行 解决办法： grep ‘\b[0-9][0-9]\b’ passwd 其实用久了我们会发现，上面的这种组合方式非常的繁琐、不方便有没有更好的办法呢？当然有！ 重复 *:零次或多次匹配前面的字符或表达式 +:一次或多次匹配前面的字符或表达式 ?:零次或一次匹配前面的字符或表达式 首先创建一个测试文件test.txt touch test.txt 填入以下内容 ab ababab abbbbbbbbbb bbbbbbbbbbb acccccccc +ab+ab+ 匹配单个字符示例： grep ‘ab*’ test.txtgrep ‘ab+’ test.txtgrep ‘ab?’ test.txt 自己可以尝试一下这三个有什么不同之处下面是我做的测试，高亮的地方就是匹配到的字符 1grep 'ab*' test.txt abababababbbbbbbbbbacccccccc+ab+ab+ 1grep 'ab+' test.txt +ab+ab+ 嘿，是不是发现grep &#39;ab+&#39; test.txt有问题啊是的，这个+号需要转义一下,?也是同理 1grep 'ab\+' test.txt abababababbbbbbbbbb+ab+ab+ 1grep 'ab\?' test.txt abababababbbbbbbbbbacccccccc+ab+ab+ 匹配多个字符如果想要匹配一整个字符呢？可以用()括起来示例： 1grep '\(ab\)*' test.txt 结果： ab ababab abbbbbbbbbb bbbbbbbbbbb acccccccc +ab+ab+ 是不是发现其中有空行的存在？这是因为*包括匹配零次的结果语句应该这样写： 1grep '\(ab\)\+' test.txt 结果： abababababbbbbbbbbb+ab+ab+ 重复特定次数{n,m}:重复n到m次比如{2,3}，在grep中使用就是说匹配重复2次到3次的数据行示例： 1grep '[0-9]\&#123;2,3\&#125;' passwd 测试之后会发现确实是匹配到了2次到3次的数据行了，但是其中也包括了三次以上的数据行这该如何解决呢？没错，就是你想的那样 1grep '\b[0-9]\&#123;2,3\&#125;\b' passwd 匹配任意字符串.表示任何一个字符示例： 1grep '^a.*' passwd 这里请注意&#39;^a.*b&#39;与&#39;^a..b&#39;的区别 这个应该都明白吧？ 哎，还是写出来吧… 示例： 1grep '^a.*b' test.txt 结果： abababababbbbbbbbbb 1grep '^a..b' test.txt 结果： ababababbbbbbbbbb 这次明白了吧…😓 逻辑表示| : ‘bin/(bash|nologin)‘示例： 1grep 'bin/\(bash\|nologin\)' passwd 结果： root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologinsystemd-network:x:192:192:systemd Network Management:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinpolkitd:x:999:997:User for polkitd:/:/sbin/nologinabrt:x:173:173::/etc/abrt:/sbin/nologintss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinchrony:x:998:996::/var/lib/chrony:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologinmysql:x:27:27:MySQL Server:/var/lib/mysql:/bin/bash 案例测试案例一匹配4-10位QQ号 首先创建一个qq.txt文件 可以填入随意的内容： 123456789101112131415161712312312124141414325313531515235235235dsdf223325325fsffew242342342342342312345678900987654x1233214567654567891235456545678672434234234322332545454223325545123dfsw245_heeet2525 1grep '^[0-9]\&#123;4,10\&#125;' qq.txt 案例二匹配15位或18位的身份证号（支持带X） 1grep '^[0-9]\([0-9]\&#123;13\&#125;\|[0-9]\&#123;16\&#125;\)[0-9xX]$' qq.txt 案例三匹配密码（由数字，26个字母和下划线组成） 1grep '^\w\+$' qq.txt]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux笔记扩展]]></title>
    <url>%2F2019%2F10%2F08%2FLinux%E7%AC%94%E8%AE%B0%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[ln 链接ln : link 为什么要用到软链接? 其实类似于windows中,桌面上的快捷方式一样 为了方便,我们平时在windows上,把所有常用的软件的快捷方式放在桌面上 Linux中也一样 123456789101112131415161718192021222324252627282930# 格式ln [选项] 源文件 目标文件# 选项: -s : 创建软连接(基本上这一个参数就够了)# 示例# 1. 软链接# 创建文件 /etc/issue 的软链接 /tmp/issue.softln -s /etc/issue /tmp/issue.softll /tmp # 特点: # 1. 软链接生成的文件是 "满权限" 的,这样是很危险的? # 2. 不不不,其实真正的权限还是由原文件来决定 # 3. 只有软链接的开头才会是 "l" # 4. 有指向源文件的箭头 lrwxrwxrwx. 1 root root 10 10月 8 17:12 issue.soft -&gt; /etc/issue# 2. 硬链接 # 创建文件 /etc/issue 的硬链接 /tmp/issue.hardln /etc/issue /tmp/issue.hardll /tmp # 特点: # 1. 硬链接生成的文件 "不是满权限" 的 # 2. 硬链接文件与源文件同步更新 # 3. 相当于cp(拷贝),即使源文件删除了,硬链接的文件依然存在(实时的备份) # 4. 通过 i 节点识别: 命令 "ls -i /etc/issue /tmp/issue.hard" 查看文件索引号(inode),会发现源文件与硬链接文件的索引号相同,这也是为什么两个文件会实时同步的原因 # 5. 硬链接无法跨分区 # 6. 无法针对目录 -rw-r--r--. 2 root root 23 8月 30 2017 issue.hard 文件搜索命令 locatelocate 秒级搜索 但是有一个问题,对于刚刚新建的文件或目录,实时的查找出来,需要更新一下数据库 相对于find来说,find查找虽然没有那么快,但它是实时搜索的,没有更新的这一个步骤 在centos7中,locate好像没有了,需要下载一下 1234567891011121314151617# 下载yum -y install mlocate# 测试mkdir /syz# 更新数据库,不然无法找到刚刚新建的目录# 注意: 临时资料库中的文件是查找不到的,如/tmpupdatedb# 查找locate /syz# 如果出现一些文件无法找到的情况,那是因为收到了限制# 修改配置文件,解除限制vim /etc/updatedb.conf #把yes改为no# 查找不区分大小写touch /SyZ.txt updatedblocate -i syz which快速查找命令的位置 12345678which ls alias ls='ls --color=auto' /usr/bin/lswhich rm alias rm='rm -i' /usr/bin/rm# 其实在Linux系统中,我们执行rm命令时,之所以会再次提醒确认删除# 不是rm这个命令特有的,而是 rm 通过 alias 映射成了 rm -i grep是不是感觉学过了? 扩展嘛,再来深入一下 1234567891011121314151617# 不区分大小写的查找touch /syz.txtecho -e "Syz\nsyz\nSyz\nasdasfsSyz\nafaaaesyz\n12412421\nwrfwafsa" &gt;&gt; /syz.txtgrep -i "syz" /syz.txt # 反向查找touch /test.txtvim /test.txt # 填入以下内容 -------------------------- # this is a test hello world # hello world hi! --------------------------grep -v "^#" /test.txt # 只输出不带有 # 的行 who查看当前所有用户的登录情况 123456789who# 以什么用户身份登录的 登录方式 登录的时间 (登录机器的IP段)root tty1 2019-10-08 16:20root pts/0 2019-10-08 16:20 (10.211.55.2)root pts/1 2019-10-08 21:46 (10.211.55.2)# 解析:# tty 表示为本地终端登录的# pts 表示为远程登录的 uptime查看服务器已经运行的时间 123uptime # 初始时间 状态 已经运行的时间 当前总共几个用户登录 负载均衡 20:50:09 up 4:30, 2 users, load average: 0.00, 0.01, 0.05 w查看 uptime who 的综合信息(比这两者还要多一点东西) 1234567891011w21:48:25 up 5:28, 3 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 16:20 7:29 0.02s 0.02s -bashroot pts/0 10.211.55.2 16:20 57:05 0.24s 0.24s -bashroot pts/1 10.211.55.2 21:46 1.00s 0.04s 0.03s w# 解析:# 第一行: 机器开机时间 状态 已经运行的时间 已经登陆了几个用户 负载均衡# 第三行: 用户身份 登录方式 来自哪个网段 何时登录的 累计空闲时间 累计占用CPU资源的时间 占用CPU资源的时间 当前执行的命令 write给某个在线用户发送信息 12345678910useradd syzpasswd syz# 重新打开一个终端,以syz用户登录# 回到root用户下的终端中,给syz用户发送信息write syzhelloworld# 最后最好回车一下,然后ctrl + d 结束,发送# 然后就会在syz用户的终端下收到消息 wall给所有的在线用户发送消息(包括自己) 这里不再演示 ping/bin/ping测试网络的连通性 123# -c : 指定发送的次数ping -c 3 baidu.com# 结尾的时间越短,证明网络连通性越好 ifconfig功能:查看和设置网卡信息英文全称:interface configure路径:/sbin/ifconfig使用权限:root 123456# 查看本机IP地址ifconfig# 设置临时IP地址# 语法: ifconfig 网卡名称 IP地址ifconfig eth0 10.0.0.10 mail功能:查看邮件或给用户发送邮件路径:/bin/mail执行权限:所有用户 123456789101112# 给 syz 用户发送邮件mail syzhello# ctrl + d#查看邮件mail# h : 列出所有邮件# 数字 : 输入列出的邮件的索引号即可查看对应的邮件内容# d 数字 : 删除相应的邮件 last 和 lastloglast功能:列出现在和过去所有用户的登陆信息,包括系统什么时候重启过 123456789101112131415161718last root pts/3 10.211.55.2 Tue Oct 8 22:55 - 22:55 (00:00) root pts/1 10.211.55.2 Tue Oct 8 22:55 still logged in syz pts/2 10.211.55.2 Tue Oct 8 22:54 still logged in root pts/1 10.211.55.2 Tue Oct 8 22:22 - 22:55 (00:32) root pts/1 10.211.55.2 Tue Oct 8 21:46 - 22:22 (00:36) root pts/0 10.211.55.2 Tue Oct 8 16:20 still logged in root tty1 Tue Oct 8 16:20 still logged in reboot system boot 3.10.0-693.el7.x Tue Oct 8 16:19 - 23:38 (07:18) root pts/0 10.211.55.2 Mon Oct 7 19:26 - down (02:01) root tty1 Mon Oct 7 19:24 - 21:27 (02:03) reboot system boot 3.10.0-693.el7.x Mon Oct 7 19:23 - 21:27 (02:04) root pts/0 10.211.55.2 Sun Oct 6 11:39 - crash (1+07:44) root tty1 Sun Oct 6 11:18 - 13:14 (01:56) reboot system boot 3.10.0-693.el7.x Sun Oct 6 11:17 - 21:27 (1+10:10) wtmp begins Sun Oct 6 11:17:26 2019 lastlog功能:只查看所有用户(包括不可登录的用户)的最后一次的登录信息 12345678910111213141516# 查看所有用户(包括不可登录的用户)的最后一次的登录信息lastlog# 通过用户的uid查看对应用户的最后一次登录信息# 查看root用户的最后一次登录信息lastlog -u 0 用户名 端口 来自 最后登陆时间 root pts/3 10.211.55.2 二 10月 8 22:55:46 +0800 2019# 查看syz用户的最后一次登录信息# 首先查看用户syz的uidcat /etc/passwd | grep syz syz:x:1002:1002::/home/syz:/bin/bashlastlog -u 1002 用户名 端口 来自 最后登陆时间 syz pts/2 10.211.55.2 二 10月 8 22:54:35 +0800 2019 traceroute功能:显示数据包到主机间的路径,可以用来排除网络在哪里出现了问题执行权限:所有用户语法:traceroute 网址(或域名) 12345678910111213141516171819202122232425262728traceroute www.imau.edu.cn # 可能是因为网络的问题,到后面太慢,所以只粘贴了一点 traceroute to www.imau.edu.cn (222.74.205.105), 64 hops max, 52 byte packets 1 bogon (192.168.43.249) 3.731 ms 2.668 ms 3.235 ms 2 * * * 3 bogon (172.20.1.89) 96.085 ms 25.947 ms 24.937 ms 4 * * * 5 111.56.28.17 (111.56.28.17) 39.030 ms 53.792 ms 20.011 ms 6 221.183.13.109 (221.183.13.109) 17.659 ms 33.792 ms 24.449 ms 7 * * * 8 * * * 9 221.183.66.2 (221.183.66.2) 106.024 ms 221.183.30.58 (221.183.30.58) 39.249 ms * 10 202.97.57.197 (202.97.57.197) 185.827 ms 202.97.88.233 (202.97.88.233) 52.745 ms 58.777 ms 11 202.97.28.190 (202.97.28.190) 92.896 ms 202.97.28.194 (202.97.28.194) 117.207 ms 114.305 ms 12 219.148.161.234 (219.148.161.234) 69.864 ms 219.148.167.170 (219.148.167.170) 76.444 ms 219.148.167.150 (219.148.167.150) 63.254 ms 13 * * * 14 123.178.212.154 (123.178.212.154) 136.865 ms 123.178.212.150 (123.178.212.150) 68.919 ms 69.143 ms 15 * * * 16 * * * 17 * * * 18 * * * 19 * * * netstat功能:显示网络相关信息执行权限:所有用户语法:netstat [选项] 选项: -t : TCP协议 -u : UDP协议 -l : 监听 -r : 路由 -n : 显示IP地址和端口号 12345678# 示例# 1. 查看本机监听的端口netstat -tlun# 2. 查看本机所有的网络连接# -a : 表示 allnetstat -an# 3. 查看本机路由表netstat -rn nmtui功能:配置网络 配置完记得要执行 systemctl restart network 才能生效 mount 挂载这是对Linux笔记中的 mount 的扩展 最初,CentOS没有了图形界面,我不知道如何才能把镜像光驱挂载到本地磁盘 现在知道了 👨‍💻‍ 12345# 首先让虚拟机连接上 镜像文件mkdir /mnt/centosmount -t iso9660 /dev/sr0 /mnt/centos# 其实可以简写mount /dev/sr0 /mnt/centos chage 查看密码信息功能:查看用户密码相关信息 12345678910111213141516171819202122232425# 语法:chage [选项] 用户名# 选项: -l : 列出用户的详细密码信息 -d : 修改密码最后一次更改日期 -m : 两次密码修改间隔 -M : 密码有效期 -W : 密码过期前警告天数 -I : 密码过期后宽限天数 -E : 密码失效时间chage -l syz 最近一次密码修改时间 ：10月 08, 2019 密码过期时间 ：从不 密码失效时间 ：从不 帐户过期时间 ：从不 两次改变密码之间相距的最小天数 ：0 两次改变密码之间相距的最大天数 ：99999 在密码过期之前警告的天数 ：7# 上面的内容弄了解即可,不是太重要,因为这样还不如直接进入shadow文件内修改来的直观# 重要的一条命令:chage -d 0 syz #该用户下次登录时,必须先修改密码# 不要使用root用户直接su进入该用户,应该新开一个终端登录该用户 chattr英文意思是 change attribute 注意:root 超级管理员也不可以跨越chattr设定的规则!!! 暗叫一声:666… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# 语法: chattr &#123;+ - =&#125; [选项] 文件或目录名# 选项: -i : 如果对文件设置了 i 属性,那么不允许对文件进行删除和改名,也不能添加和修改数据 如果对目录设置了 i 属性,那么只能修改目录下文件的数据,但不允许新建和删除文件 -a : 如果对文件设置了 a 属性,那么只能在文件中增加数据,不能删除和修改数据 如果对目录设置了 a 属性,那么只允许在目录中新建和修改文件,但是不允许删除********************************************************************# 1. i 的测试# 1.1 i 之文件下的测试# 新建一个名为111.txt的文件touch 111.txt# 给111.txt设置chattrchattr +i 111.txt# 查看当前目录下是否设置了chattr# 语法: lsattr [选项]# 选项: -a : 查看所有 -d : 查看当前目录本身,不查看子目录lsattr -a# 尝试在111.txt中添加数据echo hello &gt;&gt; 111.txt -bash: 111.txt: 权限不够# 尝试删除111.txtrm -rf 111.txt rm: 无法删除"111.txt": 不允许的操作*********************************************************# 1.2 i 之目录下的测试mkdir /testtouch /test/aaa.txtchattr +i /testlsattr -a /testecho hello &gt;&gt; /test/aaa.txt #可以对该目录下的文件写入数据touch /test/bbb.txt #但是不能创建文件 touch: 无法创建"/test/bbb.txt": 权限不够rm -rf /test/aaa.txt rm: 无法删除"/test/aaa.txt": 权限不够*********************************************************# 2. a 的测试# 2.1 a 之文件下的测试touch aaaecho hello &gt;&gt; aaacat aaachattr +a aaalsattr -aecho 111 &gt;&gt; aaa #向aaa文件内追加新数据,不修改原来的数据echo 222 &gt; aaa #向aaa文件内覆盖写入数据,尝试修改原来的数据,发现没有权限 -bash: aaa: 不允许的操作*********************************************************# 2.2 a 之目录下的测试mkdir /test2chattr +a /test2lsattr -a /test2touch /test2/aaatouch /test2/bbbecho aaa &gt;&gt; /test2/aaarm -rf /test2/aaa rm: 无法删除"/test2/aaa": 不允许的操作*********************************************************# 总结一下 i 选项相对于 a 选项来说要严格一些 i 总的来说就是: 不可以增加 不可以删除 a 总的来说就是: 可以增加,不可以删除 两者对于目录的chattr设置,目录下的文件都可以进行修改 sudo 权限root 用户将只能超级用户执行的命令赋予普通用户执行 注意: sudo的操作对象是系统命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455visudo #实际上打开的是 /etc/sudoers #用户 被管理主机的地址=(可以使用的身份) 授权命令(需要使用绝对路径) root ALL=(ALL) ALL #组名 ... %wheel ALL=(ALL) ALL# 示例# 打开 visudo# 在 root ALL=(ALL) ALL 下面加入一行syz 10.211.55.5 /sbin/useradd# 切换至该用户su - syz# 查看该用户在 sudo 中可以执行的命令sudo -l [sudo] syz 的密码： 匹配 %2$s 上 %1$s 的默认条目： !visiblepw, always_set_home, match_group_by_gid, env_reset, env_keep="COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS", env_keep+="MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE", env_keep+="LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES", env_keep+="LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE", env_keep+="LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY", secure_path=/sbin\:/bin\:/usr/sbin\:/usr/bin 用户 syz 可以在 centos-server 上运行以下命令： (root) /sbin/useradd# 测试该命令sudo useradd syz1 #不报错,即运行成功# 退出exit*********************************************************#使用其他用户测试su - zhangsansudo useradd zhangsan1 [sudo] zhangsan 的密码： zhangsan 不在 sudoers 文件中。此事将被报告。*********************************************************# 下面这个例子只是做示范,警告同学们不要这么操作visudo syz ALL=/usr/bin/vim# 注意: 这是很危险的# 因为这样的话,执行sudo命令后代表syz用户拥有了和root一样的vim编辑权限# 甚至可以编辑/etc/passwdsu - syzsudo /usr/bin/vim /etc/passwd #可以不写绝对路径,直接写 vim# 可以修改并保存,很危险 文件系统常用命令df du fsck dumpe2fs df-文件系统查看命令123456789# 语法:df [选项] 挂载点# 选项: -a : 显示所有文件系统信息,包括特殊文件系统(如/proc,/sysfs) -h : 使用习惯单位显示容量 -T : 显示文件系统类型(KB,MB,GB) -m : 以 MB 为单位显示容量 -k : 以 KB 为单位显示容量# 常用df -Th du-统计目录或文件大小一般用来统计目录的大小 1234567# 语法: du [选项] [目录或文件名]# 选项: -a : 显示每个子文件的磁盘占用量 -h : 使用习惯单位显示磁盘占用量 -s : 统计总占用量而不列出目录和文件的占用量# 常用du -sh / df 与 du 的区别df 命令是从文件系统考虑的,不光要考虑文件占用的空间,还要统计被命令或程序占用的空间(最常见的就是文件已经被删除,但是程序并没有释放空间) du 命令是面向文件的,只会计算目录或文件的占用的空间 fsck-文件系统修复命令1234# 语法: fsck [选项] 分区设备文件名# 选项: -a : 不用显示用户提醒,自动修复文件系统 -y : 自动修复,和 -a 选项作用一致,不过有些文件系统只支持 -y dumpe2fs-显示磁盘状态123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 语法: dumpe2fs 分区设备文件名dumpe2fs /dev/sdb1 dumpe2fs 1.42.9 (28-Dec-2013) Filesystem volume name: &lt;none&gt; #卷标 Last mounted on: &lt;not available&gt; #挂载点 Filesystem UUID: 49900854-b38a-4f2d-80bb-825863b86684 #分区UUID Filesystem magic number: 0xEF53 Filesystem revision #: 1 (dynamic) Filesystem features: has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize Filesystem flags: signed_directory_hash Default mount options: user_xattr acl Filesystem state: clean Errors behavior: Continue Filesystem OS type: Linux Inode count: 131072 #i节点数 Block count: 524288 #块数量 Reserved block count: 26214 Free blocks: 498132 Free inodes: 131061 First block: 0 Block size: 4096 #块大小 Fragment size: 4096 Group descriptor size: 64 Reserved GDT blocks: 255 Blocks per group: 32768 Fragments per group: 32768 Inodes per group: 8192 Inode blocks per group: 512 Flex block group size: 16 Filesystem created: Sun Oct 6 11:52:35 2019 Last mount time: Sun Oct 6 12:00:17 2019 Last write time: Sun Oct 6 13:14:11 2019 Mount count: 1 Maximum mount count: -1 Last checked: Sun Oct 6 11:52:35 2019 Check interval: 0 (&lt;none&gt;) Lifetime writes: 97 MB Reserved blocks uid: 0 (user root) Reserved blocks gid: 0 (group root) First inode: 11 Inode size: 256 Required extra isize: 28 Desired extra isize: 28 Journal inode: 8 Default directory hash: half_md4 Directory Hash Seed: 214be6cc-19b8-4bff-92ed-13a372f7b4b1 Journal backup: inode blocks Journal features: journal_64bit 日志大小: 64M Journal length: 16384 Journal sequence: 0x00000004 Journal start: 0]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux笔记]]></title>
    <url>%2F2019%2F09%2F29%2FLinux%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Linux概述简介摘自于百度百科 Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。伴随着互联网的发展，Linux得到了来自全世界软件爱好者、组织、公司的支持。它除了在服务器操作系统方面保持着强劲的发展势头以外，在个人电脑、嵌入式系统上都有着长足的进步。使用者不仅可以直观地获取该操作系统的实现机制，而且可以根据自身的需要来修改完善这个操作系统，使其最大化地适应用户的需要. Linux不仅系统性能稳定，而且是开源软件。其核心防火墙组件性能高效、配置简单，保证了系统的安全。在很多企业网络中，为了追求速度和安全，Linux操作系统不仅仅是被网络运维人员当作服务器使用，Linux既可以当作服务器，又可以当作网络防火墙是Linux的 一大亮点。 Linux与其他操作系统相比 ，具有开放源码、没有版权、技术社区用户多等特点 ，开放源码使得用户可以自由裁剪，灵活性高，功能强大，成本低。尤其系统中内嵌网络协议栈 ，经过适当的配置就可实现路由器的功能。这些特点使得Linux成为开发路由交换设备的理想开发平台。 提示符[root@localhost ~]# # 表示当前权限为超级管理员root(最高的管理级别,说白了就是我想干啥就干啥)$ 表示普通用户的权限root 表示当前用户为root@ 表示在本地localhost 表示主机的名称~ 表示当前的路径(注意:~是用户家目录的简写,root的家目录为/root,普通用户的家目录为/home/用户名) 查询/帮助命令查看系统内核版本1uname -r ls命令:查看指定/当前路径中有哪些文件或目录1234567891011121314# 直接使用 ls, 表示显示当前路径下的内容,其余ls的复杂命令同理lsllll -d# 只显示指定目录下内容的名称ls /# 显示指定目录下内容的详细信息,简写为 llls -lll# 直接查看当前目录的信息ll -d ll(ls -l):每个字段的含义12345678910111213141516171819202122232425# 查看根目录下的所有文件/目录的详细内容ll /total 68lrwxrwxrwx. 1 root root 7 Aug 8 2018 bin -&gt; usr/bindr-xr-xr-x. 5 root root 4096 Sep 17 11:01 bootdrwxr-xr-x 2 root root 4096 Jan 21 2019 datadrwxr-xr-x 19 root root 2980 Sep 17 12:38 devdrwxr-xr-x. 87 root root 4096 Sep 29 17:39 etcdrwxr-xr-x. 8 root root 4096 Sep 29 17:09 homelrwxrwxrwx. 1 root root 7 Aug 8 2018 lib -&gt; usr/liblrwxrwxrwx. 1 root root 9 Aug 8 2018 lib64 -&gt; usr/lib64drwx------. 2 root root 16384 Aug 8 2018 lost+founddrwxr-xr-x. 2 root root 4096 Apr 11 2018 mediadrwxr-xr-x. 2 root root 4096 Apr 11 2018 mntdrwxr-xr-x. 4 root root 4096 Sep 17 11:04 optdr-xr-xr-x 91 root root 0 Sep 17 12:38 procdr-xr-x---. 13 root root 4096 Sep 29 17:28 rootdrwxr-xr-x 26 root root 940 Sep 20 16:11 runlrwxrwxrwx. 1 root root 8 Aug 8 2018 sbin -&gt; usr/sbindrwxr-xr-x. 2 root root 4096 Apr 11 2018 srvdr-xr-xr-x 13 root root 0 Sep 17 16:44 sysdrwxrwxrwt. 8 root root 4096 Sep 29 17:41 tmpdrwxr-xr-x. 13 root root 4096 Aug 8 2018 usrdrwxr-xr-x. 19 root root 4096 Jan 21 2019 var 我们会发现每个文件或目录都具有相同的格式解析: 以根目录下的etc为例说明drwxr-xr-x. 87 root root 4096 Sep 29 17:39 etc 开头第一个字母: - : 表示文件 d : 表示目录 f : 表示块设备文件 c : 表示字符设备文件 l : 表示链接文件 p : 管道文件 s : 套接字文件 rwxr-xr-x 分为三个用户类型前三个字母属于文件所有者的权限(u)中间三个字母属于组内用户的权限(g)最后三个字母属于组外用户的权限(o) 文件下: - : 没有对应的权限 r : 可读 w : 可写 x : 可执行 目录下: - : 没有对应的权限 r : 可查询此目录下文件名数据，比如ls命令 w : 可以建立新目录/删除已存在目录/修改已存在的目录 x : 具有执行的权限，简单地说，就是可以将该目录转换成家目录的能力，比如cd 命令。注意，x权限对于目录是极其重要的，如果没有该目录，表示你不能切换到该目录，更不能对其子目录或者文件进行操作，即使你有“r/w”权限。 87 表示硬链接个数 root root 第一个root表示文件所有者 第二个root表示组名 4096 表示文件的大小,单位为字节 Sep 29 17:39 表示文件最后修改日期 etc 表示文件名 新建文件/目录 mkdir : 新建目录 touch : 新建文件 mkdir1234# 在根目录下新建一个名为aaa的目录mkdir /aaa# 查看ll / 进阶: 不加参数选项的mkdir只能建一层目录如果想要建立多层目录的话? 1234567# 在根目录下新建目录 /bbb1/bbb2/bbb3mkdir /bbb1/bbb2/bbb3 # 发现行不通# 加上 -p 选项mkdir -p /bbb1/bbb2/bbb3 # 成功#查看ll /bbb1/bbb2 touch1234# 在根目录下新建一个名为qqq.txt的文件touch /qqq.txt# 查看ll / 进阶: 如果想要同时创建多个文件的话? 1234# 在根目录下同时创建名为q.txt w.txt e.txt 的三个文件touch /&#123;q,w,e&#125;.txt#查看ll / 删除文件/目录12345# 删除根目录下的 q.txtrm /q.txt# 暴力删除(不会出现操作提醒,直接删除)rm -rf /w.txt chmod 更改文件/目录权限方法一123456789101112131415161718192021222324252627282930# 首先在/opt/下创建一个111.txt文件touch /opt/111.txt# 改为满权限chmod 777 /opt/111.txt# 递归赋予权限(使"此时"该目录下所有的文件或目录的权限都变为777)mkdir /syzchmod -R 777 /syzll /# 在该目录下新建一个syz.txt文件touch /syz/syz.txtll -rw-r--r--. 1 root root 0 10月 8 18:54 syz.txt# 那么现在有一个问题:# 现在这个syz.txt,普通用户可以删除吗?# 你可能会说不可以,因为这个文件的普通用户权限为只读,没有可写可执行权限# 但是,其实是可以的# 因为,这个文件是在 777 权限的目录下# 所以,不懂得童鞋,去百度一下,目录的rwx 与 文件的rwx有什么不同...# 算了,说一下吧# 文件下: r: 可读(cat) w: 可修改(vim) x: 可以运行# 目录下: r: 可查看目录内容(ls) w: 可以增加/删除/修改目录里的内容(mkdir/rmdir/rm) x: 可以切换进该目录中(cd) 解析:777指的是按照rwxrwxrwx的(二进制)顺序排列的权限 r表示4w表示2x表示1 注:不清楚二进制的同学去百度或者问问其他的人 比如 rwxr-xr-x 在chmod中可以表示为755 明白了吧?很简单的ok 方法二123touch /opt/222.txtchmod u-x,g+w /opt/222.txtchmod o=r-x /opt/222.txt 或许有的同学不知道这个u是什么意思,其实细心的同学会发现,其实我在上面已经指出了它的含义了 来看: rwxrwxrwx 分为三组,这个都知道吧? 前面三个字符属于u(所有者)中间三个字符属于g(组内)后面三个字符属于o(组外) 如果还是不明白什么意思,不要着急,后面会具体的讲这些问题. u-x的意思就是,所有者的权限中去掉x权限g+x的意思就是,组内的权限中加上w权限 其余的以此类推,这里不做演示了 四个帮助命令123456789#此处以ls查看命令为例whatis lsls --helpman lsinfo ls 终端使用技巧 查询历史命令 123# history -c : 清空当前历史命令# history -w : 将历史命令保存到历史命令文件 /root/.bash_histroy 中history 清空终端屏幕 12# 快捷键 ctrl + lclear 安利一波😝: 上下键调用历史命令Tab建自动补齐 –&gt; 补齐:命令/文件名/目录名!$ –&gt; 调用上一条命令中的最后一个参数!keyword –&gt; 调用历史命令中含有当前关键字的,距离当前时间最近的那一条命令date –&gt; 显示系统时间pwd –&gt; 打印当前目录 了解路径在Linux中,路径分为相对路径和绝对路径 / : 表示根目录.. : 上一级目录 cd命令为切换路径 我们先来看一下根目录下有哪些目录 12345# ls为查看当前或者指定路径下有哪些文件/目录ls /bin data etc lib lost+found mnt proc run srv tmp varboot dev home lib64 media opt root sbin sys usr website 由上面我们可以看到,根目录/下还有好多的子目录接下来我们使用cd命令来切换到根目录中的其中一个目录中 1cd /lib 切换目录之后,我们会发现提示符中的路径也发生了变化(由~变为了lib) 这种切换方式为绝对路径,因为是从/目录下开始的 我们当前路径在根目录/lib下 我们使用ls命令来查看lib目录下又有哪些子目录 123456lsbinfmt.d dracut gcc kernel modules-load.d python3.6 sse2 tunedcpp firewalld grub locale NetworkManager rpm sysctl.d udevcrda firmware kbd modprobe.d polkit-1 sendmail systemd yum-pluginsdebug games kdump modules python2.7 sendmail.postfix tmpfiles.d 🐦🐦🐦🐦…我举个例子来说明一下绝对路径吧 假设我们的当前用户是root,家目录在/root,我们需要查看根目录下的很多目录 如果按照上面的办法,先使用cd命令切换目录,然后再用ls查看的话太过于麻烦,怎么办呢? 这时候绝对路径就派上用场了 12# 在当前目录 /root 下查看 /lib/python3.6 目录中的内容ls /lib/python3.6 也就是说,绝对路径是以根目录为起点的一个树状完整目录 🐓🐓🐓🐓…那什么是相对路径呢 假设我们现在已经使用cd命令切换到了根目录/下,我们想要查看根目录下lib目录下的python3.6,怎么办?难道还是用ls /lib/python3.6吗? 可以是可以,但是显然再使用绝对路径就有点繁琐了 我们可以使用相对路径因为我们当前已经在根目录下了,所以不必再加上/ 1ls lib/python3.6 也就是说,相对路径是以当前路径为基准进行命令操作 也许你可能会说,不就是差了一个/号吗?我这里只是举了一个例子来演示,实际情况下,能用相对路径就用相对路径,其余就使用绝对路径 举个例子吧 比如我们现在所在的路径是/lib/python3.6,我们想要查看/etc/rpm/目录下的内容,这时候使用相对路径就有点不切实际了,应该使用绝对路径来查看 懂了吧? ok👌 Linux下的常见目录含义 boot : 相关的启动文件(引导程序,kernel等) etc : 配置文件 tmp : 进程产生的临时文件存放位置 var : 存放经常变化的数据(数据库,日志,邮件,定时) media : 设备挂载目录 mnt : 进程挂载 bin : 普通用户使用的命令 –&gt; /usr/bin sbin : 管理员使用的命令 –&gt; /ust/sbin dev : 设备文件 proc : 虚拟的文件系统/进程实时状态信息 usr : 系统文件 文件操作命令vim编辑器的用法具体用法见我的这篇博客vim的使用方法 123# 当前目录下如果文件存在,会直接进入该文件中vim test.txt# 当前目录下不存在,会在当前目录下新建一个名为test.txt的文件 进入后想要退出的话::wq –&gt; 保存并且退出:!q –&gt; 不保存强制退出 用户的家目录与虚拟控制台用户的家目录问题超级用户root的家目录 : /root普通用户的家目录 : /home/zhangsan001 如何新建普通用户: useradd zhangsan001passwd zhangsan001 su - zhangsan001(切换身份的同时也切换家目录)su zhangsan001(只切换身份) 虚拟控制台的使用技巧切换方式:ctrl+alt+F2-F6返回方式:alt+F1测试方式:who和who am i 重定向技术查看文件内容的命令more: 不一次性的输出所有内容 123# 使用more命令查看passwd# 按下空格不断进行输出more /etc/passwd cat: 一次性输出所有内容 12# 使用cat命令查看passwdcat /etc/passwd 输出重定向符号: &gt;形式: 覆盖 12345ls &gt; abc.txtcat abc.txt #查看pwd &gt; abc.txt #覆盖abc.txt之前的文本内容cat abc.txt #查看 追加重定向符号: &gt;&gt;形式: 追加 1234ll &gt;&gt; abc.txtpwd &gt;&gt; abc.txt#查看cat abc.txt 错误重定向符号: 2&gt;形式: 覆盖 12345geafasdsa 2&gt; abc.txtcat abc.txtetgasr 2&gt; abc.txtcat abc.txt 全部重定向符号: &amp;&gt;形式: 覆盖 123456# 正确命令pwd &amp;&gt; aaa.txtcat aaa.txt# 错误命令afssafa &amp;&gt; aaa.txtcat aaa.txt find命令顾名思义,find是查找的意思 参数: -type : 查找类型(f为文件类型,d为目录类型) -user : 查找内容的所有者 -name : 查找内容的名称 -iname : 查找内容不区分大小写 123456789101112131415# 试着把find与重定向组合使用# 查找根目录下,类型为文件,文件所有者为zhangsan001的文件,重定向到abc2.txt中find / -type f -user zhangsan001 &gt; abc2.txtfind / -type f -user zhangsan001 2&gt; abc3.txtfind / -type f -user zhangsan001 &amp;&gt; abc4.txt#按文件名查找名字中含有abc的文件或目录find / -name "*abc*"#按类型查找名字中含有abc的目录find / -name "*abc*" -type d#按用户查找find / -name "*abc*" -type f -user zhangsan001 高级技巧: 12345# 以张三身份建立三个文件abc1.txt,abc2.txt,abc3.txt# 测试查找这三个文件find / -name "*abc*" -type f -user zhangsan001# 高级技巧:查找并删除find / -name "*abc*" -type f -user zhangsan001 -exec rm -rf &#123;&#125; \; mv移动命令的四种用法12345678910# 新建一个111.txttouch 111.txt# 把111.txt移动到/home/zhangsan001/目录下,并重命名为222.txtmv 111.txt /home/zhangsan001/222.txt# 新建一个222.txt文件,把222.txt移动到/root/目录下mv 222.txt /root/# /home/zhangsan001/目录下已经存在222.txt,尝试强力覆盖mv -f /root/222.txt /home/zhangsan001/# 移动目录mv /root/qqq /home/zhangsan001/ cp复制命令的四种用法12345678910# 复制当前目录下的 222.txt 文件到根目录下,并重命名为 333.txtcp 222.txt /333.txt# 复制当前目录下的 333.txt 到 /home/zhangsan001/ 目录下cp 333.txt /home/zhangsan001/# 如果目标位置出现同名文件，则不覆盖；如果想覆盖，可以使用 \cp 333.txt /cp -n 333.txt /# 复制目录,需要加上 -r 参数cp -r qqq /# 繁琐目录下的文件备份方法cp /etc/sysconfig/network-scripts/&#123;ifcfg-enp2s0,ifcfg-enp2s0.bak&#125; grep在文件内容中查找格式：grep key filename 12345678910111213141516# 新建一个qqq.txt并写入内容touch qqq.txtecho -e "hello\nworld\nsafasfss\nasfsadasd\nword\nasfasfswordasfasf\nsafsafadfa\nfsaferfasasfword\n32114asfasr\n12434word" &gt; qqq.txt# 使用grep进行行的筛选grep word qqq.txt# 把上面命令的结果重定向到qqq1.txt中grep word qqq.txt &gt; qqq1.txtcat qqq1.txt# 新建一个aaa.txt,并写入内容touch aaa.txtecho -e "asafasd\nnetworkgefsafas\nafasfasfsarsfanetwork\aadfff\n12413315535networkasfarfwas\nasfasfasfnetwork"# 筛选以network开头的行grep "^network" aaa.txt# 筛选以network结尾的行grep "network$" aaa.txt 用户与组管理用户管理之useradd命令1234# 添加一个名为a001的新用户useradd a001# 设置密码passwd a001 Linux系统底层的四个连锁反映当添加好新用户时系统自动创建该用户的家目录/home/a001vim /etc/passwd（多了一行该用户的记录）vim /etc/shadow（影子文件中多一行密码记录）vim /etc/group（组信息文件中多一行记录，即自动创建同名组） /etc/passwd 七个字段的含义1234a001:x:504:505::/home/a001:/bin/bash# 用户名:密码:用户ID:组ID:用户描述:家目录:shell# 如何把普通用户改为超级管理员 -&gt; 把该用户的用户ID改为0 /etc/group 四个字段的含义a001:x:505:test:x:502:harry,sam组名:组密码:组ID:该组中包含的其他用户名 /etc/shadow 九个字段的含义权限 000 1234567891011121314151617181920a001:$6$9./UcZIY$GWuGRx6h7O4MEd3GHMyUylHCZRVkbwPoqg.98A/ogjXoNlylqzhjncXjO..vK7OTLaNLPKL8a8NII0C1i4ZIK0:16000:0:99999:7:::# 用户名:加密后的密码:密码最后一次修改日期:两次密码的修改时间间隔:密码有效期:密码到期的警告时间:密码过期后的宽限天数:账号失效时间:保留字段# 解析:# 1. 用户名# 2. 加密后的密码 -&gt; 密码只是单独的 *或!! ,说明没有密码,无法登陆,也就是禁用了该用户# 3. 密码最后一次修改日期 -&gt; 以1970年1月1日作为标准时间,每过一天时间戳 +1# 4. 两次密码的修改时间间隔 -&gt; 和第三个字段相比,比如这里设置为10,那么这十天之内不可以该用户不可以修改密码# 5. 密码有效期 -&gt; 可以自行修改,一般是99999,意思是99999天内有效,不用管,除非你能活这么长时间# 6. 密码到期的警告时间 -&gt; 比如这里为7,在密码有效期还剩7天时,会自动警告# 7. 密码过期后的宽限天数 -&gt; 密码有效期内没有修改密码,可以再宽限你几天,具体几天看数值(可自定义),0 代表密码过期后立即失效, 1 代表密码永远不会失效# 8. 账号失效时间 -&gt; 需要用时间戳表示,就算密码有效期还没有到,只要我们设置了比有效期还要短的天数,那么密码也会立即失效# 9. 保留字段# 时间戳换算成年月日的方法date -d "1970-01-01 19999 days"# 年月日换算成时间戳的方法# 注意 +%s 要连在一起写echo $(($(date --date="2019-10-10" +%s)/86400+1)) 用户的邮箱路径:/var/spool/mail/用户名/ 在添加新用户时自动创建 用户模板目录路径:/etc/skel 12345678910111213141516171819202122# 我们新建用户后,在其家目录中其实会有一些隐藏文件cd /home/syzll -a 总用量 16 drwx------. 3 syz syz 99 10月 9 02:14 . drwxr-xr-x. 7 root root 70 10月 9 01:58 .. -rw-------. 1 syz syz 69 10月 9 02:14 .bash_history -rw-r--r--. 1 syz syz 18 8月 3 2017 .bash_logout -rw-r--r--. 1 syz syz 193 8月 3 2017 .bash_profile -rw-r--r--. 1 syz syz 231 8月 3 2017 .bashrc drwxr-xr-x. 4 syz syz 39 10月 6 11:12 .mozilla# 其实,这些隐藏文件都是从 /etc/skel文件下拷贝过来的ll -a /etc/skelll -a /etc/skel 总用量 24 drwxr-xr-x. 3 root root 78 10月 6 11:13 . drwxr-xr-x. 90 root root 8192 10月 10 18:32 .. -rw-r--r--. 1 root root 18 8月 3 2017 .bash_logout -rw-r--r--. 1 root root 193 8月 3 2017 .bash_profile -rw-r--r--. 1 root root 231 8月 3 2017 .bashrc drwxr-xr-x. 4 root root 39 10月 6 11:12 .mozilla 相关测试:shell测试1234# 新建用户a002,并设置不能本地登录# 参数 -s 表示设置shelluseradd -s /sbin/nologin a002 passwd a002 如何开启登录权限:直接修改/etc/passwd中的shell字段为/bin/login 注意：/sbin/nologin这种shell的典型应用场合是给FTP客户端用户来设置的。 其他参数测试123456789101112# -c : 用户描述# -d : 指定新账户的家目录# -m : 创建用户的家目录# -u : 指定用户的id# -d -m 通常组合使用# -g : 指定为第一所属组(第一所属组只能有一个)# -G : 指定为其他附属组useradd -c "ordinary user" -m -d /var/a003 -u 333 a003passwd a003# 查看tail -1 /etc/passwd# a003:x:333:507:ordinary user:/var/a003:/bin/bash 用户管理之userdel命令不彻底的删除方法123userdel a001# 查看tail -3 /etc/passwd 彻底的删除方法12# 同时删除对应的四个连锁反映userdel -rf a003 用户管理之usermod命令123456# 更改a002用户的idusermod -u 600 a002# 设置用户a002为不可本地登录usermod -s /sbin/nologin a002# 查看tail -3 /etc/passwd 组管理之groupadd命令1234# 新建一个名为g001的组groupadd g001# 查看tail -3 /etc/group 组管理之groupdel命令123456# 删除组g001groupdel g001# 查看tail -3 /etc/group# 不能删除用户的第一所属组groupdel a002 // cannot remove the primary group of user 'a002' (gpasswd,usermod)组和用户的关系12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 知识点1️⃣:gpasswd# 格式: gpasswd [选项] 用户名 组名# 把用户b001加入到组group1中# -a : 添加# -d : 删除gpasswd -a b001 group1# 同理gpasswd -a b002 group1gpasswd -a b003 group1# 查看tail -3 /etc/group group1:x:604:b001,b002,b003**********************************# 把b003从组group1中移除gpasswd -d b003 group1# 查看tail -3 /etc/group**********************************# 查看用户b001加入了哪些组groups b001 b001 : b001 group1# 我们会发现用户加入的新组归属于 其他附属组**********************************# 修改第一所属组的测试gpasswd -a a002 group1# 查看groups a002 a002 : a002 group1# 把group2作为用户a002的第一所属组# 知识点2️⃣:usermod# 格式: usermod [选项] 组名 用户名# usermod 的选项和useradd比较类似,基本上都是同一个意思# - g : 第一所属组# - G : 其他附属组# - c : 用户描述信息# - L : 临时锁定用户(锁定会会发现/etc/shadow文件中的一长串密码开头多了一个字符)# - U : 解锁用户(把/etc/shadow文件中变化的密码复原)usermod -g group2 a002groups a002 a002 : group2 group1********************************** # 修改附属组的测试groups b001 b001 : b001 group1 group2# 把组a002作为用户b001的其他附属组usermod -G a002 b001# 查看groups b001 b001 : b001 a002 chown命令的使用方法12345678910# 格式: chown 文件所有者:所属组名称 文件名称 # 把文件qqq1.txt的文件所有者和所属组改为 b001 和 group1 chown b001:group1 qqq1.txt# 把文件qqq1.txt的所属组改为root chown :root qqq1.txt# 把文件qqq1.txt的文件所有者改为b003chown b003: qqq1.txt(自动以该用户私有组替换) 注:一个用户创建的文件,如果想要另一个用户对该文件进行访问/修改/执行,可以把另一个用户加入到这个文件的所属组中,然后使用chmod命令修改该文件的组内权限即可 runlevel运行级别7种运行级别的含义:12345678910vim /etc/inittab 0 - halt #关机 1 - Single user mode #单用户模式 2 - Multiuser, without NFS (The same as 3, if you do not have networking) #多用户模式 3 - Full multiuser mode #完整多用户模式 4 - unused #备用 5 - X11 #支持图形界面 6 - reboot (Do NOT set initdefault to this) #重启 查看和改变运行级别的方法12345678910# 查看运行级别runlevel# 改变运行级别init n# 总结关闭系统的方法init 0shutdown -h now# 总结重启系统的方法rebootinit 6 破解超级用户root的密码 Centos 7重置root密码 重启系统，在grub引导菜单，选择第一项，按e编辑启动配置文件 找到 linux16开头的行，在该行最后添加rd.break 按crtl+x启动 以读写的方式挂载根目录 mount -o remount,rw /sysroot 切换根目录 chroot /sysroot 使用passwd命令重置密码(注意bug乱码) 创建重置SELinux安全上下文的文件 touch /.autorelabel 敲两次exit退出重启即可 高级权限UMASK反掩码root用户反掩码: 0022普通用户反掩码: 0002 如何查看反掩码1umask UMASK反掩码的作用目录的缺省权限值=777-UMASK反掩码文件的缺省权限值=777-UMASK反掩码-111 如何修改UMASK反掩码12345678910111213141516171819# 直接修改即可umask 0011*************************# root用户测试umaskmkdir 1111touch 1111.txt*************************# 普通用户测试useradd lisisu - lisi# 查看普通用户反掩码umask# 修改普通用户反掩码umask 0011mkdir 1111touch 1111.txt SUID权限弥补主要针对文件文件所有者执行位变为s或S(之前有x则为s,之前无x则为S,不懂的话没关系,继续往下看) /usr/bin/passwdpasswd命令执行的脚本文件 123ll /usr/bin/passwd #可以看到文件所有者的执行位为s-rwsr-xr-x. 1 root root 27832 Jun 10 2014 /usr/bin/passwd 测试SUID1234567891011121314151617181920212223# 新建一个普通用户useradd a001passwd a001# 切换至该普通用户su - a001# 尝试修改该用户的密码# 首先输入旧的密码,然后输入两遍新的密码passwd# 如果看到最后的提示字样 successfully,那么修改成功**********************************************# 返回root用户,去除passwd文件的SUID高级权限exitchmod u-s /usr/bin/passwd #去掉s后,普通用户便不可以自己修改密码ll /usr/bin/passwd# 再次切换到普通用户进行测试su - a001passwd# passwd: Authentication token manipulation error# 如果最后出现 error 的字样,说明该用户自己已经无法修改密码,只能root超级管理员来修改 s与S的区别12345678# 在上一步的基础上继续chmod u+s,u-x /usr/bin/passwdll /usr/bin/passwd #会发现所有者执行位变为了Schmod u+x /usr/bin/passwdll /usr/bin/passwd #会发现所有者执行位变为了s# 经过我的测试,无论是S还是s,都可以普通用户自己修改密码 SGID权限弥补主要针对目录 如果给某个目录加上了SGID高级,那么在这个文件中创建目录或者创建新文件,都将会继承这个目录的组 下面用例子来演示 1234567891011121314# 创建一个新组groupadd qqq# 在根目录下创建一个新目录mkdir /111# 更改目录111的组chown :qqq /111# 查看111目录ll /111# 给111目录增加高级权限SGIDchmod g+s /111# 测试mkdir /111/222touch /111/222.txtll /111/ STICK粘滞位主要针对共享目录 组外(其他用户)的执行位变为t linux中根目录下的tmp目录就是经典的例子 示例 1234567891011121314151617181920# 在根目录下创建一个共享目录sharemkdir /share# 给share目录高级权限STICKchmod o+t,o+w /share#创建两个新用户useradd zhangsanuseradd lisi# 切换至其中一个用户su - zhangsan# 在/share共享目录下新建一个以该用户为名的txt文件touch /share/zhangsan.txtexit# 切换至另一个用户su - lisi# 查看共享目录下的文件ll /share/# 试着删除该文件rm -rf /share/zhangsan.txt# 出现如下提示rm: 无法删除"/share/zhangsan.txt": 不允许的操作 ACL访问控制列表针对目录和文件 可以对一个文件设置用户的访问权限 设置文件的ACL信息123456789101112131415161718# 在根目录下新建一个txt文件touch /123.txt# 为123.txt设置aclsetfacl -m u:zhangsan:rw- /123.txt #设置用户zhangsan访问123.txt的权限只有读和写,没有执行权限setfacl -m u:lisi:r-- /123.txt# 查看123.txt,会发现后面多了一个加号+ll /# 查看acl信息getfacl /123.txt# 测试su - zhangsanvim /123.txt #写入内容,保存退出,成功exitsu - lisivim /123.txt #写入内容,保存退出提示不可写入exit 设置目录的ACL信息123456789101112mkdir /456# 参数d表示在/456目录下新建目录或文件会自动继承目录/456的ACL信息# 但要注意:ACL的真正效果仍然体现在对文件的操作上,对文件修改时才能看出效果setfacl -m d:u:zhangsan:rwx /456cd /456touch ttt.txtgetfacl ttt.txt# 当复制一个具有ACl属性的文件或目录时,默认情况下,ACL属性值是不会复制过去的# 只有在 cp 后加上 -p 参数才可以cp -p ttt.txt /tmp/cp_ttt.txt# 如果移动一个具有ACL属性的文件或目录时,则会同时把ACL属性移动过去 删除ACL信息123456# 不彻底的删除方式setfacl -x u:lisi /123.txt #虽然去掉了lisi的权限,但是使用ll进行查看, + 号仍然存在getfacl /123.txt# 彻底的删除一个文件或者目录的所有的ACL信息chacl -B /123.txt chmod知识补充sst = 421 = 7 chmod 7777 test.txt 相当于 rwsrwsrwtchmod 6777 test.txt 相当于 rwsrwsrwxchmod 4777 test.txt 相当于 rwsrwxrwx 以此类推 RPM软件包及YUM软件仓库的使用RPM软件包的使用技巧现在基本不用rpm了,但是应该还是要了解一下 12345678910# 如何查询指定软件包是否安装rpm -q vsftpd# 如何安装指定软件包# i:立即安装# v:显示安装进度# 哈希进度提示rpm -ivh ftp-0.17-51.1.el6.i686.rpm# 如何删除指定软件包rpm -e ftp #问题：依赖性关系(rpm -e httpd) 镜像文件的回环挂载含义回环设备（ ‘loopback device’）允许用户以一个普通磁盘文件虚拟一个块设备。设想一个磁盘设备，对它的所有读写操作都将被重定向到读写一个名为 disk-image 的普通文件而非操作实际磁盘或分区的轨道和扇区。（当然，disk-image 必须存在于一个实际的磁盘上，而这个磁盘必须比虚拟的磁盘容量更大。）回环设备允许你这样使用一个普通文件。 回环挂载的用法123456789101112# 查看centos镜像文件的大小du -sh CentOS-7-x86_64-DVD-1511.iso# 创建挂载目录mkdir /mnt/iso# 回环挂载# 注意自己镜像的位置和名称,没有镜像需要自己上传或下载到本地mount -o loop /CentOS-7-x86_64-DVD-1511.iso /mnt/iso# 查看cd /mnt/isoll# 查看映射情况df -Th 卸载目录的方法123456# 直接卸载即可umount /mnt/iso# 查看cd /mnt/isolldf -Th YUM软件仓库的配置及使用修改YUM软件仓库的配置文件一定要将目录切换到YUM软件仓库的工作目录/etc/yum.repos.d/下才有效工作目录下的配置文件必须以.repo结尾 1234567891011121314151617cd /etc/yum.repos.d/vim centos7.repo# 录入五个参数********************************[base] name=CentOS7baseurl=file:///mnt/isoenabled=1 gpgcheck=0********************************# ⬆️baseurl要填写绝对路径# ⬆️enabled 为启用软件仓库# ⬆️gpgcheck 为不校验软件包# 验证软件仓库的方法yum clean allyum list #会看到很多个软件包 YUM常见命令使用技巧123456789101112131415161718# 查询指定的软件包yum search vsftpd# 查询指定软件的详细信息# 可以判断该软件包是否安装yum info vsftpd# 如何安装指定的软件包yum install vsftpd# 如何删除指定的软件包yum erase vsftpd# 成组删除yum grouplist# 如果要显示成功安装信息，则之前系统中应该没有装vsftpd包才可以yum groupinstall 'FTP Server'yum groupinstall 'PHP 支持'# 查询可用软件包的版本全称yum whatprovides vim 通过指定的FTP服务器设置YUM软件仓库源12345[base]name=centos7baseurl=ftp://10.226.41.226/centos7enabled=1gpgcheck=0 通过真实的CentOS7服务器作为YUM软件仓库源1234567891011cd /etc/yum.repos.d/ls# 压缩gzip centos7.repo# 释放压缩gunzip CentOS-Base.repo.gzcat CentOS-Base.repo# 注意：一定要保证在连接外网的前提下测试yum clean all# yum repolist 会出现 11,971个包yum -y install mariadb-server YUM软件仓库源常见错误的解决方法（yum.PID）解决方法：按照提示信息将对应文件/run/yum.pid删除即可。 Crontab定时任务用户定时任务的使用技巧用户定时任务的格式Minute Hour Day Month DayofWeek Command分钟 小时 天 月 星期 命令 设置用户定时任务的步骤：123456# 切换用户身份su - zhangsan# 设置定时任务crontab -e #编辑该用户定时任务crontab -l #查看该用户定时任务crontab -r #删除该用户定时任务 实例123456789101112131415# a.zhangsan用户创建定时任务，要求：每天下午5:00关机。su - zhangsancrontab -e0 17 * * * shutdown -h now# b.lisi用户创建定时任务，要求：周一至周五朝九晚五每分钟发一条消息(wall 命令进行测试)。su - lisicrontab -e* 9-17 * * 1-5 wall "hello,I'am lisi"# c.lisi用户创建定时任务，要求：周一至周五朝九晚五每两小时发一条消息。* 9-17/2 * * 1-5 wall "hello,I'am lisi"# d.lisi用户创建定时任务，要求：周一至周五朝九晚五每两隔10分钟发一条消息。*/10 9-17 * * 1-5 wall "hello,I'am lisi" 管理员对用户定时任务的管理方法方法一：/var/spool/cron 用户定时任务的工作目录(查看;修改;删除),如果用户设置过定时任务,那么在该目录下会有与用户同名的文件 方法二：crontab -u lisi -l | -e | -r 用户定时任务的高级管理技巧黑名单文件 /etc/cron.deny //默认存在白名单文件 /etc/cron.allow //默认不存在,使用时,应删除cron.deny文件,再创建cron.allow文件,只有在cron.allow文件里的用户才可以设置定时任务 系统定时任务的使用技巧系统定时任务的工作目录/etc/cron.daily/ 日志回滚文件,该目录下的脚本文件每天会自动运行一次(触发时间:4:22) /etc/cron.hourly/ 该目录下的脚本文件每小时（第一分钟）会自动运行一次 /etc/cron.weekly 该目录下的脚本文件每星期（周日的4:22）会自动运行一次 /etc/cron.monthly/ 该目录下的脚本文件每个月（1号的4:22）会自动运行一次 anacron系统原理：系统定时任务的触发时间由于某种原因(例如停电)而错过了，anacron系统会保证系统定时任务工作目录下的脚本会弥补运行的一种机制。 123456vim /etc/anacrontab#period in days delay in minutes job-identifier command1 5 cron.daily nice run-parts /etc/cron.daily7 25 cron.weekly nice run-parts /etc/cron.weekly@monthly 45 cron.monthly nice run-parts /etc/cron.monthly FS Management(文件系统管理)Linux下的磁盘分区及其表示方法磁盘的表示方法/dev/sda—第一块磁盘(针对SCSI或串口磁盘)/dev/sdb—第二块磁盘/dev/sdc—第三块磁盘 /dev/hda,/dev/hdb,/dev/hdc,….(传统的IDE磁盘)/dev/vda,/dev/vdb,/dev/vdc(虚拟磁盘) 分区的表示方法/dev/sda1—第一块磁盘的第一个分区/dev/sda2—第一块磁盘的第二个分区/dev/sdb1—第二块磁盘的第一个分区/dev/hda1—第一块磁盘的第一个分区(传统的IDE磁盘)/dev/vdc5/dev/vdb3 主分区,扩展分区和逻辑分区一块400G的硬盘C—100G—/dev/sda1(主)D—50G—/dev/sda2(主)E—50G—/dev/sda3(主)/dev/sda4(扩展分区) F—50G—/dev/sda5 G—50G—/dev/sda6 H—50G—/dev/sda7 I—50G—/dev/sda8 结论： 主分区的个数至多4个； 扩展分区是一个容器，其中可以包含多个逻辑分区； 扩展分区的大小=各个逻辑分区大小之和+未划分的扩展分区大小； 真正能使用的数据分区只能是主分区或者逻辑分区； 磁盘的剩余空间 = 扩展分区 - 各逻辑分区之和； 为虚拟机添加一块磁盘双击虚拟机 -&gt; show virtual machine details(灯泡的图案) -&gt; virtIO Disk 1 -&gt; 下方add hardword -&gt; bus type(scsi) -&gt; finish fdisk命令的使用技巧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# 查看是否添加成功df -Th# 为磁盘创建分区fdisk /dev/sdb# 下面是选项,n是添加分区,t是改变分区类型m print this menup print the partition tabled delete a partition(删除分区时，必须从后往前一个一个删除)n add a new partition(创建分区时，必须从前往后一个一个创建)t change a partitions system idl list known partition types # 常用分区类型 5 Extended 7 HPFS/NTFS b W95 FAT32 82 Linux swap 83 Linux –---------xfs, ext4, ext3,ext2 8e Linux LVMw write table to disk and exitq quit without saving changesThe device presents a logical sector size that is smaller thanthe physical sector size. Aligning to a physical sector (or optimalI/O) size boundary is recommended, or performance may be impacted.欢迎使用 fdisk (util-linux 2.23.2)。更改将停留在内存中，直到您决定将更改写入磁盘。使用写入命令前请三思。********************************************************************^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^演示⬇️# 1️⃣第一步:添加分区,有些地方默认回车就可以,到 LAST 扇区 那里,需要填好分区的大小命令(输入 m 获取帮助)：nPartition type: p primary (2 primary, 0 extended, 2 free) e extendedSelect (default p): p分区号 (3,4，默认 3)：起始 扇区 (21979136-67108863，默认为 21979136)：将使用默认值 21979136Last 扇区, +扇区 or +size&#123;K,M,G&#125; (21979136-67108863，默认为 67108863)：+5G分区 3 已设置为 Linux 类型，大小设为 5 GiB# 2️⃣第二步:p命令查看是否添加成功命令(输入 m 获取帮助)：p磁盘 /dev/sdb：34.4 GB, 34359738368 字节，67108864 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 4096 字节I/O 大小(最小/最佳)：4096 字节 / 4096 字节磁盘标签类型：dos磁盘标识符：0x6bfb58cf 设备 Boot Start End Blocks Id System/dev/sdb1 2048 20973567 10485760 83 Linux/dev/sdb2 20973568 21979135 502784 82 Linux swap / Solaris/dev/sdb3 21979136 32464895 5242880 83 Linux# 3️⃣第三步:改变分区的类型命令(输入 m 获取帮助)：t分区号 (1-3，默认 3)：3Hex 代码(输入 L 列出所有代码)：82已将分区“Linux”的类型更改为“Linux swap / Solaris”# 4️⃣第四步:再次查看是否改变成功命令(输入 m 获取帮助)：p磁盘 /dev/sdb：34.4 GB, 34359738368 字节，67108864 个扇区Units = 扇区 of 1 * 512 = 512 bytes扇区大小(逻辑/物理)：512 字节 / 4096 字节I/O 大小(最小/最佳)：4096 字节 / 4096 字节磁盘标签类型：dos磁盘标识符：0x6bfb58cf 设备 Boot Start End Blocks Id System/dev/sdb1 2048 20973567 10485760 83 Linux/dev/sdb2 20973568 21979135 502784 82 Linux swap / Solaris/dev/sdb3 21979136 32464895 5242880 82 Linux swap / Solaris# 5️⃣第五步:保存退出命令(输入 m 获取帮助)：wThe partition table has been altered!Calling ioctl() to re-read partition table.WARNING: Re-reading the partition table failed with error 16: 设备或资源忙.The kernel still uses the old table. The new table will be used atthe next reboot or after you run partprobe(8) or kpartx(8)正在同步磁盘。 更新磁盘分区表的方法123456# 不重启,立即生效partprobe# 重启后生效reboot# 检查分区是否格式化成功cat /proc/partitions 格式化磁盘分区的方法常用格式:ext2,ext3,ext4,xfs,swap,vfat (1)mkfs.xfs /dev/sdb1(2)mkfs.ext4 /dev/sdb2(3)mkfs.ext3 /dev/sdb5(4)mkfs.vfat /dev/sdb3 (注意:在使用fdisk创建/dev/sdb3时,要将其类型修改为FAT32格式)(5)mkswap /dev/sdb6 (注意:在使用fdisk创建/dev/sdb6时,要将其类型修改为SWAP格式) 注意：在格式化vfat的时候，会提示-bash: mkfs.vfat: command not found 解决： 1234567# 1. 查询yum provides mkfs.vfat #或者 yum whatprovides mkfs.vfat# 2. 复制查询出的包名# 3. 安装yum -y install dosfstools.x86_64 使用分区存放数据方法一:手动挂载12345678910111213# 创建一个挂载目录mkdir /mmm1# 挂载mount /dev/sdb2 /mmm1# 检查df -Th(要知道各个字段信息的含义)# 测试cd /mmm1touch 111.txtmkdir 111# 卸载目录umount /mmm1df -Th 方法二:自动挂载12345678910vim /etc/fstab# 文件前三个字段的含义# 设备文件名/dev/sda1 挂载目标目录/ 设备文件名对应的分区的类型ext4/dev/sdb2 /mmm1 ext4 defaults 0 0# 查看挂载情况df -Th #发现没有挂载上# 重启mount -a# 再次查看,挂载成功df -Th 方法三:UUID挂载1234567891011blkid #显示已格式化的分区的UUID信息# 注意：各物理设备的 UUID 号是系统定义好的，唯一的，用户无法修改。# 方法一：通过mount命令实现手动挂载mount UUID="0ef71ac1-ac8a-4be9-821e-d98bc21e23f7" /sdb1# 方法二:通过/etc/fstab文件实现开机自动挂载vim /etc/fstab UUID="0ef71ac1-ac8a-4be9-821e-d98bc21e23f7" /sdb1 ext4 defaults 0 0# 重启mount -a swap交换分区的管理物理分区实现swap分区大小的变化12345678910111213#查看内存的详细信息，其中包括交换分区的大小free total used free shared buff/cache availableMem: 1877420 157032 1530176 9108 190212 1568576Swap: 2097148 0 2097148# 查看swap分区的信息 cat /proc/swaps # 或(两者效果相同)swapon -s文件名 类型 大小 已用 权限/dev/dm-1 partition 2097148 0 -2 计算swap的差值12345# 要求将swap分区调整到2600000K# 已有swap分区大小为 2097148k# 使用 expr 命令来计算剩余所需大小expr 2600000 - 2097148502852 #需要创建一个502852k大小的swap分区 创建一个大小为502852大小的物理分区并将该分区类型修改为swap1234567891011121314151617181920# 创建分区并修改类型(不会的同学翻阅上一节笔记,不要懒惰哦😊)fdisk /dev/sdb # swap的代号为 82# 格式化/dev/sda1 的磁盘mkswap /dev/sdb2# 修改/etc/fstab文件实现开机自动挂载# 永久生效!!!vim /etc/fstab/dev/sdb2 swap swap defaults 0 0# 注意：修改完开机自动挂载文件/etc/fstab后，使用mount -a 命令对SWAP分区无效# 必须重启!!!!!!!!!!!!!!!!swapon -s # 发现没有sdb2# 手动挂载,激活交换分区swapon /dev/sda1# 验证swapon -sfree# 手动卸载swapoff /dev/sda1swapon -s LVM逻辑卷管理物理分区和物理卷逻辑过程: 物理分区 -&gt; 物理卷 123456789101112# 创建分区fdisk /dev/sdb# 创建物理卷pvcreate /dev/sdb5# 删除物理卷# 如果该物理卷已经加入到了 卷组 中,并且该 卷组 已经创建了 逻辑卷# 那么应该首先释放该 物理卷 中的 PE 块, pvmove /dev/sdb5# 然后把该物理卷从 卷组 中移除, vgreduce vg9 /dev/sdb5# 然后就可以删除 物理卷 了pvremove /dev/sdb5# 查看物理卷pvdisplay 卷组关系: 物理卷 + 物理卷 + … = 卷组卷组可以包含多个物理卷并且卷组的大小可以动态的调整 如何创建卷组 123456789101112# 格式: vgcreate 卷组名 物理卷1 物理卷2 ...vgcreate vg9 /dev/sdb1 /dev/sdb2# 删除卷组vgremove vg9# 移除卷组中的物理卷vgreduce vg9 /dev/sdb5#查看卷组vg9的基本信息vgdisplay -v vg9 # 查看卷组vg9的使用情况vgdisplay -s PE(物理块):它是卷组创建时要指定的基本逻辑单位，4M(默认),8M,12M…(4的整数倍即可) 逻辑卷从卷组中划拨出逻辑卷逻辑卷的大小也可以动态的调整约束条件：以PE的整数倍进行增加或减小 小提示💡:逻辑卷所占用的PE，可以跨越不同的物理卷 123456789# 创建逻辑卷# 格式: lvcreate -n 逻辑卷名称 -L 逻辑卷大小(加不加单位都可以) 卷组名lvcreate -n lv0 -L 80 vg9 #创建了一个逻辑卷名称叫lv0,大小80M，位于卷组vg9中# 逻辑卷格式化mkfs.ext4 /dev/vg9/lv0 # 删除逻辑卷lvremove /dev/vg9/lv0# 查看lvdisplay 例题一动态的调整卷组的大小动态的调整逻辑卷的大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122创建三个物理分区，并将它们指定成三个大小都为100M的物理卷再建立一个卷组vg9,当中要包含两个物理卷在卷组vg9中创建两个逻辑卷lv0,lv1，大小分别是100M和40M,要求分别用xfs和ext4格式化，并自动挂载到目录/lvm0和/lvm1上要求动态增加lv0是20M，减小lv1的大小12M从卷组vg9中添加、删除物理卷进行测试# 第一步:创建三个大小为100M的物理分区/dev/sdb5,/dev/sdb6./dev/sdb7,类型都改为 8efdisk /dev/sdbpartprobe #刷新fdisk -l #查看****************************************************************************# 第二步:将物理分区/dev/sdb5建立成物理卷/dev/sdb5pvcreate /dev/sdb5pvcreate /dev/sdb6pvcreate /dev/sdb7# 查看pvdisplay****************************************************************************# 第三步:把其中两个物理卷加入到新建的卷组vg9中# 创建卷组vg9,包含物理卷/dev/sdb5和/dev/sdb6,默认PE大小4Mvgcreate vg9 /dev/sdb5 /dev/sdb6# 查看vgdisplay -v****************************************************************************# 第四步:创建逻辑卷# 新建名为lv0,大小为100M的逻辑卷 lvcreate -n lv0 -L 100 vg9 # 新建名为lv1,大小为40M的逻辑卷 # -l : PE的个数,如果不做修改的话,PE默认大小为4M# -L : 直接设置逻辑卷的大小lvcreate -n lv1 -l 10 vg9# 查看lvdisplay****************************************************************************# 第五步:对逻辑卷进行格式化mkfs.xfs /dev/vg9/lv0mkfs. ext4 /dev/vg9/lv1# 查看UUIDblkid****************************************************************************# 第六步:创建目标目录/lvm0和/lvm1mkdir /lv0mkdir /lv1****************************************************************************# 第七步:挂载# 方式一:手动挂载mount /dev/vg9/lv0 /lv0# 方式二:开机自动挂载# 不要用UUID挂载,有问题vim /etc/fstab /dev/vg9/lv0 /lv0 xfs defaults 0 0# 重启mount -a# 查看df -Th****************************************************************************# 第八步:增加文件系统的大小# 增加文件系统大小 不必卸载 文件目录# 1. 增加逻辑卷容量lvresize -L +20M /dev/vg9/lv0 #增加逻辑卷lv0大小20M# 注意：此时仅仅增加的是 逻辑卷lv0 的大小；lvdisplay# 逻辑卷 lv0 对应的 文件系统的大小 并未增加# 测试方法：mount 命令将其挂载到目标目录上，用df -Th看其对应的文件系统大小仍然为100M# 正确解法:# 增加文件系统大小,目录一定要处于挂载上的状态,不然无法更新# 2. 更新xfs_growfs /dev/vg9/lv0 #更新逻辑卷lv0所对应的 xfs 文件系统的大小# 或者resize2fs /dev/vg9/lv0 #更新逻辑卷lv0所对应的 ext4, 3 文件系统的大小# 再次用df -Th看文件系统大小也为120M了**************************************************************************# 第九步:减小文件系统的大小# 1. 跟增加不同的是,ext4减小需要卸载目录,不先卸载文件目录的话会报错umount /lv1# 2. 更新resize2fs /dev/vg9/lv1 28M #更新逻辑卷lv1所对应的ext2,3,4文件系统减小至28M# 运行上边的命令会提示先运行 e2fsck -f /dev/vg9/lv1 ，要求先检查文件系统，运行该条命令就没有问题了。# 3. 将逻辑卷lv1的大小减小至28Mlvresize -L -12M /dev/vg9/lv1 mount -a# 查看df -Th**************************************************************************# 第十步:向卷组vg9中添加新的物理卷vgextend vg9 /dev/sdb7vgdisplay -v**************************************************************************# 第十一步:从卷组vg9中删除物理卷#释放与物理卷/dev/sdb5包含的PEpvmove /dev/sdb5 #从卷组vg9中删除物理卷/dev/sdb5vgreduce vg9 /dev/sdb5 #查看卷组vg9的基本信息vgdisplay -v vg9 # 查看卷组vg9的使用情况vgdisplay -s # 注意：逻辑卷/dev/vg9/lv0所占用的PE可以跨越不同的物理分区 例题二创建逻辑卷database,属于卷组datastore逻辑卷的大小为10个扩展物理单元(PE)PE的大小为16M使用xfs文件系统格式化该逻辑卷,并自动挂载到/mnt/database上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778# 第一步:创建三个物理分区，大小都为160M，类型为8efdisk /dev/sdb 8 24 171089 sdb8 8 25 171089 sdb9 8 26 171089 sdb10**************************************************************************# 第二步:创建物理卷pvcreate /dev/sdb8pvcreate /dev/sdb9pvcreate /dev/sdb10pvdisplay**************************************************************************# 第三步:创建卷组datastore,PE为16M,包含/dev/sdb8,/dev/sdb9# -s : 设置PE的大小vgcreate -s 16M datastore /dev/sdb8 /dev/sdb9# 查看vgdisplay -v datastore**************************************************************************# 第四步:创建逻辑卷database,大小为10个PE,即160M，并用xfs格式化。lvcreate -l 10 -n database datastore# 查看lvdisplay# 格式化为xfs格式mkfs.xfs /dev/datastore/database# 查看UUIDblkid**************************************************************************# 第五步:创建目标目录/mnt/databasemkdir /mnt/database**************************************************************************# 第六步:修改自动挂载文件vim /etc/fstab /dev/datastore/database /mnt/database xfs defaults 0 0# 重启mount -a# 查看df -Th /dev/mapper/datastore-database xfs 154M 8.3M 146M 6% /mnt/database**************************************************************************# 第七步:调整逻辑卷database及其文件系统的大小为240M.lvresize -L +80M /dev/datastore/database #增加逻辑卷大小80Mxfs_growfs /dev/datastore/database #更新逻辑卷所对应的xfs文件系统的大小。# 查看df -Thlvdisplay**************************************************************************# 第八步:调整逻辑卷database及其文件系统大小为80Mlvresize -L -160M /dev/datastore/database #将逻辑卷的大小减小160Mxfs_growfs /dev/datastore/database #更新逻辑卷所对应的xfs文件系统的大小至80M。# 查看lvdisplay #逻辑卷的大小改变了df -Th #挂载目录大小没变# 发现挂载目录大小并没有改变# 这是因为xfs格式只能增加,无法减小!!!!!!!!!!!!!# 若是非要减小,只能重新格式化# 这样做的话,文件里的东西就都被格式化了,不建议如此操作# 如果真的想这么做,命令如下⬇️:lvresize -L -160M /dev/datastore/database #将逻辑卷的大小减小160Mumount /dev/datastore/database #卸载目录mkfs.xfs -f /dev/datastore/database #强制格式化mount -a #重新挂载目录(之前已经配置过开机自启动)df -Th 网络环境配置配置静态IP地址12# 查看IPip a 配置防火墙12345678910111213141516171819202122232425262728# 查看防火墙规则状态是否为关闭systemctl status firewalld systemctl start firewalld #开启iptablessystemctl status firewalld #查看iptables的状态systemctl stop firewalld #关闭iptables# 查看SElinux的状态是否为关闭状态 getenforce getenforce #查看SELinux的状态setenforce 0 #关闭SElinuxsetenforce 1 #打开SElinux将SElinux设置为关闭状态的永久生效方法vim /etc/sysconfig/selinux #将 enforcing 改为 disabled # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=enforcing # SELINUXTYPE= can take one of three two values: # targeted - Targeted processes are protected, # minimum - Modification of targeted policy. Only selected processes are protected. # mls - Multi Level Security protection. SELINUXTYPE=targeted 删除旧的IP地址1ip addr del 192.168.122.51/24 dev eth0 配置新的静态IP地址1234567891011121314vim /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE="eth0" BOOTPROTO="static" ONBOOT="yes" TYPE="Ethernet" IPADDR=192.168.122.100 //IP地址 PREFIX=24 //子网掩码 GATEWAY=192.168.122.1 //网关 DNS1=202.207.48.3 //DNS服务器# 重启网络服务systemctl restart network ip a #IP地址已经被修改成了192.168.122.100 配置动态IP地址12345678910111213141516171819# 查看防火墙规则状态是否为关闭systemctl status firewalld # 查看SElinux的状态是否为关闭状态getenforce# 删除旧的IP地址ip addr del 192.168.122.100/24 dev eth0# 配置新的动态IP地址vim /etc/sysconfig/network-scripts/ifcfg-eth0 DEVICE="eth0" BOOTPROTO="dhcp" ONBOOT="yes" TYPE="Ethernet" # 重启网络服务systemctl restart networkip a #IP 地址已经被修改成了192.168.122.X 补充知识临时绑定多个IP地址当网卡eth0ip addr add 192.168.122.X/24 dev eth0ip a //可以查看到新绑定的IP地址 注意：如果重启网络服务（systemctl restart network ），则使用 ip addr del 192.168.122.51/24 dev eth0或者ip addr add 192.168.122.X/24 dev eth0命令删除或添加的IP地址会失效。 修改主机名方法一：使用hostnamectl set-hostname 51命令，将主机名修改为51注意：需要退出并重新登录后方可生效，主机名一旦修改，永久生效。 方法二：使用“vim /etc/hostname”命令，修改主机名配置文件，直接将文件中原来的主机名localhost.localdomain修改为新主机名重新登录或者重启系统后，新主机名就会生效。 压缩与解压缩tar命令(归档)的使用创建tar包1234# -c 创建归档包# -v 显示详细的提示信息# -f 指定文件名tar -cvf etc.tar /etc 创建压缩的tar包两种压缩技术: gzip 和 bzip gzip: ***.gz12345# 在tar命令中添加一个参数 -ztar -zcvf bgl.tar.gz /etc #压缩目录# 查看压缩包的大小du -sh etc.tar.gztar -zcvf file.tar.gz 111.txt 222.txt #压缩文件 bzip2: ***.bz2123# 在tar命令中添加一个参数 -jtar -jcvf etc.tar.bz2 /etc #压缩目录tar -jcvf file.tar.bz2 111.txt 222.txt #压缩文件 查询tar包中包含的文件目录列表1234# -t 查看是否使用tar命令来归档的包# -f 指定文件名tar -tf aaa.tar.gztar -tf aaa.tar.bz2 释放tar包12345# 默认释放在当前目录下# 在tar命令中添加一个参数 -x# 一般情况下使用: -xf 即可tar -xzvf etc.tar.gztar -xjvf etc.tar.bz2 释放在指定目录下123# -C : 指定释放的目录mkdir /666tar -xjvf bgl.tar.bz2 -C /666 习题使用bzip2压缩,将/etc目录归档并压缩到/root/backup.tar.bz2 1tar -jcvf /root/backup.tar.bz2 /etc 压缩知识扩展gzip压缩的两种技术压缩技术一(gunzip,gzip)覆盖源文件的压缩技术,但无法压缩目录 参数: -d : 解压参数 -f : 强制覆盖以存在的同名压缩包 -v : 显示压缩过程 12345678# 压缩gzip -v &#123;1,2,3&#125;.txt #压缩效果是将源文件1.txt替换为1.txt.gz# 注意：使用gzip命令压缩后,源文件就不存在了。gzip -fv &#123;1,2,3&#125;.txt #如果目标位置有同名的压缩文件（1.txt.gz）存在，则覆盖# 解压gzip -d 111.txt.gz #解压的效果是将压缩文件111.txt.gz还原为111.txt。gunzip 111.txt.gz #gunzip命令与gzip -d的效果解压相同。 压缩技术二(tar.gz)归档压缩技术，同前 12345678# 压缩tar zcvf filename.tar.gz -C /tmp/ # 解压tar zxvf filename.tar.gz # 显示列表tar tf filname.tar bzip2压缩的两种技术压缩技术一(bunzip2,bzip2)覆盖源文件的压缩技术,但无法压缩目录 参数: -d : 解压参数 -f : 强制覆盖以存在的同名压缩包 -v : 显示压缩过程 1234567# 压缩bzip2 &#123;1,2,3&#125;.txt #压缩效果是将源文件1.txt替换为1.txt.bz2# 注意：使用bzip2命令压缩后，源文件就不存在了# 解压bzip2 -d 1.txt.bz2 #解压的效果是将压缩文件111.txt.bz2还原为111.txtbunzip2 1.txt.bz2 #效果同上 压缩技术二(tar.bz2)归档压缩技术，同前 123456789# 压缩tar jcvf filename.tar.bz2 descfilename# 解压 tar jxvf filename.tar.bz2 tar --bzip xvf filename.tar.bz2 # 列表tar tf filname.tar zip压缩技术不覆盖源文件的压缩技术 123456789101112# 压缩# 格式:zip filename.zip sourcefilenamezip 111.txt.zip 111.txt #压缩效果是将源文件111.txt压缩为111.txt.zip# 注意：使用该命令压缩后，源文件仍然存在# 压缩一个目录使用 -r 参数,-r 递归zip -r 222.zip 222 #将目录222压缩为222.zip，压缩后源目录仍然存在# 解压# 格式:unzip filename.zip unzip 222.zip #解压效果是将222.zip解压为222目录#注意：如果当前位置已经有222目录，则会提示是否覆盖 autofs自动挂载简介autofs自动挂载器是一个监视目录的守护进程，并在目标子目录被引用时，自动执行预定义的NFS挂载。自动挂载器由autofs服务脚本管理，自动挂载器由auto.master一级配置文件进行配置，该文件引用了一个按惯例称作/etc/auto.misc或其他类似名称的二级配置文件。autofs与NFS两者之间配合用的还是比较多的 使用目的autofs服务动态自动挂载各种文件系统。mount是用来挂载文件系统的，可以在启动的时候挂载也可以在启动后挂载。这就好像windows中的光驱自动打开功能，能够及时挂载动态加载的文件系统，免去了手动挂载的麻烦。在centos7.2系统下，对于本地固定设备，如硬盘可以使用mount挂载，而光盘，软盘，NFS，SMB等文件系统具有动态性，即需要的时候才有必要挂载，光驱和软盘一般知道什么时候需要挂载，但NFS，SMB共享等就不一定知道了，即一般不能及时知道NFS共享和SMB什么时候可以挂载，而autofs服务就提供这种功能，所以本章详细讲述了autofs自动挂载方式 需要安装的软件1234567# 安装yum -y install autofs*yum -y install nfs*# 重启systemctl start rpcbindsystemctl start nfs 测试要求:将分区 /dev/sdb1 自动挂载到 /misc/aaa 目录下 配置12345678910111213141516171819202122# 第一步: 利用 fdisk 添加一块新磁盘# 添加磁盘此处略过,不会的同学请去复习前面的内容,复习很重要哦# 要求格式化为 ext4格式mkfs.ext4 /dev/sdb1blkid++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++# 第二步: 具体配置# 打开一级文件vim /etc/auto.master #当访问/misc目录时,会自动查询二级文件/etc/auto.misc# 打开二级文件vim /etc/auto.misc #填入以下内容 aaa -fstype=ext4 :/dev/sdb2# 保存退出++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++# 第三步: 重启服务systemctl restart autofs++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++# 第四步: 切换目录,触发文件挂载机制cd /misc/aaa# 查看是否挂载成功df -Th NFS自动挂载简介NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样 NFS最显而易见的优点： 节省本地存储空间，将常用的数据存放在一台NFS服务器上且可以通过网络访问，那么本地终端将可以减少自身存储空间的使用。 用户不需要在网络中的每个机器上都建有Home目录，Home目录可以放在NFS服务器上且可以在网络上被访问使用。 一些存储设备如软驱、CDROM和Zip（一种高储存密度的磁盘驱动器与磁盘）等都可以在网络上被别的机器使用。这可以减少整个网络上可移动介质设备的数量 测试要求:将NFS服务器上发布的共享目录/home/guests/guest2019自动挂载到客户机的/home/guests/guest2019上 开两台虚拟机,一台作为服务器,另一台作为客户机来测试 服务器端配置1234567891011121314151617181920# 建立共享目录mkdir -p /home/guests/guest2019# 修改NFS主配置文件vim /etc/exports # 填入以下内容 /home/guests/guest2019 10.211.55.0/24(rw,sync,no_root_squash) # 解析: # IP 字段表示允许IP地址范围在 10.211.55.0 网段的计算机访问共享目录 “/home/guests/guest2006” # “rw”表示有读写权限 # “sync”表示数据同步写入内存和硬盘 # “no_root_squash”表示NFS服务器共享目录用户的属性，如果用户是root，那么这个共享目录具有root的权限# 重启服务systemctl restart nfs# 设置开机自启动systemctl enable nfs-server.service 客户端测试方式一:手动挂载123456789101112# 在客户机行新建一个挂载目录 /syzmkdir /syz# 查看NFS服务器发布的共享资源信息# 注意: 需要关闭服务器端的防火墙,不然会出现查询错误showmount -e 10.211.55.5# 手动挂载mount 10.211.55.5:/home/guests/guest2019 /syz# 查看是否挂载成功df -Th 方式二:autofs自动挂载1234567891011121314151617181920212223242526272829303132333435363738# 隐含原则：# 若将NFS服务器上发布的共享目录自动挂载到客户端的n层目录上# 则将前n-1层目录放置于一级文件中# 最后一层目录放入二级文件中# 并且除了最后一层目录，其他目录都需提前建立号好# 建立需要的目录mkdir /home/guests# 编辑一级文件vim /etc/auto.master # 填入以下内容 # auto.two_master 是我随便起的,自己编写一个记得住的名字即可 /home/guests /etc/auto.two_master# 编辑二级文件vim /etc/auto.two_master # 填入以下内容 guest2019 -fstype=nfs,rw 10.211.55.5:/home/guests/guest2019# 卸载 /syz 目录umount /syz# 查看是否卸载成功df -Th# 重启autofa服务systemctl restart autofssystemctl enable autofs# 切换目录,触发autofa挂载机制# 如果出现没有该目录,检查二级文件是否编写错误cd /home/guests/guest2019# 查看是否挂载成功df -Th]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awk的使用方法]]></title>
    <url>%2F2019%2F09%2F05%2Fawk%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[awk的使用awk的处理方式与格式awk的处理方式 awk一次处理一行内容 awk可以对每行进行切片处理 示例： 1awk '&#123;print $1&#125;' awk的格式命令行格式1awk [options] 'command' files command1:pattern {awk操作命令} 操作命令： 内置函数：print(),printf(),getline… 控制指令：if(){…}else{…},while() 脚本格式1awk -f awk-script-file file(s) 扩展格式BEGIN{…}{…}END{…} 示例： 以制表的形式输出passwd文件中的NR,NF,User 1awk -F ':' 'BEGIN&#123;print "Line\t Columns User"&#125;&#123;print NR"\t",NF"\t",$1&#125;END&#123;print "-------"FILENAME"-------"&#125;' passwd 结果： 123456789101112131415161718192021222324Line Columns User1 7 root2 7 bin3 7 daemon4 7 adm5 7 lp6 7 sync7 7 shutdown8 7 halt9 7 mail10 7 operator11 7 games12 7 ftp13 7 nobody14 7 systemd-network15 7 dbus16 7 polkitd17 7 abrt18 7 tss19 7 postfix20 7 chrony21 7 sshd22 7 mysql-------passwd------- awk的内置参数变量 $0 : 表示整个当前行 $1 : 表示第一个字段 $2 : 每行第二个字段以此类推 NR : 每行的记录号（行号） NF : 字段数（以分隔符为参照物） FILENAME : 正在处理的文件名示例： 1awk -F ':' '&#123;print NR,NF&#125;' /etc/passwd 结果： 123456789101112131415161718192021221 72 73 74 75 76 77 78 79 710 711 712 713 714 715 716 717 718 719 720 721 722 7 1awk -F ':' '&#123;print FILENAME&#125;' /etc/passwd 结果： 12345678910111213141516171819202122/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd/etc/passwd ~ : 对变量进行更加详细的匹配 示例： 输出passwd文件中以a-c开头的用户名 1awk -F ':' '$1~/^[a-c].*/&#123;print $1&#125;' passwd 结果： 1234binadmabrtchrony 输出passwd文件中不以a-c开头的用户名 1awk -F ':' '$1!~/^[a-c].*/&#123;print $1&#125;' passwd 结果： 123456789101112131415161718rootdaemonlpsyncshutdownhaltmailoperatorgamesftpnobodysystemd-networkdbuspolkitdtsspostfixsshdmysql “&gt;,&lt;,==,!=” : 逻辑判断 示例： 输出passwd文件中UID大于80的用户名和UID 1awk -F ':' '$3&gt;80&#123;print $1,$3&#125;' passwd 结果： 1234567nobody 99systemd-network 192dbus 81polkitd 999abrt 173postfix 89chrony 998 分隔符options: -F field-separator(默认为空格) 示例： 打印passwd中的组id 1awk -F ':' '&#123;print $3&#125;' /etc/passwd 结果： 12345678910111213141516171819202122012345678111214991928199917359899987427 打印passwd中的用户名和组id 1awk -F ':' '&#123;print "USER:"$1," UID:"$3&#125;' /etc/passwd 结果： 12345678910111213141516171819202122USER:root UID:0USER:bin UID:1USER:daemon UID:2USER:adm UID:3USER:lp UID:4USER:sync UID:5USER:shutdown UID:6USER:halt UID:7USER:mail UID:8USER:operator UID:11USER:games UID:12USER:ftp UID:14USER:nobody UID:99USER:systemd-network UID:192USER:dbus UID:81USER:polkitd UID:999USER:abrt UID:173USER:tss UID:59USER:postfix UID:89USER:chrony UID:998USER:sshd UID:74USER:mysql UID:27 案例一显示/etc/passwd每行的行号，每行的列数，对应行的用户名（print,printf） 1awk -F ':' '&#123;print "Line: " NR,"Columns: "NF,"USER: "$1&#125;' /etc/passwd 结果： 12345678910111213141516171819202122Line: 1 Columns: 7 USER: rootLine: 2 Columns: 7 USER: binLine: 3 Columns: 7 USER: daemonLine: 4 Columns: 7 USER: admLine: 5 Columns: 7 USER: lpLine: 6 Columns: 7 USER: syncLine: 7 Columns: 7 USER: shutdownLine: 8 Columns: 7 USER: haltLine: 9 Columns: 7 USER: mailLine: 10 Columns: 7 USER: operatorLine: 11 Columns: 7 USER: gamesLine: 12 Columns: 7 USER: ftpLine: 13 Columns: 7 USER: nobodyLine: 14 Columns: 7 USER: systemd-networkLine: 15 Columns: 7 USER: dbusLine: 16 Columns: 7 USER: polkitdLine: 17 Columns: 7 USER: abrtLine: 18 Columns: 7 USER: tssLine: 19 Columns: 7 USER: postfixLine: 20 Columns: 7 USER: chronyLine: 21 Columns: 7 USER: sshdLine: 22 Columns: 7 USER: mysql 1awk -F ':' '&#123;printf("Line: %3s Columns: %s USER: %s\n",NR,NF,$1)&#125;' /etc/passwd 结果： 12345678910111213141516171819202122Line: 1 Columns: 7 USER: rootLine: 2 Columns: 7 USER: binLine: 3 Columns: 7 USER: daemonLine: 4 Columns: 7 USER: admLine: 5 Columns: 7 USER: lpLine: 6 Columns: 7 USER: syncLine: 7 Columns: 7 USER: shutdownLine: 8 Columns: 7 USER: haltLine: 9 Columns: 7 USER: mailLine: 10 Columns: 7 USER: operatorLine: 11 Columns: 7 USER: gamesLine: 12 Columns: 7 USER: ftpLine: 13 Columns: 7 USER: nobodyLine: 14 Columns: 7 USER: systemd-networkLine: 15 Columns: 7 USER: dbusLine: 16 Columns: 7 USER: polkitdLine: 17 Columns: 7 USER: abrtLine: 18 Columns: 7 USER: tssLine: 19 Columns: 7 USER: postfixLine: 20 Columns: 7 USER: chronyLine: 21 Columns: 7 USER: sshdLine: 22 Columns: 7 USER: mysql 案例二显示/etc/passwd中用户组id大于100的行号和用户名（if(){}else{}） 1awk -F ':' '&#123;if ($3&gt;100)&#123; print "Line: "NR,"USER: "$1&#125;else&#123;print "组id小于100，不与展示"&#125;&#125;' passwd 结果： 12345678910111213141516171819202122组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示组id小于100，不与展示Line: 14 USER: systemd-network组id小于100，不与展示Line: 16 USER: polkitdLine: 17 USER: abrt组id小于100，不与展示组id小于100，不与展示Line: 20 USER: chrony组id小于100，不与展示组id小于100，不与展示 案例三显示/etc/passwd中的带有nologin的行的USER信息和组id信息 12sed -n '/nologin/p' /etc/passwd | awk -F ':' '&#123;print "USER: "$1,"UID: "$3&#125;'awk -F ':' '/nologin/&#123;print "USER: "$1,"UID: "$3&#125;' /etc/passwd 结果： 1234567891011121314151617USER: bin UID: 1USER: daemon UID: 2USER: adm UID: 3USER: lp UID: 4USER: mail UID: 8USER: operator UID: 11USER: games UID: 12USER: ftp UID: 14USER: nobody UID: 99USER: systemd-network UID: 192USER: dbus UID: 81USER: polkitd UID: 999USER: abrt UID: 173USER: tss UID: 59USER: postfix UID: 89USER: chrony UID: 998USER: sshd UID: 74 案例四统计当前文件夹下的文件/文件夹占用的大小 1ls -l | awk 'BEGIN&#123;size=0&#125;&#123;size+=$5&#125;END&#123;print "size is " size "M"&#125;' 结果： 1size is 1495034M 案例五统计/etc/passwd的账户总人数 1awk -F ':' 'BEGIN&#123;count=0&#125;$1!~/^$/&#123;count++&#125;END&#123;print "Line is " count&#125;' passwd 结果： 1Line is 22 案例六统计UID大于100的用户名 1awk -F ':' 'BEGIN&#123;count=0&#125;&#123;if($3&gt;100) name[count++]=$1&#125;END&#123;for(i=0;i&lt;count;i++)&#123; print i,name[i]&#125;&#125;' passwd 有点蒙b… 案例七统计netstat -anp状态下为LISTEN和OCONNECTED的链接数量 1netstat -anp | awk '$6~/CONNECTED|LISTEN/&#123;sum[$6]++&#125;END&#123;for (i in sum) &#123;print i,sum[i]&#125;&#125;' 结果： 12LISTEN 3CONNECTED 42 祝你学习愉快～～～]]></content>
      <categories>
        <category>Linux</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql查询-条件查询]]></title>
    <url>%2F2019%2F08%2F26%2FMysql%E6%9F%A5%E8%AF%A2-%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Mysql查询-条件查询语法123456select 查询列表from 表名where 筛选条件; 分类条件表达式查询 条件运算符：&gt; , &lt; , = , != , &lt;&gt; , &gt;= , &lt;= 案例一：查询工资大于12000的员工信息 123456select * from employees where salary &gt; 12000; 案例二：查询部门编号不等于90的员工姓名和部门编号 1234567select last_name, department_idfrom employeeswhere department_id&lt;&gt;90; 逻辑表达式查询作用：用于连接条件表达式 逻辑运算符：&amp;&amp;, || , ！, and , or , not&amp;&amp;和and: 两个条件都为true， 结果为true，反之为false||和o 只要有一个为true，结果就为true！和no 如果链接的条件本身为false，结果为true，反之为false 案例一：查询工资在10000到20000之间的员工名、工资以及奖金 12345678select last_name, salary, commission_pctfrom employeeswhere salary &gt;=10000 and salary &lt;=20000 案例二：查询部门编号不是在90到110之间，或者工资高于15000的员工信息 123456select *from employeeswhere not(department_id&gt;=90 and department_id&lt;=110) or salary &gt; 15000; 模糊查询 like ， between ， in ，is null 1. like:特点： 一般和通配符搭配使用 【通配符】： % ：任意多个字符，包含0个字符 _ ：任意单个字符 案例一：查询员工名中包含字符a的员工信息 123456select * from employees where last_name like '%a%'; 案例二：查询员工名中第三个字符为e，第五个字符为a的员工名和工资 123456select last_name,salary from employees where last_name like '__n_l%'; 案例三：查询员工名中第二个字符为_的员工名 用转义字符 \ 或者下面这种方法 123456select last_namefrom employeeswhere last_name like '_$_%' escape '$'; 2. between and特点： 包含临界值 两个临界值不要调换顺序 提高了语句简洁度 案例一：查询员工编号在110到120之间的员工信息 123456select *from employeeswhere employees_id between 100 and 120; 3. in特点： 提高语句简洁度 in列表的值类型必须一致或兼容 不支持通配符 案例一：查询员工的年龄属于23，24，25岁的员工信息 123456select *from employeeswhere emp_age in (23,24,25); 4. is null特点： =或&lt;&gt;不能判断null值 is null 或 is not null 可以判断null值 案例一：查询没有奖金的员工信息 123456selsct *from employeeswhere commission_pct is null;]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql查询-基础查询]]></title>
    <url>%2F2019%2F08%2F25%2FMysql%E6%9F%A5%E8%AF%A2-%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Mysql查询-基础查询基础查询select 查询列表 from 表名;例如： 1select * from test; 查询单个字段1select id,name from test; 查询全部字段方式一（查询字段顺序可以自定义）： 1select id,name,age,sex from test; 方式二（不够灵活）： select * from test; 查询常量值12select 100;select 'john'; 查询表达式1select version( ); 起别名好处： 1. 便于理解 2. 如果要查询的字段有重名的情况，使用别名可以区分开来 方式一： 12select 100%50 as 结果;select last_name as 姓,first_name as 名 from test; 方式二： 1select last_name 姓,first_name 名 from test; 注意：如果别名中出现了特殊字符，需要用双引号引起来 去重关键字：distinct案例：查询所有员工的部门编号 1select distinct department_id from employees; + 号的作用（不能实现字段拼接）+ 号的功能：运算符 实例： 两个数都为数值型，则做加法运算 1select 100 + 100; 一个为字符型，一个为数值型，系统会尝试把字符型转换为数值型成功则继续运算，失败则把字符型的值视为数字0 12select "100" + 100;select "code" + 100; 拼接在mysql中进行拼接，不能用 +号，需要用到concat函数 123concat ('a','b','c') as 结果;select concat(last_name,first_name) as 姓名 from employees; 案例：显示所有员工的姓和名还有年龄，中间用-号进行连接 123select concat(last_name,'-',first_name,'-',age) as out_put from employees; 但是如果age字段有为空（NULL）的情况，查询就会出现问题可以使用IFNULL( )函数那么，语句可以这样写： 123select concat(last_name,'-',first_name,'-',ifnull(age,0)) as out_put from employees;]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS下安装Python]]></title>
    <url>%2F2019%2F08%2F24%2FCentOS%E4%B8%8B%E5%AE%89%E8%A3%85Python%2F</url>
    <content type="text"><![CDATA[centos下如何安装python方法一(不推荐，适合于安装一次，第二次最好不要再用这个脚本)：首先，利用python自带的python2.7.5版本编写一个python的安装脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#coding=utf-8import osimport sys#安装 wget 以及依赖库cmd = 'yum install -y wget &amp;&amp; yum groupinstall "Development tools" &amp;&amp; yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel'res = os.system(cmd)if res != 0: print('安装依赖库失败，请检查repo库或者网络是否链接') sys.exit(1) if os.getuid() == 0: passelse: print('当前用户不是root用户，请以root用户的身份执行脚本') sys.exit(1)version = raw_input('请输入要安装的python版本号：(2.7/3.5)')if version == '2.7': url = 'https://www.python.org/ftp/python/2.7.16/Python-2.7.16.tgz'elif version == '3.5': url = 'https://www.python.org/ftp/python/3.5.6/Python-3.5.6.tgz'else: print('请输入2.7或者3.5') sys.exit(1)cmd = 'wget ' + urlres = os.system(cmd)package_name = ''if res != 0: print('下载源码包失败，请检查网络') sys.exit(1)if version == '2.7': package_name = 'Python-2.7.16' python_dir_name = 'python2_7_16' ver = 'python'else: package_name = 'Python-3.5.6' python_dir_name = 'python3_5_6' ver = 'python3'cmd = 'tar -xf ' + package_name + '.tgz'res = os.system(cmd)if res != 0: os.system('rm -rf ' + package_name + '.tgz') print('解压源码包失败，请重新运行这个脚本下载源码包') sys.exit(1)cmd = 'cd ' + package_name + '&amp;&amp; ./configure --prefix=/usr/local/'+ python_dir_name + ' &amp;&amp; make &amp;&amp; make install'res = os.system(cmd)if res != 0: print('编译python源码失败，请检查是否缺少依赖库') sys.exit(1)cmd = 'mv /usr/bin/python /usr/bin/python2.7.5 &amp;&amp; ln -s /usr/local/' + python_dir_name+ '/bin/' + ver + ' /usr/bin/python'res = os.system(cmd)if res != 0: print('建立软连接失败，请检查/usr/bin 与 /usr/local 目录') 安装完成后，会发现yum无法使用在终端下执行： vi usr/bin/yum vi /usr/libexec/urlgrabber-ext-down 第一行的python均修改为python2 方法二：在终端执行以下操作： yum install -y wget &amp;&amp; yum groupinstall “Development tools” &amp;&amp; yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel wget https://www.python.org/ftp/python/2.7.16/Python-2.7.16.tgz tar -xf Python-2.7.16.tgz cd Python2.7.16 ./configure –prefix=/usr/local/python2_7_16 make &amp;&amp; make install mv /usr/bin/python /usr/bin/python2.7.5 注意，这里给以前的软连接重命名之后，执行对应的重命名名称即可执行以前的python版本，比如上边的python2.7.5 嘟嘟嘟，请注意啦！解释： 比如，输入 python 进入2.7.16 的python版本 | 输入python2.7.5进入2.7.5的python版本 与 mv /usr/bin/python /usr/bin/python2.7.5 命令的python2.7.5息息相关，这只是个名字，可以随便起 比如也可以把这条命令写成 mv /usr/bin/python /usr/bin/python275，执行 python275 效果是一样的 设置软连接 ln -s /usr/local/python2_7_16/bin/python /usr/bin/python 安装完成后，会发现yum无法使用： vi .usr/bin/yum vi /usr/libexec/urlgrabber-ext-down 第一行的python均修改为python2 嘟嘟嘟，请注意啦！特别注意： mv /usr/bin/python /usr/bin/python2.7.5 与 mv /usr/bin/python/ /usr/bin/python2.7.5/ 完全不同，这一点多加注意我的朋友们 /usr/bin 是一个很重要的文件，最开始的时候 /usr/bin/python -&gt; python2的一个软连接 由于我们执行了 mv /usr/bin/python /usr/bin/python2.7.5 ， 给软连接重命名，就变成了 /usr/bin/python2.7.5 -&gt; python2，以后再想执行python2这个版本的python，可以使用python2.7.5 没有了 /usr/bin/python这个软连接了，于是我们就可以新建一个/usr/bin/python软连接了 ln -s /usr/local/python2_7_16/bin/python /usr/bin/python来设置自己的软连接，以后在终端输入python就是自己设置的版本的python了，大概就是这个意思 实际情况展示： 12345[root@localhost python_dir]# ll /usr/bin/pyth*lrwxrwxrwx. 1 root root 34 8月 11 22:51 /usr/bin/python -&gt; /usr/local/python2_7_16/bin/pythonlrwxrwxrwx. 1 root root 9 8月 11 21:25 /usr/bin/python2 -&gt; python2.7-rwxr-xr-x. 1 root root 7136 8月 4 2017 /usr/bin/python2.7lrwxrwxrwx. 1 root root 7 8月 11 21:25 /usr/bin/python2.7.5 -&gt; python2 特别问题：*为软连接重命名，但是软连接中已经有/usr/bin/python2.7.5这个名字了* 1234567[root@localhost python_dir]# mv /usr/bin/python /usr/bin/python2.7.5mv：是否覆盖&quot;/usr/bin/python2.7.5&quot;？ y[root@localhost python_dir]# ll /usr/bin/pyth*lrwxrwxrwx. 1 root root 9 8月 11 21:25 /usr/bin/python2 -&gt; python2.7-rwxr-xr-x. 1 root root 7136 8月 4 2017 /usr/bin/python2.7lrwxrwxrwx. 1 root root 34 8月 11 22:51 /usr/bin/python2.7.5 -&gt; /usr/local/python2_7_16/bin/python 细心的话会发现： lrwxrwxrwx. 1 root root 7 8月 11 21:25 /usr/bin/python2.7.5 -&gt; python2 被覆盖了 其实没多大影响，要是还是想用2.7.5版本的python，输入 python2 即可，因为python2指向python2.7 lrwxrwxrwx. 1 root root 9 8月 11 21:25 /usr/bin/python2 -&gt; python2.7 或者自己重新为python2自定义添加一个软链接： 1[root@localhost python_dir]# ln -s /usr/bin/python2 /usr/bin/python275 想使用python2.7版本的python的时候，在终端输入 python275 即可]]></content>
      <categories>
        <category>Linux</category>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo&NexT的相关配置]]></title>
    <url>%2F2019%2F08%2F22%2FHexo-NexT%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[如何安装hexo博客框架与next主题，还有如何把博客静态资源部署到远端github上，请参考这位大神的个人博客：http://gonghonglou.com/2016/02/03/firstblog/ 接下来所介绍的是安装完hexo之后的具体配置。 Hexo与NexT的配置注意：每次对hexo和next作出修改时，都要执行： 1234hexo cleanhexo ghexo s //本地部署hexo d //远端部署 没有部署到远端的（比如github或者coding）童鞋，使用hexo s开启服务在本地进行测试，无需执行hexo d。 如果出现了端口正在运行无法使用的情况 FATAL Port 4000 has been used. Try other port instead.FATAL Something’s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: listen EADDRINUSE: address already in use :::4000 可以这样解决： sudo lsof -i :4000 [shang@11:06:24]~/blog$ sudo lsof -i :4000COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnode 13676 root 36u IPv6 0x783f5ae0b80a0c4b 0t0 TCP *:terabase (LISTEN) sudo kill -9 13676 这样端口4000下的进程就被杀死了。 如果上传到远端出现这种情况: xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrunFATAL Something’s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess. (/Users/mac/blog/node_modules/hexo-util/lib/spawn.js:52:19) at ChildProcess.emit (events.js:198:13) at Process.ChildProcess._handle.onexit (internal/child_process.js:248:12) 是因为缺少xcode的组件,安装一下就好了 1xcode-select --install 创建博客 hexo new &quot;test&quot; 之后就会在/blog/source/_posts/建立一个名为 test.md 的文件 开始编写： 12345678910111213141516171819---title: 个人简介date: 2019-08-20 23:11:27tags: - 简介 - 尚先森categories: 个人介绍---# 个人介绍##基本资料 姓名：尚用正 性别：男 年龄：保密 居住地：天津 所在学校：内蒙古农业大学 跳转页面配置基本配置请参考：https://theme-next.iissnan.com/getting-started.html 增加完各个选项后直接点击的话会报错，原因是找不到文件，那么如何添加跳转的页面呢？在blog目录下执行（举个例子）： 1hexo n page tags 之后就会在/blog/source/tags/index.md下建立一个index文件继续编辑index.md文件修改title名称为’标签’ title: 标签 比如加上： type: “tags” 头像配置在/blog/themes/next/_config.yml文件下，搜索 avatar 这个关键字 avatar: https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1804160177,2244151847&amp;fm=26&amp;gp=0.jpg图片可以是本地，也可以是网络上的图片 增加侧边栏地址链接在/blog/themes/next/_config.yml文件下，搜索 social 这个关键字 例如： 123social: GitHub: https://github.com/shang-code || github E-Mail: mailto:syz15822409222@126.com || envelope 添加友情链接在/blog/themes/next/_config.yml文件下，搜索 links 这个关键字 123456links_icon: linklinks_title: 学习社区links_layout: block#links_layout: inlinelinks: 菜鸟: http://www.runoob.com/ 与上面相似，不再赘述。 显示阅读全文在/blog/themes/next/_config.yml文件下，搜索 auto_excerpt 这个关键字 123auto_excerpt: enable: true length: 150 或者可以在md文件的任意地方输入：&lt;!-- more --&gt;下面的内容就会不见，只有点击阅读全文才可以看到下面的内容 增加打赏功能在/blog/themes/next/_config.yml文件下，搜索 rew 这个关键字 123reward_comment: 喜欢的朋友可以打个赏^ _ ^wechatpay: /images/weixin.pngalipay: /images/zhifubao.png 注：下面所有需要用到的图片放在 /blog/themes/next/source/images 下 增加个人二维码 在/blog/themes/next/_config.yml文件下，搜索 wechat 这个关键字 1234wechat_subscriber: enabled: true qcode: /images/syz.png description: 有任何问题可以扫描上方二维码私聊我哦😊 设置头像可旋转在 /blog/themes/next/source/css/_common/components/sidebar/sidebar-author.styl中进行编辑 12345678910111213.site-author-image &#123;display: block;margin: 0 auto;padding: $site-author-image-padding;max-width: $site-author-image-width;height: $site-author-image-height;border: $site-author-image-border-width solid $site-author-image-border-color;border-radius: 50%;transition: 2s all;&#125;.site-author-image:hover&#123;transform: rotate(360deg);&#125; 设置动态背景在/blog/themes/next/_config.yml文件下，搜索canvas 这个关键字 想要使用哪个，把哪个改为 ture 1234567891011# Canvas-nestcanvas_nest: false# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: true 设置 fork github链接样式一：https://blog.github.com/2008-12-19-github-ribbons/链接样式二：http://tholman.com/github-corners/ 在 /blog/themes/next/layout/_layout.swig打开文件找到第23行在这一行的下面输入： 1&lt;a href="https://github.com/shang-code/" class="github-corner" aria-label="View source on GitHub"&gt;&lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt;&lt;path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"&gt;&lt;/path&gt;&lt;path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"&gt;&lt;/path&gt;&lt;path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 开头的 href 改为自己的github地址即可 修改内链接样式在/blog/themes/next/source/css/_common/components/post/post.styl打开文件在最下边增加以下内容： 12345678.post-body p a&#123; color: #EEDC82; border-bottom: none; &amp;:hover&#123; color: #FFC125; font-size: 20px; &#125;&#125; 更改标签图标图标网址：https://www.easyicon.net/1158252-tag_icon.html在/blog/themes/next/layout/_macro/post.swig打开文件找到359行： 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;img src="/images/tag.png"&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 评论一：添加valine评论功能（简洁）网址：https://leancloud.cn/dashboard/applist.html#/apps 创建应用创建完成后会有一个小齿轮（设置），进入之后点击应用key复制App ID 与 App key 然后分别粘贴到下面文件中的对应位置 在/blog/themes/next/_config.yml文件下，搜索 valine 这个关键字 12345678910valine: enable: true appid: hU7o1mDSLSyDeK4wE4hDgcIG-gzGzoHsz # your leancloud application appid appkey: SezjNE3ljsOzb5og8uQs51FR # your leancloud application appkey notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 具体配置参考：https://valine.js.org 评论二：增加来必力评论（加载慢）网址：https://www.livere.com 注册登陆后，点击首页上的安装点击免费安装输入https://shang-code.cn地址等就会出现一个有代码的界面复制里面的data-uid 在/blog/themes/next/_config.yml文件下，搜索 livere 这个关键字在对应的位置进行粘贴 1livere_uid: MTAyMC80NjE5Ni8yMjcwNw== 增加搜索功能网址：https://theme-next.iissnan.com/getting-started.html 点击首页的 第三方服务找到搜索服务 在/blog下执行 1npm install hexo-generator-searchdb --save 在/blog/_config.yml文件下添加 12345search: path: search.xml field: post format: html limit: 10000 在/blog/themes/next/_config.yml文件下，搜索 local_search 这个关键字 123# Local searchlocal_search: enable: true 增加不蒜子统计功能网址：https://theme-next.iissnan.com/getting-started.html 点击首页的 第三方服务找到不蒜子统计参照上面的内容，在下面的文件中分别进行填写 在/blog/themes/next/_config.yml文件下，搜索 busuanzi_count 这个关键字 123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: 本站访问数&lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: 人次 # custom pv span for the whole site site_pv: true site_pv_header: 本站总访问量&lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: 本文总阅读数&lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer: 次 问题：如果无法显示数字: 解决办法： 先找到NexT下引用不蒜子统计的方法。文件路径为/theme/next/layout/_third-party/analytics/busuanzi-counter.swig文件。替换链接部分即可。替换为”https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot; 增加内容分享服务 我配置这个有问题，日后再做分析吧！ 网址：https://theme-next.iissnan.com/getting-started.html 点击首页的 第三方服务找到内容分享服务 在/blog/themes/next/_config.yml文件下，搜索 jiathis 这个关键字 12jiathis: true ##uid: Get this uid from http://www.jiathis.com/ 增加加载效果在/blog/themes/next/_config.yml文件下，搜索 pace 这个关键字 123456789101112131415161718pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-bounce pace_theme的参数在上面随便选择一个即可，不唯一 设置点击爆炸效果参考网址：https://blog.csdn.net/qq_38332436/article/details/82724672 首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下： 1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码： 12345&#123;% if theme.fireworks %&#125; &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 在/blog/themes/next/_config.yml文件，在里面最后写下： 12# Fireworksfireworks: true 增加点击出现小红心效果在/themes/next/source/js/src下新建文件love.js，并复制粘贴如下代码 1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\themes\next\layout\_layout.swig文件的&lt;body&gt;标签最后添加 12&lt;!-- 页面点击小红心，在末尾添加，避免找不到 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 解决来必力加载慢问题我们打开/blog/themes/next/layout/_partials/comments.swig 将这段代码 123&lt;div class="comments" id="comments"&gt; &lt;div id="lv-container" data-id="city" data-uid="&#123;&#123; theme.livere_uid &#125;&#125;"&gt;&lt;/div&gt;&lt;/div&gt; 改成 1&lt;iframe title="livere" src="https://was.livere.me/comment/city?id=city&amp;refer=&#123;&#123;page.permalink&#125;&#125;&amp;uid=&#123;&#123;theme.livere_uid&#125;&#125;&amp;site=&#123;&#123;page.permalink&#125;&#125;&amp;title=&#123;&#123;page.title&#125;&#125;" scrolling="" frameborder="0" id="lv-comment-399" style="min-width: 100%; width: 100px; min-height: 400px; overflow: auto; border: 0px; z-index: 124212; height: 800px;" &gt;&lt;/iframe&gt; 添加live2D参考网址：https://sevencho.github.io/archives/cb206c67.html 在/blog下执行： 1npm install --save hexo-helper-live2d 如果不想使用、想彻底卸载，命令如下： 1npm uninstall hexo-helper-live2d 对应的模块下载:https://github.com/xiazeyu/live2d-widget-models 动画模型效果:https://huaji8.top/post/live2d-plugin-2.0/ 手动下载完成之后将packages里面的所有文件拷贝到博客根目录的node_moduels文件夹下 打开博客根目录的配置文件_config.yml，添加如下内容： 12345678910111213141516171819202122# Live2D## https://github.com/xiazeyu/live2d-widget.js## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 use: live2d-widget-model-tororo // 下载的动画模型名称 display: superSample: 2 width: 120 height: 200 position: left // 模型在网页显示位置 hOffset: 20 vOffset: 50 mobile: show: true // 移动设备是否显示 scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 如果你想发布自己的Live2D动画模型包，可以参考如下步骤：新建一个目录, 在终端下切换目录到新建的目录中，执行 npm init, 包名推荐格式如：live2d-widget-model-xxx。在刚刚创建的目录下创建 assets 子目录, 把你的模型文件放进去.在live2d-widget-model-xxx目录下执行 npm publish 命令来发布.此时就在/blog目录下使用 npm install --save live2d-widget-model-xxx 来安装自定义的模型包了。安装完成后就可以在配置文件_config.yml中 model:use 修改包名来使用了. 在文章末尾增加版权声明参考网址：https://www.jianshu.com/p/93170e7413e9 在目录 themes/next/layout/_macro/ 下添加 my-copyright.swig ，内容如下： 123456789101112131415161718192021222324252627282930313233&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm:ss") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm:ss") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125; 在目录 themes/next/source/css/_common/components/post/ 下添加 my-post-copyright.styl，内容如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #333333; // title color font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #0593d3; // link color text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改 themes/next/layout/_macro/post.swig，如下：修改前： 12345&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125; &lt;div&gt; &#123;% include 'wechat-subscriber.swig' %&#125; &lt;/div&gt;&#123;% endif %&#125; 修改后： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 打开 themes/next/source/css/_common/components/post/post.styl 文件，在最后一行增加代码： 1@import "my-post-copyright" 设置新建文章自动开启 copyright ，即新建文章自动显示自定义的版权声明，设置 /bolg/scaffolds/post.md 文件，如下： 12345---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;copyright: true #新增,开启--- 增加RSS插件在 /blog下执行： 1npm install hexo-generator-feed --save 在/blog下的_config.yml下添加： 12345678# Extensionsplugins: hexo-generator-feed#Feed Atomfeed: type: atom path: atom.xml limit: 20 在/blog/themes/next/_config.yml文件找到rss 1rss: /atom.xml 隐藏底部强力驱动在/blog/themes/next/layout/_partials/下打开footer.swig文件 123456789101112131415161718&lt;!-- &#123;% if theme.footer.powered %&#125; &lt;div class="powered-by"&gt;&#123;# #&#125;&#123;&#123; __('footer.powered', '&lt;a class="theme-link" target="_blank" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class="theme-info"&gt;&#123;# #&#125;&#123;&#123; __('footer.theme') &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next"&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125; --&gt; 将这一段用 &lt;!-- --&gt;扩起来 字数统计与阅读时长在/blog/themes/next/下的_config.yml文件中搜索post_wordcount字段 123456post_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 为了让效果好一点，修改/blog/themes/next/layout/_macro/post.swig文件 修改字数统计，找到如下代码： 123&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt; 添加 “字” 到 1&#123;&#123; wordcount(post.content) &#125;&#125; 后面，修改后为： 123&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; 同理，我们修改阅读时长，修改后如下： 123&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 效果图如下： 如果出现没有数字的情况，尝试执行下面这条（安装）命令： 1npm i --save hexo-wordcount 添加背景图在themes/next/source/css/_custom/custom.styl文件中添加： 123456789101112131415161718body &#123;background: url(https://source.unsplash.com/random/1600x900?wallpapers);background-size: cover;background-repeat: no-repeat;background-attachment: fixed;background-position: 50% 50%;&#125;// 修改主体透明度.main-inner &#123; background: #fff; opacity: 0.9;&#125;// 修改菜单栏透明度.header-inner &#123; opacity: 0.9;&#125; background: url() 中填写的是背景图片的 url 地址, 这里调用了 Unsplash 的 API, 随机选用该网站的高清美图作为博客背景.opacity 指定了对应元素的透明度, 这里是 “0.8”, 可以按需更改. 修改行内代码块样式打开 themes\next\source\css\_custom\custom.styl，添加如下样式： 1234567/* 行内代码块的自定义样式 */code &#123; color: #d500fc; background: rgba(78, 240, 233, 0.42); margin: 2px; border: 1px solid #d6d6d6;&#125; 去掉图片边框NexT主题默认会有图片边框，不太好看，我们可以把边框去掉。打开 themes\next\source\css\_custom\custom.styl，添加如下CSS代码： 12345678/* 去掉图片边框 */.posts-expand .post-body img &#123; border: none; padding: 0px;&#125;.post-gallery .post-gallery-img img &#123; padding: 3px;&#125; 修改鼠标样式打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码 1234567// 鼠标样式 * &#123; cursor: url("https://www.easyicon.net/api/resizeApi.php?id=1124585&amp;size=24"),auto!important &#125; :active &#123; cursor: url("https://www.easyicon.net/api/resizeApi.php?id=1124585&amp;size=24"),auto!important &#125; 修改网页底部的图标还是打开themes/next/layout/_partials/footer.swig，找到： 123&lt;span class="with-love"&gt;...&lt;/span&gt; 把中间内容删除，在中间添加如下代码： 1&lt;img src="https://www.easyicon.net/api/resizeApi.php?id=1200645&amp;size=16"&gt; 点开文章在新的标签页打开打开 themes\next\layout\_macro\post-collapse.swig 找到如下区域代码： 1234567&lt;a class="post-title-link" href="&#123;&#123; url_for(post.path) &#125;&#125;" itemprop="url"&gt; &#123;% if post.type === 'picture' %&#125; &#123;&#123; post.content &#125;&#125; &#123;% else %&#125; &lt;span itemprop="name"&gt;&#123;&#123; post.title | default(__('post.untitled')) &#125;&#125;&lt;/span&gt; &#123;% endif %&#125;&lt;/a&gt; 接着打开 themes\next\layout\_macro\post.swig 找到如下区域代码： 123&lt;a class="post-title-link" href="&#123;&#123; url_for(post.path) &#125;&#125;" itemprop="url"&gt;&#123;# #&#125;&#123;&#123; post.title | default(__('post.untitled'))&#125;&#125;&#123;# #&#125;&lt;/a&gt; 在两个文件的如上两个位置的class属性后添加 target=&quot;_blank&quot; 添加DaoVoice 实现在线联系参考网址：https://blog.csdn.net/weixin_43998150/article/details/84861684#修改顶部菜单与下方信息栏的间隙大小 本功能可以实现在线留言，作者会收到邮件，如果绑定了微信，作者还会收到微信通知。首先到http://dashboard.daovoice.io注册一个Daovioce账号。注册完成后会进到DaoCloud，重新访问连接即可。进到Daovoice面板，点击左侧边栏的应用设置– 安装到网站。在下方的代码中会看到app_id: “xxxx”字样。 复制这个app_id 打开 themes/next/layout/_partials/head/head.swig 文件中最下方加入如下代码： 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice_app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 在主题配置文件 _config.yml，添加如下代码： 123# DaoVoice daovoice: truedaovoice_app_id: 这里输入前面获取的app_id 回到Daovoice控制面板，点击聊天设置可以对聊天图标的颜色及位置进行设置。 修改主题背景色打开hexo/themes/next/source/css/_variables/base.styl找到Colors代码段，如下： 123456789101112131415161718// Colors// colors for use across theme.// -------------------------------------------------- $whitesmoke = #f5f5f5 $gainsboro = #eee //这个是边栏头像外框的颜色， $gray-lighter = #ddd //文章中插入图片边框颜色 $grey-light = #ccc //文章之间分割线、下划线颜色 $grey = #bbb //页面选中圆点颜色 $grey-dark = #999 $grey-dim = #666 //侧边栏目录字体颜色 $black-light = #555 //修改文章字体颜色 $black-dim = #333 $black-deep = #495a80 //修改主题的颜色 $red = #ff2a2a $blue-bright = #87daff $blue = #0684bd $blue-deep = #262a30 $orange = #F39D01 //浏览文章时，目录选中的颜色 修改Pisces主题的宽度在source/css/_schemes/Picses/_layout.sty⽂件末尾添加如下代码: 12345678910111213141516171819202122232425262728293031// 以下为新增代码！！header&#123; width: 90% !important; &#125;header.post-header &#123; width: auto !important;&#125;.container .main-inner &#123; width: 90%; &#125;.content-wrap &#123; width: calc(100% - 260px); &#125;.header &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.container .main-inner &#123; +tablet() &#123; width: auto !important; &#125; +mobile() &#123; width: auto !important; &#125;&#125;.content-wrap &#123; +tablet() &#123; width: 100% !important; &#125; +mobile() &#123; width: 100% !important; &#125;&#125;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql基础操作]]></title>
    <url>%2F2019%2F08%2F20%2FMysql%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Mysql基础操作安装Mysql网址：https://dev.mysql.com/downloads/mysql/Linux请参考：https://www.runoob.com/mysql/mysql-install.html 查看mysql是否安装 1#rpm -qa | grep mysql 删除 12#rpm -e mysql // 普通删除模式#rpm -e --nodeps mysql // 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除 下载、安装 1234#wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm#rpm -ivh mysql-community-release-el7-5.noarch.rpm#yum update#yum install mysql-server 设置权限 1#chown mysql:mysql -R /var/lib/mysql 初始化 1#mysqld --initialize 启动服务 1#systemctl start mysqld 查看运行状态: 1#systemctl status mysqld 查看版本 1#mysqladmin --version 如果mysql版本为5.7以上，默认会生成一个随机密码 查看随机密码方式： 1#grep password /var/log/myswld.log 设置root密码 1#mysqladmin -u root password &quot;new_password&quot;; 基本设置登陆 1#mysql -u root -p 如果显示找不到： 设置软连接 1#ln -s /usr/local/mysql/bin/mysql /usr/local/bin/ 修改root密码 5.7.6以后的版本 1ALTER USER 'root'@'localhost' IDENTIFIED BY 'new_password'; 或者 1ALTER USER USER() IDENTIFIED BY 'shang'; 5.7.6以前的版本 1SET PASSWORD = PASSWORD('shang'); 导入mysql文件Macx下： source + 文件路径（直接拖拽进入即可）; Linux下： 123#wget https://downloads.mysql.com/docs/sakila-db.tar.gz#tar -xf sakila-db.tar.gz#cd sakila-db 在数据库中新建一个和要导入的数据库名称相同的数据库,然后退出Mysql 格式：mysql -u 用户名 -p 数据库名 &lt; 数据库名.sql; 12#mysql -u root -p sakila &lt; sakila-schema.sql;#mysql -u root -p sakila &lt; sakila-data.sql; 或者在数据库中新建一个和要导入的数据库名称相同的数据库（或者可以不用新建吧，忘记了），然后在Mysql中输入 source sql文件路径; 基础查询查看Mysql的版本 1mysql --version 查看所有database 1show databases; 查看所有table 首先要使用 use 数据库名选中数据库; 1show tables; 显示数据库表的属性等 1show columns from 表名; 显示数据表的详细索引信息 1show index from 表名; 显示Mysql数据库的管理系统的性能和统计信息。 show table status from 数据库名; 例子： 123show table status from test_db; //所有表的信息show table status from test_db like 'test%'; //以test开头的表的信息show table status from test_db like 'test%'\G; //查询结果按列打印 Mysql常用命令查看当前所有的数据库 1show databases; 打开指定的库 1use database_name; 查看当前库的所有表 1show tables; 查看其他库的所有表 1show tables from database_name; 创建表 12345create table table_name( columns_name colunms_type, columns_name colunms_type, ...) 查看表结构 1desc table_name; 查看服务器的版本 方式一：登陆到mysql服务端 1select version(); 方式二：没有登陆到mysql服务端 1#mysql --version 或者 #mysql -V 设置字符集 1set names utf8; Mysql之注释 单行注释：#注释文字 多行注释：/* 注释文字 */]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql开篇</tag>
      </tags>
  </entry>
</search>
